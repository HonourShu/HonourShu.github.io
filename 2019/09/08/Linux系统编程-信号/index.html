<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>Linux系统编程-信号 | 庸的博客 | 爱代码,爱生活~</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content>
    <link rel="shortcut icon" href="/img/yong.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	false,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/yong.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">HSR</h5>
          <a href="mailto:461467948@qq.com" title="461467948@qq.com" class="mail">
            
              <span>4</span>
            
              <span>6</span>
            
              <span>1</span>
            
              <span>4</span>
            
              <span>6</span>
            
              <span>7</span>
            
              <span>9</span>
            
              <span>4</span>
            
              <span>8</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/HonourShu" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>Linux系统编程-信号</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">Linux系统编程-信号</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-09-08T02:30:53.000Z" itemprop="datePublished" class="page-time">
  2019-09-08
</time>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-Linux系统编程-信号"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">Linux系统编程-信号</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-09-08 10:30:53" datetime="2019-09-08T02:30:53.000Z"  itemprop="datePublished">2019-09-08</time>

            


            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a><strong>信号的概念</strong></h2><p>信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪……他们都有共性：1. 简单 2. 不能携带大量信息 3. 满足某个特设条件才发送。</p>
<p>​    信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p>
<p>​    Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p>
<h3 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a><strong>信号的机制</strong></h3><p>​    A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</p>
<p><strong>信号的特质</strong>：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p>​    <strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p>
<h3 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a><strong>与信号相关的事件和状态</strong></h3><p>​    <strong>产生信号</strong>: </p>
<ol>
<li><p>按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</p>
</li>
<li><p>系统调用产生，如：kill、raise、abort</p>
</li>
<li><p>软件条件产生，如：定时器alarm</p>
</li>
<li><p>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</p>
</li>
<li><p>命令产生，如：kill命令</p>
</li>
</ol>
<p>​    <strong>递达</strong>：递送并且到达进程。</p>
<p>​    <strong>未决</strong>：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 </p>
<p>​    <strong>信号的处理方式:</strong> </p>
<ol>
<li><p>执行默认动作 </p>
</li>
<li><p>忽略(丢弃) </p>
</li>
<li><p>捕捉(调用户处理函数)</p>
</li>
</ol>
<p>​    Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</p>
<p>​    <strong>阻塞信号集(信号屏蔽字)</strong>： 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)</p>
<p><strong>未决信号集</strong>: </p>
<ol>
<li><p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 </p>
</li>
<li><p>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。    </p>
</li>
</ol>
<h3 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a><strong>信号的编号</strong></h3><p>可以使用kill –l命令查看当前系统可使用的信号有哪些。</p>
<p>1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL         5) SIGTRAP</p>
<p> 6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1</p>
<p>11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM</p>
<p>16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP</p>
<p>21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ</p>
<p>26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR</p>
<p>31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3</p>
<p>38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8</p>
<p>43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13</p>
<p>48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12</p>
<p>53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7</p>
<p>58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2</p>
<p>63) SIGRTMAX-1    64) SIGRTMAX</p>
<p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</p>
<h3 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h3><p>与变量三要素类似的，每个信号也有其必备4要素，分别是：</p>
<ol>
<li>编号 2. 名称 3. 事件 4. 默认处理动作 </li>
</ol>
<p>可通过man 7 signal查看帮助文档获取。也可查看/usr/src/linux-headers-3.16.0-30/arch/s390/include/uapi/asm/signal.h</p>
<p>Signal         Value     Action   Comment</p>
<p>────────────────────────────────────────────</p>
<p>SIGHUP          1       Term    Hangup detected on controlling terminal or death of controlling process</p>
<p>SIGINT           2       Term    Interrupt from keyboard</p>
<p>SIGQUIT          3       Core    Quit from keyboard</p>
<p>SIGILL            4       Core    Illegal Instruction</p>
<p>SIGFPE           8       Core    Floating point exception</p>
<p>SIGKILL           9       Term    Kill signal</p>
<p>SIGSEGV         11      Core    Invalid memory reference</p>
<p>SIGPIPE       13      Term    Broken pipe: write to pipe with no readers</p>
<p>SIGALRM        14      Term    Timer signal from alarm(2)</p>
<p>SIGTERM         15      Term    Termination signal</p>
<p>SIGUSR1   30,10,16    Term    User-defined signal 1</p>
<p>SIGUSR2   31,12,17    Term    User-defined signal 2</p>
<p>SIGCHLD   20,17,18    Ign     Child stopped or terminated</p>
<p>SIGCONT   19,18,25    Cont    Continue if stopped</p>
<p>SIGSTOP   17,19,23    Stop    Stop process</p>
<p>SIGTSTP   18,20,24    Stop    Stop typed at terminal</p>
<p>SIGTTIN   21,21,26    Stop    Terminal input for background process</p>
<p>SIGTTOU   22,22,27   Stop    Terminal output for background process</p>
<p>The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.       </p>
<p>在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。</p>
<p>不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。</p>
<p>​    默认动作：</p>
<p>​        Term：终止进程</p>
<p>​        Ign： 忽略信号 (默认即时对该种信号忽略操作)</p>
<p>​        Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)</p>
<p>​        Stop：停止（暂停）进程</p>
<p>​        Cont：继续运行进程</p>
<p>   注意从man 7 signal帮助文档中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</p>
<p>   这里特别强调了<strong>9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<p>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！</p>
<h3 id="Linux常规信号一览表"><a href="#Linux常规信号一览表" class="headerlink" title="Linux常规信号一览表"></a><strong>Linux常规信号一览表</strong></h3><p>1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程</p>
<p>2) SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</p>
<p>3) SIGQUIT：当用户按下&lt;ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</p>
<p>4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件</p>
<p>5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。</p>
<p>6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。</p>
<p>7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</p>
<p>8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。</p>
<p>9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</p>
<p>10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p>
<p>11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。</p>
<p>12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p>
<p>13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。</p>
<p>14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。</p>
<p>15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。</p>
<p>16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</p>
<p>17) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。</p>
<p>18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。</p>
<p>19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</p>
<p>20) SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</p>
<p>21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</p>
<p>22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</p>
<p>23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</p>
<p>24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。</p>
<p>25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</p>
<p>26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。</p>
<p>27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。</p>
<p>28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</p>
<p>29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。</p>
<p>30) SIGPWR：关机。默认动作为终止进程。</p>
<p>31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。</p>
<p>34) SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。</p>
<h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a><strong>信号的产生</strong></h2><h3 id="终端按键产生信号"><a href="#终端按键产生信号" class="headerlink" title="终端按键产生信号"></a><strong>终端按键产生信号</strong></h3><p>​    Ctrl + c  → 2) SIGINT（终止/中断）     “INT” —-Interrupt</p>
<p>​    Ctrl + z  → 20) SIGTSTP（暂停/停止）  “T” —-Terminal 终端。</p>
<p>​    Ctrl + \  → 3) SIGQUIT（退出）    </p>
<h3 id="硬件异常产生信号"><a href="#硬件异常产生信号" class="headerlink" title="硬件异常产生信号"></a><strong>硬件异常产生信号</strong></h3><p>​    除0操作   → 8) SIGFPE (浮点数例外)    “F” —–float 浮点数。</p>
<p>​    非法访问内存  → 11) SIGSEGV (段错误)</p>
<p>​    总线错误  → 7) SIGBUS    </p>
<h3 id="kill函数-命令产生信号"><a href="#kill函数-命令产生信号" class="headerlink" title="kill函数/命令产生信号"></a><strong>kill函数/命令产生信号</strong></h3><p>kill命令产生信号：kill -SIGKILL pid</p>
<p>kill函数：给指定进程发送指定信号(不一定杀死)</p>
<p>​    int kill(pid_t pid, int sig);     成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno</p>
<p>​    sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</p>
<p>​    pid &gt; 0:  发送信号给指定的进程。</p>
<p>​    pid = 0:  发送信号给 与调用kill函数进程属于同一进程组的所有进程。</p>
<p>​    pid &lt; 0:  取|pid|发给对应进程组。</p>
<p>​    pid = -1：发送给进程有权限发送的系统中所有进程。</p>
<p>​    进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 kill -9 (root用户的pid)  是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID == 接收者实际或有效用户ID</p>
<h3 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a><strong>raise和abort函数</strong></h3><p>​    raise 函数：给当前进程发送指定信号(自己给自己发)    raise(signo) == kill(getpid(), signo);</p>
<p>​        int raise(int sig); 成功：0，失败非0值</p>
<p>​    abort 函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件</p>
<p>​        void abort(void); 该函数无返回</p>
<h3 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a><strong>软件条件产生信号</strong></h3><h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a><strong>alarm函数</strong></h4><p>设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。</p>
<p><strong>每个进程都有且只有唯一个定时器。</strong></p>
<p>unsigned int alarm(unsigned int seconds); 返回0或剩余的秒数，无失败。</p>
<p>​    常用：取消定时器alarm(0)，返回旧闹钟余下秒数。</p>
<p>​    例：alarm(5) → 3sec → alarm(4) → 5sec → alarm(5) → alarm(0)</p>
<p>​    定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。</p>
<h4 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a><strong>setitimer函数</strong></h4><p>​    设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。</p>
<p>​    int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);    成功：0；失败：-1，设置errno</p>
<p>​    参数：which：指定定时方式</p>
<p>​        ① 自然定时：ITIMER_REAL → 14）SIGLARM                         计算自然时间</p>
<p>​        ② 虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM       只计算进程占用cpu的时间</p>
<p>​        ③ 运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF         计算占用cpu及执行系统调用的时间</p>
<h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a><strong>信号集操作函数</strong></h2><p>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。</p>
<h3 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a><strong>信号集设定</strong></h3><p>​    sigset_t  set;        // typedef unsigned long sigset_t; </p>
<p>​    int sigemptyset(sigset_t *set);            将某个信号集清0                 成功：0；失败：-1</p>
<p>​    int sigfillset(sigset_t *set);                将某个信号集置1                  成功：0；失败：-1</p>
<p>​    int sigaddset(sigset_t *set, int signum);        将某个信号加入信号集          成功：0；失败：-1</p>
<p>​    int sigdelset(sigset_t *set, int signum);        将某个信号清出信号集           成功：0；失败：-1</p>
<p>​    int sigismember(const sigset_t *set, int signum);判断某个信号是否在信号集中    返回值：在集合：1；不在：0；出错：-1  </p>
<p>​    sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p>
<p>​    对比认知select 函数。</p>
<h3 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a><strong>sigprocmask函数</strong></h3><p>用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)</p>
<p>​    <strong>严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</strong></p>
<p>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);    成功：0；失败：-1，设置errno</p>
<p>参数：</p>
<p>​        set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。</p>
<p>​        oldset：传出参数，保存旧的信号屏蔽集。</p>
<p>​        how参数取值：    假设当前的信号屏蔽字为mask</p>
<ol>
<li><p>SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask|set</p>
</li>
<li><p>SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set</p>
</li>
<li><p>SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p>
</li>
</ol>
<h3 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a><strong>sigpending函数</strong></h3><p>读取当前进程的<strong>未决</strong>信号集</p>
<p>int sigpending(sigset_t *set);    set传出参数。   返回值：成功：0；失败：-1，设置errno</p>
<h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a><strong>信号捕捉</strong></h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a><strong>signal函数</strong></h3><p>注册一个信号捕捉函数：</p>
<p>typedef void (*sighandler_t)(int);</p>
<p>sighandler_t signal(int signum, sighandler_t handler);</p>
<p>​    该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</p>
<p>​    void (<em>signal(int signum, void (</em>sighandler_t)(int))) (int);</p>
<p>​    能看出这个函数代表什么意思吗？  注意多在复杂结构中使用typedef。</p>
<h3 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a><strong>sigaction函数</strong></h3><p>修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数）</p>
<p>​    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);  成功：0；失败：-1，设置errno</p>
<p>参数：</p>
<p>act：传入参数，新的处理方式。</p>
<p>​        oldact：传出参数，旧的处理方式。                                                </p>
<h4 id="struct-sigaction结构体"><a href="#struct-sigaction结构体" class="headerlink" title="struct sigaction结构体"></a><strong>struct sigaction结构体</strong></h4><p>​    struct sigaction {</p>
<p>​        void     (*sa_handler)(int);</p>
<p>​        void     (*sa_sigaction)(int, siginfo_t *, void *);</p>
<p>​        sigset_t   sa_mask; </p>
<p>​        int       sa_flags; </p>
<p>​        void     (*sa_restorer)(void);</p>
<p>​    };</p>
<p>​    sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)</p>
<p>​    sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用)  </p>
<p>重点掌握：</p>
<p>​    ① sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</p>
<p>​    ② sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</p>
<p>​    ③ sa_flags：通常设置为0，表使用默认属性。    </p>
<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a><strong>信号捕捉特性</strong></h4><ol>
<li><p>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。</p>
</li>
<li><p>XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。</p>
</li>
<li><p>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</p>
</li>
</ol>
<h3 id="内核实现信号捕捉过程："><a href="#内核实现信号捕捉过程：" class="headerlink" title="内核实现信号捕捉过程："></a><strong>内核实现信号捕捉过程：</strong></h3> <a rel=Linux系统编程-信号 href="/2019/09/08/Linux系统编程-信号/sig1.png" title="" data-fancybox="images"><img src="/2019/09/08/Linux系统编程-信号/sig1.png"></a>

<h2 id="竞态条件-时序竞态-："><a href="#竞态条件-时序竞态-：" class="headerlink" title="竞态条件(时序竞态)："></a><strong>竞态条件(时序竞态)：</strong></h2><h3 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a><strong>pause函数</strong></h3><p>​    调用该函数可以造成进程主动挂起，等待信号唤醒。调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。</p>
<p>​    int pause(void);    返回值：-1 并设置errno为EINTR</p>
<p>​    返回值：</p>
<p>​        ① 如果信号的默认处理动作是终止进程，则进程终止，pause函数么有机会返回。</p>
<p>​        ② 如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。</p>
<p>​        ③ 如果信号的处理动作是捕捉，则【调用完信号处理函数之后，pause返回-1】</p>
<p>errno设置为EINTR，表示“被信号中断”。想想我们还有哪个函数只有出错返回值。</p>
<p>​        ④ pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。</p>
<h3 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a><strong>时序竞态</strong></h3><h4 id="前导例"><a href="#前导例" class="headerlink" title="前导例"></a><strong>前导例</strong></h4><p>设想如下场景：</p>
<p>​    欲睡觉，定闹钟10分钟，希望10分钟后闹铃将自己唤醒。</p>
<p>​    正常：定时，睡觉，10分钟后被闹钟唤醒。</p>
<p>​    异常：闹钟定好后，被唤走，外出劳动，20分钟后劳动结束。回来继续睡觉计划，但劳动期间闹钟已经响过，不会再将我唤醒。</p>
<h4 id="时序问题分析"><a href="#时序问题分析" class="headerlink" title="时序问题分析"></a><strong>时序问题分析</strong></h4><p>回顾，借助pause和alarm实现的mysleep函数。设想如下时序：</p>
<p>​    1. 注册SIGALRM信号处理函数     （sigaction…)</p>
<p>​    2. 调用alarm(1) 函数设定闹钟1秒。</p>
<p>​    3. 函数调用刚结束，开始倒计时1秒。当前进程失去cpu，内核调度优先级高的进程(有多个)取代当前进程。当前进程无法获得cpu，进入就绪态等待cpu。</p>
<p>​    4. 1秒后，闹钟超时，内核向当前进程发送SIGALRM信号(自然定时法，与进程状态无关)，高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决)</p>
<p>​    5. 优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。SIGALRM信号递达，信号设置捕捉，执行处理函数sig_alarm。</p>
<p>​    6. 信号处理函数执行结束，返回当前进程主控流程，pause()被调用挂起等待。（欲等待alarm函数发送的SIGALRM信号将自己唤醒）</p>
<p>​    7. SIGALRM信号已经处理完毕，pause不会等到。</p>
<h4 id="解决时序问题"><a href="#解决时序问题" class="headerlink" title="解决时序问题"></a><strong>解决时序问题</strong></h4><p>可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这个两个操作间隙失去cpu资源。除非将这两步骤合并成一个“原子操作”。sigsuspend函数具备这个功能。在对时序要求严格的场合下都应该使用sigsuspend替换pause。     </p>
<p>​    int sigsuspend(const sigset_t *mask);    挂起等待信号。</p>
<p>sigsuspend函数调用期间，进程信号屏蔽字由其<strong>参数mask</strong>指定。</p>
<p>​    可将某个信号（如SIGALRM）从临时信号屏蔽字mask中删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，sigsuspend函数返回后仍然屏蔽该信号。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</p>
<p>不可靠由其实现原理所致。信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</p>
<p>这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
<h3 id="全局变量异步I-O"><a href="#全局变量异步I-O" class="headerlink" title="全局变量异步I/O"></a><strong>全局变量异步I/O</strong></h3><p>   分析如下父子进程交替数数程序。当捕捉函数里面的sleep取消，程序即会出现问题。请分析原因</p>
<p>​    示例中，通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。</p>
<p>​    问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。</p>
<p>如何解决该问题呢？可以使用后续课程讲到的“锁”机制。当操作全局变量的时候，通过加锁、解锁来解决该问题。</p>
<p>现阶段，我们在编程期间如若使用全局变量，应在主观上注意<strong>全局变量的异步IO</strong>可能造成的问题。</p>
<h3 id="可-不可重入函数"><a href="#可-不可重入函数" class="headerlink" title="可/不可重入函数"></a><strong>可/不可重入函数</strong></h3><p>​    一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称之为“重入”。根据函数实现的方法可分为“可重入函数”和“不可重入函数”两种。看如下时序。</p>
 <a rel=Linux系统编程-信号 href="/2019/09/08/Linux系统编程-信号/sig2.png" title="" data-fancybox="images"><img src="/2019/09/08/Linux系统编程-信号/sig2.png"></a>

<p>​    显然，insert函数是不可重入函数，重入调用，会导致意外结果呈现。究其原因，是该函数内部实现使用了全局变量。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ol>
<li><p>定义可重入函数，函数内不能含有全局变量及static变量，不能使用malloc、free</p>
</li>
<li><p>信号捕捉函数应设计为可重入函数</p>
</li>
<li><p>信号处理程序可以调用的可重入函数可参阅man 7 signal </p>
</li>
<li><p>没有包含在上述列表中的函数大多是不可重入的，其原因为：</p>
<p>a) 使用静态数据结构</p>
<p>b) 调用了malloc或free</p>
<p>c) 是标准I/O函数</p>
</li>
</ol>
<h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a><strong>SIGCHLD信号</strong></h2><h3 id="SIGCHLD的产生条件"><a href="#SIGCHLD的产生条件" class="headerlink" title="SIGCHLD的产生条件"></a><strong>SIGCHLD的产生条件</strong></h3><p>子进程终止时</p>
<p>子进程接收到SIGSTOP信号停止时</p>
<p>子进程处在停止态，接受到SIGCONT后唤醒时</p>
<h3 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a><strong>借助SIGCHLD信号回收子进程</strong></h3><p>子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</p>
<h3 id="子进程结束status处理方式"><a href="#子进程结束status处理方式" class="headerlink" title="子进程结束status处理方式"></a><strong>子进程结束status处理方式</strong></h3><p>pid_t waitpid(pid_t pid, int *status, int options)</p>
<p>options</p>
<p>WNOHANG</p>
<p>没有子进程结束，立即返回</p>
<p>WUNTRACED</p>
<p>如果子进程由于被停止产生的SIGCHLD，waitpid则立即返回</p>
<p>WCONTINUED</p>
<p>如果子进程由于被SIGCONT唤醒而产生的SIGCHLD，waitpid则立即返回</p>
<p>获取status</p>
<p>WIFEXITED(status)</p>
<p>子进程正常exit终止，返回真</p>
<p>WEXITSTATUS(status)返回子进程正常退出值</p>
<p>WIFSIGNALED(status)</p>
<p>子进程被信号终止，返回真</p>
<p>WTERMSIG(status)返回终止子进程的信号值</p>
<p>WIFSTOPPED(status)</p>
<p>子进程被停止，返回真</p>
<p>WSTOPSIG(status)返回停止子进程的信号值</p>
<p>WIFCONTINUED(status)</p>
<h3 id="SIGCHLD信号注意问题"><a href="#SIGCHLD信号注意问题" class="headerlink" title="SIGCHLD信号注意问题"></a><strong>SIGCHLD信号注意问题</strong></h3><ol>
<li><p>子进程继承了父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集spending。</p>
</li>
<li><p>注意注册信号捕捉函数的位置。</p>
</li>
<li><p>应该在fork之前，阻塞SIGCHLD信号。注册完捕捉函数后解除阻塞。</p>
</li>
</ol>
<h2 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a><strong>信号传参</strong></h2><h3 id="发送信号传参"><a href="#发送信号传参" class="headerlink" title="发送信号传参"></a><strong>发送信号传参</strong></h3><p>sigqueue函数对应kill函数，但可在向指定进程发送信号的同时携带参数</p>
<p>int sigqueue(pid_t pid, int sig, const union sigval value);成功：0；失败：-1，设置errno</p>
<p>​           union sigval {</p>
<p>​               int   sival_int;</p>
<p>​               void *sival_ptr;</p>
<p>​           };</p>
<p>​    向指定进程发送指定信号的同时，携带数据。但，如传地址，需注意，不同进程之间虚拟地址空间各自独立，将当前进程地址传递给另一进程没有实际意义。</p>
<h3 id="捕捉函数传参"><a href="#捕捉函数传参" class="headerlink" title="捕捉函数传参"></a><strong>捕捉函数传参</strong></h3><p>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</p>
<p>​           struct sigaction {</p>
<p>​               void     (*sa_handler)(int);</p>
<p>​               void     (*sa_sigaction)(int, siginfo_t *, void *);</p>
<p>​               sigset_t   sa_mask;</p>
<p>​               int       sa_flags;</p>
<p>​               void     (*sa_restorer)(void);</p>
<p>​           };</p>
<p>​    当注册信号捕捉函数，希望获取更多信号相关信息，不应使用sa_handler而应该使用sa_sigaction。但此时的<strong>sa**</strong>_flags必须指定为SA_SIGINFO**。siginfo_t是一个成员十分丰富的结构体类型，可以携带各种与信号相关的数据。</p>
<h2 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a><strong>中断系统调用</strong></h2><p>系统调用可分为两类：慢速系统调用和其他系统调用。</p>
<ol>
<li><p>慢速系统调用：可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，read、write、pause、wait…</p>
</li>
<li><p>其他系统调用：getpid、getppid、fork…</p>
</li>
</ol>
<p>结合pause，回顾慢速系统调用：</p>
<p>​    慢速系统调用被中断的相关行为，实际上就是pause的行为： 如，read</p>
<p>​        ① 想中断pause，信号不能被屏蔽。</p>
<p>​        ② 信号的处理方式必须是捕捉 (默认、忽略都不可以)</p>
<p>​        ③ 中断后返回-1， 设置errno为EINTR(表“被信号中断”)</p>
<p>可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRURT不重启。 SA_RESTART重启。</p>
<p>扩展了解：</p>
<p>​    sa_flags还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号。</p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-09-10T08:14:44.812Z" itemprop="dateUpdated">2019-09-10 16:14:44</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2019/09/08/Linux系统编程-信号/" target="_blank" rel="external">www.huangshurong.top/2019/09/08/Linux系统编程-信号/</a>
        
    </div>
    <footer>
        <a href="www.huangshurong.top">
            <img src="/img/yong.png" alt="HSR">
            HSR
        </a>
    </footer>
</blockquote>

        
        <div class="post-footer">
            
            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=www.huangshurong.top/2019/09/08/Linux系统编程-信号/&title=《Linux系统编程-信号》 — 庸的博客&pic=www.huangshurong.top/img/yong.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=www.huangshurong.top/2019/09/08/Linux系统编程-信号/&title=《Linux系统编程-信号》 — 庸的博客&source=这是一个菜鸡的博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/09/10/Linux系统编程-线程/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Linux系统编程-线程</h4>
      </a>
    </div>
  

  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#信号的概念"><span class="post-toc-number">1.</span> <span class="post-toc-text">信号的概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#信号的机制"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">信号的机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#与信号相关的事件和状态"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">与信号相关的事件和状态</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#信号的编号"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">信号的编号</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#信号4要素"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">信号4要素</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Linux常规信号一览表"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">Linux常规信号一览表</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#信号的产生"><span class="post-toc-number">2.</span> <span class="post-toc-text">信号的产生</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#终端按键产生信号"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">终端按键产生信号</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#硬件异常产生信号"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">硬件异常产生信号</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#kill函数-命令产生信号"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">kill函数/命令产生信号</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#raise和abort函数"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">raise和abort函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#软件条件产生信号"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">软件条件产生信号</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#alarm函数"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">alarm函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#setitimer函数"><span class="post-toc-number">2.5.2.</span> <span class="post-toc-text">setitimer函数</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#信号集操作函数"><span class="post-toc-number">3.</span> <span class="post-toc-text">信号集操作函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#信号集设定"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">信号集设定</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sigprocmask函数"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">sigprocmask函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sigpending函数"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">sigpending函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#信号捕捉"><span class="post-toc-number">4.</span> <span class="post-toc-text">信号捕捉</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#signal函数"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">signal函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sigaction函数"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">sigaction函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#struct-sigaction结构体"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">struct sigaction结构体</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#信号捕捉特性"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">信号捕捉特性</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内核实现信号捕捉过程："><span class="post-toc-number">4.3.</span> <span class="post-toc-text">内核实现信号捕捉过程：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#竞态条件-时序竞态-："><span class="post-toc-number">5.</span> <span class="post-toc-text">竞态条件(时序竞态)：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pause函数"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">pause函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#时序竞态"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">时序竞态</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#前导例"><span class="post-toc-number">5.2.1.</span> <span class="post-toc-text">前导例</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#时序问题分析"><span class="post-toc-number">5.2.2.</span> <span class="post-toc-text">时序问题分析</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#解决时序问题"><span class="post-toc-number">5.2.3.</span> <span class="post-toc-text">解决时序问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#总结"><span class="post-toc-number">5.2.4.</span> <span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#全局变量异步I-O"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">全局变量异步I/O</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可-不可重入函数"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">可/不可重入函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意事项"><span class="post-toc-number">5.4.1.</span> <span class="post-toc-text">注意事项</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SIGCHLD信号"><span class="post-toc-number">6.</span> <span class="post-toc-text">SIGCHLD信号</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SIGCHLD的产生条件"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">SIGCHLD的产生条件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#借助SIGCHLD信号回收子进程"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">借助SIGCHLD信号回收子进程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#子进程结束status处理方式"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">子进程结束status处理方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SIGCHLD信号注意问题"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">SIGCHLD信号注意问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#信号传参"><span class="post-toc-number">7.</span> <span class="post-toc-text">信号传参</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#发送信号传参"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">发送信号传参</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#捕捉函数传参"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">捕捉函数传参</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#中断系统调用"><span class="post-toc-number">8.</span> <span class="post-toc-text">中断系统调用</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.huangshurong.top" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                HSR &copy; 2017 - 2019
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=www.huangshurong.top/2019/09/08/Linux系统编程-信号/&title=《Linux系统编程-信号》 — 庸的博客&pic=www.huangshurong.top/img/yong.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=www.huangshurong.top/2019/09/08/Linux系统编程-信号/&title=《Linux系统编程-信号》 — 庸的博客&source=这是一个菜鸡的博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKElEQVR42u3aS27DMAwFwNz/0i7QbWv7kXSKRhqtgjRxNCpAiJ/XK17H9/r5+uyvZ585e87xY73esTAwMD6WcVyufKNV9vXz871hYGDsw8i3kgTEs40mz6l+BgMDA6N6sUtCcH41xMDAwJgEviSk9hJjDAwMjEkSe51GXr9frZK9MRfHwMD4QMY7guNTr/+ov4GBgfGPGcdgTY4gCdmFnWBgYCzN6CWf+U9OvpWX3jAwMHZg9BLLagMgSW7zsB4dPQYGxkKMyQBEtek4aTbc8DAwMBZlJCF1cmWsnmgykPHLr2BgYCzNSC6F1WtcL5WdVPsxMDDWZvQainmYzo9jMniBgYGxNuOpn3zqmpi8c1Nuw8DAWJTx1L1yEoirjYGbBBsDA2MhRrXElofj6ljY6D+AgYGxDaM3PFEdoajyoospBgbGNowkHS3Pl8Wp7OhbGBgYGzAmJbC8HJaH6XIZDgMDY2nGvGTWyyWr5f7CtAgGBsaijGTT1Q5DL4hX93N6QcTAwFiUUShvDYpxvatedKwYGBjbMKqjFb3Sfw98c4gYGBhLM3pJZnLta17yig0GDAyMtRlHcSUDYQlpEogxMDB2Y+QrT1bn4bVXhsPAwFibMQ+y1bGMhJGn0BgYGPswqoGvOh6RH0dzXAMDAwMjuNi9I1gnDU4MDAyMyajWpDFZzrwxMDA2YFTL9/OBid47GBgYezKqjYFqSyB/TnW8bNTfwMDA+AzGFwAdN/Wi23BrAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
