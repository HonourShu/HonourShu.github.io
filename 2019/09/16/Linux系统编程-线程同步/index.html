<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>Linux系统编程-线程同步 | 庸的博客 | 爱代码,爱生活~</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content>
    <link rel="shortcut icon" href="/img/yong.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	false,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/yong.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">HSR</h5>
          <a href="mailto:461467948@qq.com" title="461467948@qq.com" class="mail">
            
              <span>4</span>
            
              <span>6</span>
            
              <span>1</span>
            
              <span>4</span>
            
              <span>6</span>
            
              <span>7</span>
            
              <span>9</span>
            
              <span>4</span>
            
              <span>8</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/HonourShu" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>Linux系统编程-线程同步</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">Linux系统编程-线程同步</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-09-16T08:23:20.000Z" itemprop="datePublished" class="page-time">
  2019-09-16
</time>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-Linux系统编程-线程同步"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">Linux系统编程-线程同步</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-09-16 16:23:20" datetime="2019-09-16T08:23:20.000Z"  itemprop="datePublished">2019-09-16</time>

            


            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h2 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a><strong>同步概念</strong></h2><p>​    所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等</p>
<p>​    而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a><strong>线程同步</strong></h3><p>​    同步即协同步调，按预定的先后次序运行。</p>
<p>​    线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p>
<p>举例1：    银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</p>
<p>举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续    从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</p>
<p>​    产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</p>
<p>​    “同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p>
<p>​    因此，<strong>所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</strong></p>
<h3 id="数据混乱原因："><a href="#数据混乱原因：" class="headerlink" title="数据混乱原因："></a><strong>数据混乱原因：</strong></h3><ol>
<li><p>资源共享（独享资源则不会）    </p>
</li>
<li><p>调度随机（意味着数据访问会出现竞争）    </p>
</li>
<li><p>线程间缺乏必要的同步机制。</p>
</li>
</ol>
<p>​    以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p>
<p>​    所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p>
<h2 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a><strong>互斥量mutex</strong></h2><p>Linux中提供一把互斥锁mutex（也称之为互斥量）。</p>
<p>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p>
<p>​    资源还是共享的，线程间也还是竞争的，                            </p>
<p>​    但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p>
<a rel=Linux系统编程-线程同步 href="/2019/09/16/Linux系统编程-线程同步/sync1.png" title="" data-fancybox="images"><img src="/2019/09/16/Linux系统编程-线程同步/sync1.png"></a> 

<p>​    但，应注意：同一时刻，只能有一个线程持有该锁。</p>
<p>​    当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</p>
<p>​    所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。</p>
<p>​    因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</p>
<h3 id="主要应用函数："><a href="#主要应用函数：" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h3><p>​    pthread_mutex_init函数</p>
<p>​    pthread_mutex_destroy函数</p>
<p>​    pthread_mutex_lock函数</p>
<p>​    pthread_mutex_trylock函数</p>
<p>​    pthread_mutex_unlock函数</p>
<p>以上5个函数的返回值都是：成功返回0， 失败返回错误号。    </p>
<p>pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</p>
<p>pthread_mutex_t mutex; 变量mutex只有两种取值1、0。</p>
<h4 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a><strong>pthread_mutex_init函数</strong></h4><p>初始化一个互斥锁(互斥量) —&gt; 初值可看作1</p>
<p>​    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</p>
<p>​    参1：传出参数，调用时应传 &amp;mutex    </p>
<p>​    restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</p>
<p>​    参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</p>
<ol>
<li><p>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</p>
</li>
<li><p>动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</p>
</li>
</ol>
<h4 id="pthread-mutex-destroy函数"><a href="#pthread-mutex-destroy函数" class="headerlink" title="pthread_mutex_destroy函数"></a><strong>pthread_mutex_destroy函数</strong></h4><p>销毁一个互斥锁</p>
<p>​    int pthread_mutex_destroy(pthread_mutex_t *mutex);</p>
<h4 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a><strong>pthread_mutex_lock函数</strong></h4><p>加锁。可理解为将mutex–（或-1）</p>
<p>​    int pthread_mutex_lock(pthread_mutex_t *mutex);</p>
<h4 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a><strong>pthread_mutex_unlock函数</strong></h4><p>解锁。可理解为将mutex ++（或+1）</p>
<p>​    int pthread_mutex_unlock(pthread_mutex_t *mutex);</p>
<h4 id="pthread-mutex-trylock函数"><a href="#pthread-mutex-trylock函数" class="headerlink" title="pthread_mutex_trylock函数"></a><strong>pthread_mutex_trylock函数</strong></h4><p>尝试加锁</p>
<p>​    int pthread_mutex_trylock(pthread_mutex_t *mutex);</p>
<h3 id="加锁与解锁"><a href="#加锁与解锁" class="headerlink" title="加锁与解锁"></a><strong>加锁与解锁</strong></h3><h4 id="lock与unlock："><a href="#lock与unlock：" class="headerlink" title="lock与unlock："></a><strong>lock与unlock：</strong></h4><p>​    lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</p>
<p>​    unlock主动解锁函数，<strong>同时将阻塞在该锁上的所有线程**</strong>全部唤醒**，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</p>
<p>​    例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。</p>
<p>​    可假想mutex锁 init成功初值为1。    lock 功能是将mutex–。    unlock将mutex++</p>
<h4 id="lock与trylock："><a href="#lock与trylock：" class="headerlink" title="lock与trylock："></a><strong>lock与trylock：</strong></h4><p>​    lock加锁失败会阻塞，等待锁释放。</p>
<p>​    trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</p>
<h3 id="加锁步骤测试："><a href="#加锁步骤测试：" class="headerlink" title="加锁步骤测试："></a><strong>加锁步骤测试：</strong></h3><p>​    看如下程序：该程序是非常典型的，由于共享、竞争而没有加任何同步机制，导致产生于时间有关的错误，造成数据混乱：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">3</span>);	<span class="comment">/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/</span></span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">​    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">​    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【练习】：修改该程序，使用mutex互斥锁进行同步。                                        </p>
<ol>
<li><p>定义全局互斥量，初始化init(&amp;m, NULL)互斥量，添加对应的destry</p>
</li>
<li><p>两个线程while中，两次printf前后，分别加lock和unlock</p>
</li>
<li><p>将unlock挪至第二个sleep后，发现交替现象很难出现。</p>
</li>
</ol>
<p>线程在操作完共享资源后本应该立即解锁，但修改后，线程抱着锁睡眠。睡醒解锁后又立即加锁，这两个库函数本身不会阻塞。</p>
<p>所以在这两行代码之间失去cpu的概率很小。因此，另外一个线程很难得到加锁的机会。</p>
<ol start="4">
<li><p>main 中加flag = 5 将flg在while中–  这时，主线程输出5次后试图销毁锁，但子线程未将锁释放，无法完成。</p>
</li>
<li><p>main 中加pthread_cancel()将子线程取消。                                        </p>
</li>
</ol>
<p><strong>结论：</strong></p>
<p>​    <strong>在访问共享资源前加锁，访问结束后**</strong>立即解锁<strong>**。锁的“粒度”应越小越好。</strong></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h2><p>​    1. 线程试图对同一个互斥量A加锁两次。</p>
<p>​    2. 线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁                                        </p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h2><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。</p>
<h3 id="读写锁状态："><a href="#读写锁状态：" class="headerlink" title="读写锁状态："></a><strong>读写锁状态：</strong></h3><p>一把读写锁具备三种状态：</p>
<p>​    1. 读模式下加锁状态 (读锁)</p>
<p>​    2. 写模式下加锁状态 (写锁)</p>
<p>​    3. 不加锁状态</p>
<h3 id="读写锁特性："><a href="#读写锁特性：" class="headerlink" title="读写锁特性："></a><strong>读写锁特性：</strong></h3><ol>
<li><p>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</p>
</li>
<li><p>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</p>
</li>
<li><p>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁, 读锁、写锁并行阻塞，<strong>写锁优先级高</strong></p>
</li>
</ol>
<p>​    读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享。</strong></p>
<p>​    读写锁非常适合于对数据结构读的次数远大于写的情况。</p>
<h3 id="主要应用函数：-1"><a href="#主要应用函数：-1" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h3><p>​    pthread_rwlock_init函数</p>
<p>​    pthread_rwlock_destroy函数</p>
<p>​    pthread_rwlock_rdlock函数  </p>
<p>​    pthread_rwlock_wrlock函数</p>
<p>​    pthread_rwlock_tryrdlock函数</p>
<p>​    pthread_rwlock_trywrlock函数</p>
<p>​    pthread_rwlock_unlock函数</p>
<p>以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。    </p>
<p>​    pthread_rwlock_t类型    用于定义一个读写锁变量。</p>
<p>​    pthread_rwlock_t rwlock;</p>
<h4 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a><strong>pthread_rwlock_init函数</strong></h4><p>初始化一把读写锁</p>
<p>​    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</p>
<p>​    参2：attr表读写锁属性，通常使用默认属性，传NULL即可。</p>
<h4 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a><strong>pthread_rwlock_destroy函数</strong></h4><p>销毁一把读写锁</p>
<p>​    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a><strong>pthread_rwlock_rdlock函数</strong></h4><p>以读方式请求读写锁。（常简称为：请求读锁）</p>
<p>​    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a><strong>pthread_rwlock_wrlock函数</strong></h4><p>以写方式请求读写锁。（常简称为：请求写锁）</p>
<p>​    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a><strong>pthread_rwlock_unlock函数</strong></h4><p>解锁</p>
<p>​    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-tryrdlock函数"><a href="#pthread-rwlock-tryrdlock函数" class="headerlink" title="pthread_rwlock_tryrdlock函数"></a><strong>pthread_rwlock_tryrdlock函数</strong></h4><p>非阻塞以读方式请求读写锁（非阻塞请求读锁）</p>
<p>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-trywrlock函数"><a href="#pthread-rwlock-trywrlock函数" class="headerlink" title="pthread_rwlock_trywrlock函数"></a><strong>pthread_rwlock_trywrlock函数</strong></h4><p>非阻塞以写方式请求读写锁（非阻塞请求写锁）</p>
<p>​    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</p>
<h3 id="读写锁示例"><a href="#读写锁示例" class="headerlink" title="读写锁示例"></a><strong>读写锁示例</strong></h3><p>看如下示例，同时有多个线程对同一全局数据读、写操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">th_write</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> t, i = (<span class="keyword">int</span>)arg;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​        t = counter;</span><br><span class="line"></span><br><span class="line">​        usleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"=======write %d: %lu: counter=%d ++counter=%d\n"</span>, i, pthread_self(), t, ++counter);</span><br><span class="line"></span><br><span class="line">​        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​        usleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">th_read</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"----------------------------read %d: %lu: %d\n"</span>, i, pthread_self(), counter);</span><br><span class="line"></span><br><span class="line">​        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​        usleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">​    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"></span><br><span class="line">​        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, th_write, (<span class="keyword">void</span> *)i);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line"></span><br><span class="line">​        pthread_create(&amp;tid[i+<span class="number">3</span>], <span class="literal">NULL</span>, th_read, (<span class="keyword">void</span> *)i);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line"></span><br><span class="line">​        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                </p>
<h2 id="条件变量："><a href="#条件变量：" class="headerlink" title="条件变量："></a><strong>条件变量：</strong></h2><p>​    条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</p>
<h3 id="主要应用函数：-2"><a href="#主要应用函数：-2" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h3><p>​    pthread_cond_init函数</p>
<p>​    pthread_cond_destroy函数</p>
<p>​    pthread_cond_wait函数</p>
<p>​    pthread_cond_timedwait函数</p>
<p>​    pthread_cond_signal函数</p>
<p>​    pthread_cond_broadcast函数</p>
<p>以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。</p>
<p>​    pthread_cond_t类型    用于定义条件变量</p>
<p>​    pthread_cond_t cond;</p>
<h4 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a><strong>pthread_cond_init函数</strong></h4><p>初始化一个条件变量</p>
<p>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);        </p>
<p>参2：attr表条件变量属性，通常为默认值，传NULL即可</p>
<p>也可以使用静态初始化的方法，初始化条件变量：</p>
<p>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p>
<h4 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a><strong>pthread_cond_destroy函数</strong></h4><p>销毁一个条件变量</p>
<p>int pthread_cond_destroy(pthread_cond_t *cond);</p>
<h4 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a><strong>pthread_cond_wait函数</strong></h4><p>阻塞等待一个条件变量</p>
<p>​    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</p>
<p>函数作用：</p>
<ol>
<li><p>阻塞等待条件变量cond（参1）满足    </p>
</li>
<li><p>释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);</p>
<p><strong>1.2.两步为一个原子操作。</strong></p>
</li>
<li><p>当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</p>
</li>
</ol>
<h4 id="pthread-cond-timedwait函数"><a href="#pthread-cond-timedwait函数" class="headerlink" title="pthread_cond_timedwait函数"></a><strong>pthread_cond_timedwait函数</strong></h4><p>限时等待一个条件变量</p>
<p>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</p>
<p>​    参3：    参看man sem_timedwait函数，查看struct timespec结构体。</p>
<p>​        struct timespec {</p>
<p>​            time_t tv_sec;        /* seconds */ 秒</p>
<p>​            long   tv_nsec;    /* nanosecondes*/ 纳秒</p>
<p>​        }                                </p>
<p>形参abstime：绝对时间。                                        </p>
<p>如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。    </p>
<p>​            struct timespec t = {1, 0};</p>
<p>​            pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 1970年1月1日 00:00:01秒(早已经过去) </p>
<p>​        正确用法：</p>
<p>​            time_t cur = time(NULL); 获取当前时间。</p>
<p>struct timespec t;    定义timespec 结构体变量t</p>
<p>​            t.tv_sec = cur+1; 定时1秒</p>
<p>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参                参APUE.11.6线程同步条件变量小节</p>
<p>​        在讲解setitimer函数时我们还提到另外一种时间类型：</p>
<p>​        struct timeval {</p>
<p>​             time_t      tv_sec;  /* seconds */ 秒</p>
<p>​             suseconds_t tv_usec;     /* microseconds */ 微秒</p>
<p>​        };</p>
<h4 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a><strong>pthread_cond_signal函数</strong></h4><p>唤醒至少一个阻塞在条件变量上的线程</p>
<p>int pthread_cond_signal(pthread_cond_t *cond);</p>
<h4 id="pthread-cond-broadcast函数"><a href="#pthread-cond-broadcast函数" class="headerlink" title="pthread_cond_broadcast函数"></a><strong>pthread_cond_broadcast函数</strong></h4><p>唤醒全部阻塞在条件变量上的线程</p>
<p>​    int pthread_cond_broadcast(pthread_cond_t *cond);</p>
<h3 id="生产者消费者条件变量模型"><a href="#生产者消费者条件变量模型" class="headerlink" title="生产者消费者条件变量模型"></a><strong>生产者消费者条件变量模型</strong></h3><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p>
<p>看如下示例，使用条件变量模拟生产者、消费者问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">​        pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">while</span> (head == <span class="literal">NULL</span>) &#123;           <span class="comment">//头指针为空,说明没有节点    可以为if吗</span></span><br><span class="line"></span><br><span class="line">​            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        mp = head;      </span><br><span class="line"></span><br><span class="line">​        head = mp-&gt;next;    			<span class="comment">//模拟消费掉一个产品</span></span><br><span class="line"></span><br><span class="line">​        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"-Consume ---%d\n"</span>, mp-&gt;num);</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">free</span>(mp);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        mp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct msg));</span><br><span class="line"></span><br><span class="line">​        mp-&gt;num = rand() % <span class="number">1000</span> + <span class="number">1</span>;        <span class="comment">//模拟生产一个产品</span></span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"-Produce ---%d\n"</span>, mp-&gt;num);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​        pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">​        mp-&gt;next = head;</span><br><span class="line"></span><br><span class="line">​        head = mp;</span><br><span class="line"></span><br><span class="line">​        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​        pthread_cond_signal(&amp;has_product);  <span class="comment">//将等待在该条件变量上的一个线程唤醒</span></span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_t</span> pid, cid;</span><br><span class="line"></span><br><span class="line">​    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                        </p>
<h3 id="条件变量的优点："><a href="#条件变量的优点：" class="headerlink" title="条件变量的优点："></a><strong>条件变量的优点：</strong></h3><p>​    相较于mutex而言，条件变量可以减少竞争。</p>
<p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong>信号量</strong></h2><p>进化版的互斥锁（1 –&gt; N）</p>
<p>​    由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</p>
<p>​    信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p>
<h3 id="主要应用函数：-3"><a href="#主要应用函数：-3" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h3><p>​    sem_init函数</p>
<p>​    sem_destroy函数</p>
<p>​    sem_wait函数</p>
<p>​    sem_trywait函数    </p>
<p>​    sem_timedwait函数    </p>
<p>​    sem_post函数</p>
<p>以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)</p>
<p>​    sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。 </p>
<p>sem_t sem; 规定信号量sem不能 &lt; 0。头文件 &lt;semaphore.h&gt;</p>
<h4 id="信号量基本操作："><a href="#信号量基本操作：" class="headerlink" title="信号量基本操作："></a><strong>信号量基本操作：</strong></h4><p>sem_wait:    1. 信号量大于0，则信号量–        （类比pthread_mutex_lock）</p>
<p>​      |            2. 信号量等于0，造成线程阻塞</p>
<p>​    对应</p>
<p>​      |</p>
<p>​    sem_post：    将信号量++，同时唤醒阻塞在信号量上的线程    （类比pthread_mutex_unlock）</p>
<p>但，由于sem_t的实现对用户隐藏，所以所谓的++、–操作只能通过函数来实现，而不能直接++、–符号。</p>
<p><strong>信号量的初值，决定了占用信号量的线程的个数。</strong></p>
<h4 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a><strong>sem_init函数</strong></h4><p>初始化一个信号量</p>
<p>​    int sem_init(sem_t *sem, int pshared, unsigned int value);</p>
<p>​    参1：sem信号量    </p>
<p>参2：pshared取0用于线程间；取非0（一般为1）用于进程间    </p>
<p>参3：value指定信号量初值</p>
<h4 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a><strong>sem_destroy函数</strong></h4><p>销毁一个信号量</p>
<p>​    int sem_destroy(sem_t *sem);</p>
<h4 id="sem-wait函数"><a href="#sem-wait函数" class="headerlink" title="sem_wait函数"></a><strong>sem_wait函数</strong></h4><p>给信号量加锁 – </p>
<p>​    int sem_wait(sem_t *sem);</p>
<h4 id="sem-post函数"><a href="#sem-post函数" class="headerlink" title="sem_post函数"></a><strong>sem_post函数</strong></h4><p>给信号量解锁 ++</p>
<p>​     int sem_post(sem_t *sem);    </p>
<h4 id="sem-trywait函数"><a href="#sem-trywait函数" class="headerlink" title="sem_trywait函数"></a><strong>sem_trywait函数</strong></h4><p>尝试对信号量加锁 –    (与sem_wait的区别类比lock和trylock)</p>
<p>​     int sem_trywait(sem_t *sem);    </p>
<h4 id="sem-timedwait函数"><a href="#sem-timedwait函数" class="headerlink" title="sem_timedwait函数"></a><strong>sem_timedwait函数</strong></h4><p>限时尝试对信号量加锁 –</p>
<p>​    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</p>
<p>​    参2：abs_timeout采用的是绝对时间。            </p>
<p>​    定时1秒：</p>
<p>​        time_t cur = time(NULL); 获取当前时间。</p>
<p>struct timespec t;    定义timespec 结构体变量t</p>
<p>​        t.tv_sec = cur+1; 定时1秒</p>
<p>​        t.tv_nsec = t.tv_sec +100; </p>
<p>sem_timedwait(&amp;sem, &amp;t); 传参</p>
<h3 id="生产者消费者信号量模型"><a href="#生产者消费者信号量模型" class="headerlink" title="生产者消费者信号量模型"></a><strong>生产者消费者信号量模型</strong></h3><p>【练习】：使用信号量完成线程间同步，模拟生产者，消费者问题。            </p>
<p>分析：</p>
<p>​    规定：    如果□中有数据，生产者不能生产，只能阻塞。</p>
<p>​            如果□中没有数据，消费者不能消费，只能等待数据。</p>
<p>​    定义两个信号量：S满 = 0， S空 = 1 （S满代表满格的信号量，S空表示空格的信号量，程序起始，格子一定为空）</p>
<p>​    所以有：    T生产者主函数 {                T消费者主函数 {</p>
<p>​                     sem_wait(S空);                 sem_wait(S满);</p>
<p>​                    生产….                          消费….</p>
<p>​                     sem_post(S满);                 sem_post(S空);</p>
<p>​                }                            }</p>
<p>​    假设：    线程到达的顺序是:T生、T生、T消。</p>
<p>​    那么：    T生1 到达，将S空-1，生产，将S满+1</p>
<p>​            T生2 到达，S空已经为0， 阻塞</p>
<p>​            T消  到达，将S满-1，消费，将S空+1</p>
<p>​    三个线程到达的顺序是：T生1、T生2、T消。而执行的顺序是T生1、T消、T生2</p>
<p>​    这里，S空 表示空格子的总数，代表可占用信号量的线程总数–&gt;1。其实这样的话，信号量就等同于互斥锁。</p>
<p>​    但，如果S空=2、3、4……就不一样了，该信号量同时可以由多个线程占用，不再是互斥的形式。因此我们说信号量是互斥锁的加强版。</p>
<p>【推演练习】：    理解上述模型，推演，如果是两个消费者，一个生产者，是怎么样的情况。        </p>
<p>【作业】：结合生产者消费者信号量模型，揣摩sem_timedwait函数作用。编程实现，一个线程读用户输入， 另一个线程打印“hello world”。如果用户无输入，则每隔5秒向屏幕打印一个“hello world”；如果用户有输入，立刻打印“hello world”到屏幕。                                                                            </p>
<h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a><strong>进程间同步</strong></h2><h3 id="互斥量mutex-1"><a href="#互斥量mutex-1" class="headerlink" title="互斥量mutex"></a><strong>互斥量mutex</strong></h3><p>进程间也可以使用互斥锁，来达到同步的目的。但应在pthread_mutex_init初始化之前，修改其属性为进程间共享。mutex的属性修改函数主要有以下几个。</p>
<h4 id="主要应用函数：-4"><a href="#主要应用函数：-4" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h4><p>​    pthread_mutexattr_t mattr 类型：        用于定义mutex锁的【属性】</p>
<p>​    <strong>pthread_mutexattr_init函数</strong>：            初始化一个mutex属性对象</p>
<p>​        int pthread_mutexattr_init(pthread_mutexattr_t *attr);</p>
<p>​    <strong>pthread_mutexattr_destroy函数</strong>：        销毁mutex属性对象 (而非销毁锁)</p>
<p>​        int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</p>
<p>​    <strong>pthread_mutexattr_setpshared函数</strong>：    修改mutex属性。</p>
<p>​        int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</p>
<p>​        参2：pshared取值：</p>
<p>​            线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有)</p>
<p>​            进程锁：PTHREAD_PROCESS_SHARED</p>
<h4 id="进程间mutex示例"><a href="#进程间mutex示例" class="headerlink" title="进程间mutex示例"></a><strong>进程间mutex示例</strong></h4><p>进程间使用mutex来实现同步：</p>
<p>​                    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mt</span> &#123;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> fd, i;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">mt</span> *<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    fd = open(<span class="string">"mt_test"</span>, O_CREAT | O_RDWR, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">​    ftruncate(fd, <span class="keyword">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line">​    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(*mm), PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">​    close(fd);</span><br><span class="line"></span><br><span class="line">​    unlink(<span class="string">"mt_test"</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);</span></span><br><span class="line"></span><br><span class="line">​    <span class="built_in">memset</span>(mm, <span class="number">0</span>, <span class="keyword">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_mutexattr_init(&amp;mm-&gt;mutexattr);                                  <span class="comment">//初始化mutex属性对象</span></span><br><span class="line"></span><br><span class="line">​    pthread_mutexattr_setpshared(&amp;mm-&gt;mutexattr, PTHREAD_PROCESS_SHARED);    <span class="comment">//修改属性为进程间共享</span></span><br><span class="line"></span><br><span class="line">​    pthread_mutex_init(&amp;mm-&gt;mutex, &amp;mm-&gt;mutexattr);                          <span class="comment">//初始化一把mutex琐</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pid = fork();</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">​            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line"></span><br><span class="line">​            (mm-&gt;num)++;</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">printf</span>(<span class="string">"-child----num++   %d\n"</span>, mm-&gt;num);</span><br><span class="line"></span><br><span class="line">​            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line"></span><br><span class="line">​            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">​            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line"></span><br><span class="line">​            mm-&gt;num += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">printf</span>(<span class="string">"-parent---num+=2  %d\n"</span>, mm-&gt;num);</span><br><span class="line"></span><br><span class="line">​            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_mutexattr_destroy(&amp;mm-&gt;mutexattr);          <span class="comment">//销毁mutex属性对象</span></span><br><span class="line"></span><br><span class="line">​    pthread_mutex_destroy(&amp;mm-&gt;mutex);                <span class="comment">//销毁mutex</span></span><br><span class="line"></span><br><span class="line">​    munmap(mm,<span class="keyword">sizeof</span>(*mm));                          <span class="comment">//释放映射区</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a><strong>文件锁</strong></h3><p>​    借助 fcntl函数来实现锁机制。    操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作。</p>
<p>fcntl函数：    获取、设置文件访问控制属性。</p>
<p>​    int fcntl(int fd, int cmd, … /* arg */ );</p>
<p>​    参2：</p>
<p>​        F_SETLK (struct flock *)    设置文件锁（trylock）</p>
<p>​        F_SETLKW (struct flock *) 设置文件锁（lock）W –&gt; wait</p>
<p>​        F_GETLK (struct flock *)    获取文件锁</p>
<p>​    参3：</p>
<p>​        struct flock {</p>
<p>​              …</p>
<p>​              short l_type;        锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</p>
<p>​              short l_whence;      偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </p>
<p>​              off_t l_start;           起始偏移：1000</p>
<p>​              off_t l_len;             长度：0表示整个文件加锁</p>
<p>​              pid_t l_pid;         持有该锁的进程ID：(F_GETLK only)</p>
<p>​              …</p>
<p>​         };</p>
<h4 id="进程间文件锁示例"><a href="#进程间文件锁示例" class="headerlink" title="进程间文件锁示例"></a><strong>进程间文件锁示例</strong></h4><p>多个进程对加锁文件进行访问： </p>
<p>​    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    perror(str); <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">f_lock</span>;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"./a.out filename\n"</span>); <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">​        sys_err(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="comment">//f_lock.l_type = F_WRLCK;        /*选用写琐*/</span></span><br><span class="line"></span><br><span class="line">​    f_lock.l_type = F_RDLCK;          <span class="comment">/*选用读琐*/</span> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    f_lock.l_whence = SEEK_SET;</span><br><span class="line"></span><br><span class="line">​    f_lock.l_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    f_lock.l_len = <span class="number">0</span>;               <span class="comment">/* 0表示整个文件加锁 */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"get flock\n"</span>);</span><br><span class="line"></span><br><span class="line">​    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    f_lock.l_type = F_UNLCK;</span><br><span class="line"></span><br><span class="line">​    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"un flock\n"</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    close(fd);	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                </p>
<p>依然遵循“读共享、写独占”特性。但！如若进程不加锁直接操作文件，依然可访问成功，但数据势必会出现混乱。</p>
<p>【思考】：多线程中，可以使用文件锁吗？</p>
<p>多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。</p>
<h2 id="哲学家用餐模型分析"><a href="#哲学家用餐模型分析" class="headerlink" title="哲学家用餐模型分析"></a><strong>哲学家用餐模型分析</strong></h2><h3 id="多线程版："><a href="#多线程版：" class="headerlink" title="多线程版："></a><strong>多线程版：</strong></h3><p>​    选用互斥锁mutex，如创建5个， pthread_mutex_t m[5];</p>
<p>​    模型抽象：    </p>
<p>​        5个哲学家 –&gt; 5个线程；    5支筷子 –&gt; 5把互斥锁        int left(左手)， right(右手)</p>
<p>​        5个哲学家使用相同的逻辑，可通用一个线程主函数，void *tfn(void *arg)，使用参数来表示线程编号：int i = (int)arg;</p>
<p>​        哲学家线程根据编号知道自己是第几个哲学家，而后选定锁，锁住，吃饭。否则哲学家thinking。</p>
<p>​                                         A   B   C   D   E</p>
<p>​        5支筷子，在逻辑上形成环： 0   1   2   3   4   分别对应5个哲学家：</p>
<a rel=Linux系统编程-线程同步 href="/2019/09/16/Linux系统编程-线程同步/sync2.png" title="" data-fancybox="images"><img src="/2019/09/16/Linux系统编程-线程同步/sync2.png"></a> 

<p>​    所以有：</p>
<p>​        if(i == 4)    </p>
<p>​            left = i, right = 0;</p>
<p>​        else </p>
<p>​            left = i, right = i+1;</p>
<p>​    振荡：如果每个人都攥着自己左手的锁，尝试去拿右手锁，拿不到则将锁释放。过会儿五个人又同时再攥着左手锁尝试拿右手锁，依然拿不到。如此往复形成另外一种极端死锁的现象——振荡。</p>
<p>​    避免振荡现象：只需5个人中，任意一个人，拿锁的方向与其他人相逆即可(如：E，原来：左：4，右：0    现在：左：0， 右：4)。</p>
<p>​    所以以上if else语句应改为：</p>
<p>​        if(i == 4)    </p>
<p>​            left = 0, right = i;</p>
<p>​        else </p>
<p>​            left = i, right = i+1;</p>
<p>​    而后， 首先应让哲学家尝试加左手锁：    </p>
<p>while { </p>
<p>​            pthread_mutex_lock(&amp;m[left]);     如果加锁成功，函数返回再加右手锁，</p>
<p>​                                        如果失败，应立即释放左手锁，等待。</p>
<p>​            若，左右手都加锁成功 –&gt; 吃 –&gt; 吃完 –&gt; 释放锁（应先释放右手、再释放左手，是加锁顺序的逆序）</p>
<p>​        }</p>
<p>​    主线程(main)中，初始化5把锁，销毁5把锁，创建5个线程（并将i传递给线程主函数），回收5个线程。</p>
<p><strong>避免死锁的方法：</strong></p>
<p>​    <strong>1. 当得不到所有所需资源时，放弃已经获得的资源，等待。</strong></p>
<p>​    <strong>2. 保证资源的获取顺序，要求每个线程获取资源的顺序一致。</strong>如：A获取顺序1、2、3；B顺序应也是1、2、3。若B为3、2、1则易出现死锁现象。                                            </p>
<h3 id="多进程版"><a href="#多进程版" class="headerlink" title="多进程版"></a><strong>多进程版</strong></h3><p>相较于多线程需注意问题：</p>
<p>​    需注意如何共享信号量 (注意：坚决不能使用全局变量 sem_t s[5])</p>
<p>实现：</p>
<p>​    main函数中：    </p>
<p>循环 sem_init(&amp;s[i], 0, 1); 将信号量初值设为1，信号量变为互斥锁。</p>
<p>​        循环 sem_destroy(&amp;s[i]);</p>
<p>​        循环 创建 5 个子进程。 if(i &lt; 5) 中完成子进程的代码逻辑。</p>
<p>​        循环 回收 5 个子进程。</p>
<p>​    子进程中：</p>
<p>if(i == 4)  </p>
<p>left = 0, right == 4;</p>
<p>​        else    </p>
<p>left = i, right = i+1;    </p>
<p>​        while (1) {</p>
<p>​            使用 sem_wait(&amp;s[left]) 锁左手，尝试锁右手，若成功 –&gt; 吃； 若不成功 –&gt; 将左手锁释放。</p>
<p>​            吃完后， 先释放右手锁，再释放左手锁。</p>
<p>​        }</p>
<p>【重点注意】：</p>
<p>直接将sem_t s[5]放在全局位置，试图用于子进程间共享是错误的！应将其定义放置与mmap共享映射区中。main中：</p>
<p>sem_t *s = mmap(NULL, sizeof(sem_t) * 5, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON， -1， 0);</p>
<p>​    使用方式：将s当成数组首地址看待，与使用数组s[5]没有差异。</p>
<p>​                                                                            </p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-10-16T10:47:53.767Z" itemprop="dateUpdated">2019-10-16 18:47:53</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2019/09/16/Linux系统编程-线程同步/" target="_blank" rel="external">www.huangshurong.top/2019/09/16/Linux系统编程-线程同步/</a>
        
    </div>
    <footer>
        <a href="www.huangshurong.top">
            <img src="/img/yong.png" alt="HSR">
            HSR
        </a>
    </footer>
</blockquote>

        
        <div class="post-footer">
            
            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=www.huangshurong.top/2019/09/16/Linux系统编程-线程同步/&title=《Linux系统编程-线程同步》 — 庸的博客&pic=www.huangshurong.top/img/yong.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=www.huangshurong.top/2019/09/16/Linux系统编程-线程同步/&title=《Linux系统编程-线程同步》 — 庸的博客&source=这是一个菜鸡的博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/09/16/Linux网络编程-网络基础/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Linux网络编程-网络基础</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/09/15/Linux系统编程-守护进程/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Linux系统编程-守护进程</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#同步概念"><span class="post-toc-number">1.</span> <span class="post-toc-text">同步概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程同步"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">线程同步</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据混乱原因："><span class="post-toc-number">1.2.</span> <span class="post-toc-text">数据混乱原因：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#互斥量mutex"><span class="post-toc-number">2.</span> <span class="post-toc-text">互斥量mutex</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主要应用函数："><span class="post-toc-number">2.1.</span> <span class="post-toc-text">主要应用函数：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-mutex-init函数"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">pthread_mutex_init函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-mutex-destroy函数"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">pthread_mutex_destroy函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-mutex-lock函数"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">pthread_mutex_lock函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-mutex-unlock函数"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">pthread_mutex_unlock函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-mutex-trylock函数"><span class="post-toc-number">2.1.5.</span> <span class="post-toc-text">pthread_mutex_trylock函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#加锁与解锁"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">加锁与解锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#lock与unlock："><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">lock与unlock：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#lock与trylock："><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">lock与trylock：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#加锁步骤测试："><span class="post-toc-number">2.3.</span> <span class="post-toc-text">加锁步骤测试：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#死锁"><span class="post-toc-number">3.</span> <span class="post-toc-text">死锁</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#读写锁"><span class="post-toc-number">4.</span> <span class="post-toc-text">读写锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读写锁状态："><span class="post-toc-number">4.1.</span> <span class="post-toc-text">读写锁状态：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读写锁特性："><span class="post-toc-number">4.2.</span> <span class="post-toc-text">读写锁特性：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主要应用函数：-1"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">主要应用函数：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-rwlock-init函数"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">pthread_rwlock_init函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-rwlock-destroy函数"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">pthread_rwlock_destroy函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-rwlock-rdlock函数"><span class="post-toc-number">4.3.3.</span> <span class="post-toc-text">pthread_rwlock_rdlock函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-rwlock-wrlock函数"><span class="post-toc-number">4.3.4.</span> <span class="post-toc-text">pthread_rwlock_wrlock函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-rwlock-unlock函数"><span class="post-toc-number">4.3.5.</span> <span class="post-toc-text">pthread_rwlock_unlock函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-rwlock-tryrdlock函数"><span class="post-toc-number">4.3.6.</span> <span class="post-toc-text">pthread_rwlock_tryrdlock函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-rwlock-trywrlock函数"><span class="post-toc-number">4.3.7.</span> <span class="post-toc-text">pthread_rwlock_trywrlock函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读写锁示例"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">读写锁示例</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#条件变量："><span class="post-toc-number">5.</span> <span class="post-toc-text">条件变量：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主要应用函数：-2"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">主要应用函数：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-cond-init函数"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">pthread_cond_init函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-cond-destroy函数"><span class="post-toc-number">5.1.2.</span> <span class="post-toc-text">pthread_cond_destroy函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-cond-wait函数"><span class="post-toc-number">5.1.3.</span> <span class="post-toc-text">pthread_cond_wait函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-cond-timedwait函数"><span class="post-toc-number">5.1.4.</span> <span class="post-toc-text">pthread_cond_timedwait函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-cond-signal函数"><span class="post-toc-number">5.1.5.</span> <span class="post-toc-text">pthread_cond_signal函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pthread-cond-broadcast函数"><span class="post-toc-number">5.1.6.</span> <span class="post-toc-text">pthread_cond_broadcast函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#生产者消费者条件变量模型"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">生产者消费者条件变量模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#条件变量的优点："><span class="post-toc-number">5.3.</span> <span class="post-toc-text">条件变量的优点：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#信号量"><span class="post-toc-number">6.</span> <span class="post-toc-text">信号量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主要应用函数：-3"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">主要应用函数：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#信号量基本操作："><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">信号量基本操作：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sem-init函数"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">sem_init函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sem-destroy函数"><span class="post-toc-number">6.1.3.</span> <span class="post-toc-text">sem_destroy函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sem-wait函数"><span class="post-toc-number">6.1.4.</span> <span class="post-toc-text">sem_wait函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sem-post函数"><span class="post-toc-number">6.1.5.</span> <span class="post-toc-text">sem_post函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sem-trywait函数"><span class="post-toc-number">6.1.6.</span> <span class="post-toc-text">sem_trywait函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sem-timedwait函数"><span class="post-toc-number">6.1.7.</span> <span class="post-toc-text">sem_timedwait函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#生产者消费者信号量模型"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">生产者消费者信号量模型</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进程间同步"><span class="post-toc-number">7.</span> <span class="post-toc-text">进程间同步</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#互斥量mutex-1"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">互斥量mutex</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#主要应用函数：-4"><span class="post-toc-number">7.1.1.</span> <span class="post-toc-text">主要应用函数：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#进程间mutex示例"><span class="post-toc-number">7.1.2.</span> <span class="post-toc-text">进程间mutex示例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件锁"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">文件锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#进程间文件锁示例"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">进程间文件锁示例</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#哲学家用餐模型分析"><span class="post-toc-number">8.</span> <span class="post-toc-text">哲学家用餐模型分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多线程版："><span class="post-toc-number">8.1.</span> <span class="post-toc-text">多线程版：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多进程版"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">多进程版</span></a></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.huangshurong.top" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                HSR &copy; 2017 - 2019
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=www.huangshurong.top/2019/09/16/Linux系统编程-线程同步/&title=《Linux系统编程-线程同步》 — 庸的博客&pic=www.huangshurong.top/img/yong.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=www.huangshurong.top/2019/09/16/Linux系统编程-线程同步/&title=《Linux系统编程-线程同步》 — 庸的博客&source=这是一个菜鸡的博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACtklEQVR42u3ay24jMQwEwPz/T+8Ce1og8KSblOwcak6GX6NyAJFh6+srvv78u74//v+Z2fPfX03WcPjCw8PDGy391fXMe75l8j353fPP4uHh4b2HlxeD5+0+YSTFoy1OL5/Hw8PD+ygvQSYlIXn/rCDh4eHh/TZevqzZfKAtTnh4eHif5eXjgIQ0KxjtEOTwrAUPDw8v5m0CsE89flO+h4eHh1em6vtrXww2q8XDw8O7wdsMFPLNuj2w1Y6Pf1gDHh4e3mXeO8tDG4A9H0R4CcbDw8M7ysuPQOUj1A2+PXzww8+Hh4eHd433TMq3+HbRZ4tNNGvBw8PDW/PaIcLzx4rRalxs8va6Dsnw8PDwRrx2w0061fzAQf7ZWdOPh4eHd4OXR2LtM21FahvxpCDh4eHh3eDlodRmFJt/c96sR0UCDw8P7zIvb6NnjewztR03RAMLPDw8vAu8NtCaHYdqR8P78cfLvyEeHh7emtdu5bNNfDa63YdheHh4eDd4eYQ/G0PMvm3Dfvl/Ax4eHt4hXnvLPO5qR7ez2KwYQ+Dh4eEd4rXTznZBdY0qA7DiPXh4eHjXeO3o4WzcdWVKjYeHh3c5ANsfGpgVgFl5KGbVeHh4eId4m2HEDLkpOXX7joeHh3eBl7ews5iqXXS+kuLueHh4eBd4yaGo9pazECspNnnTj4eHh3ePt9pwF+WhLQOzd+Lh4eHd4yVRU7Iptw36qprlARgeHh7eId7ZG+fRV7Lp58eqogEuHh4e3iHeZkCQFI+o5S0b7lMHEfDw8PA2vHZB+Rbc/sbJIKMeHOPh4eFd482CqE1kNYvi2sMHeHh4eL+fN/vsLGarAzA8PDy8t/PyYCx5tQ3Y8iMO0Qt4eHh4a14eerVN82zgm8Ci6AsPDw/vAm8WgG3a5TbcOlAe8PDw8M7w/gIxrX7j2k6luQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
