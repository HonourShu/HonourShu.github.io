<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>Linux系统编程-进程 | 庸的博客 | 爱代码,爱生活~</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content>
    <link rel="shortcut icon" href="/img/yong.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	false,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/yong.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">HSR</h5>
          <a href="mailto:461467948@qq.com" title="461467948@qq.com" class="mail">
            
              <span>4</span>
            
              <span>6</span>
            
              <span>1</span>
            
              <span>4</span>
            
              <span>6</span>
            
              <span>7</span>
            
              <span>9</span>
            
              <span>4</span>
            
              <span>8</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/HonourShu" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>Linux系统编程-进程</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">Linux系统编程-进程</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-09-10T03:07:27.000Z" itemprop="datePublished" class="page-time">
  2019-09-10
</time>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-Linux系统编程-进程"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">Linux系统编程-进程</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-09-10 11:07:27" datetime="2019-09-10T03:07:27.000Z"  itemprop="datePublished">2019-09-10</time>

            


            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a><strong>程序和进程</strong></h2><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p>
<p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p>
<p>程序 → 剧本(纸)        进程 → 戏(舞台、演员、灯光、道具…)</p>
<p>同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)</p>
<p>如：同时开两个终端。各自都有一个bash但彼此ID不同。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p>
<p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p>
<a rel=Linux系统编程-进程 href="/2019/09/10/Linux系统编程-进程/fork1.png" title="This is an example image" data-fancybox="images"><img src="/2019/09/10/Linux系统编程-进程/fork1.png" title="This is an example image"></a>

<h3 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a><strong>单道程序设计</strong></h3><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><strong>多道程序设计</strong></h3><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p>
<p><strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p>
<h2 id="CPU和MMU"><a href="#CPU和MMU" class="headerlink" title="CPU和MMU"></a><strong>CPU和MMU</strong></h2><a rel=Linux系统编程-进程 href="/2019/09/10/Linux系统编程-进程/fork2.png" title="This is an example image" data-fancybox="images"><img src="/2019/09/10/Linux系统编程-进程/fork2.png" title="This is an example image"></a>

<a rel=Linux系统编程-进程 href="/2019/09/10/Linux系统编程-进程/fork3.png" title="This is an example image" data-fancybox="images"><img src="/2019/09/10/Linux系统编程-进程/fork3.png" title="This is an example image"></a>

<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a><strong>进程控制块PCB</strong></h2><p>我们知道，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h文件中可以查看struct task_struct 结构体定义。其内部成员有很多，我们重点掌握以下部分即可：</p>
<p>* 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</p>
<p>* 进程的状态，有就绪、运行、挂起、停止等状态。</p>
<p>* 进程切换时需要保存和恢复的一些CPU寄存器。</p>
<p>* 描述虚拟地址空间的信息。</p>
<p>* 描述控制终端的信息。</p>
<p>* 当前工作目录（Current Working Directory）。</p>
<p>* umask掩码。</p>
<p>* 文件描述符表，包含很多指向file结构体的指针。</p>
<p>* 和信号相关的信息。</p>
<p>* 用户id和组id。</p>
<p>* 会话（Session）和进程组。</p>
<p>* 进程可以使用的资源上限（Resource Limit）。</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h2><p>进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。</p>
<a rel=Linux系统编程-进程 href="/2019/09/10/Linux系统编程-进程/fork4.png" title="" data-fancybox="images"><img src="/2019/09/10/Linux系统编程-进程/fork4.png"></a>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a><strong>环境变量</strong></h2><p>按照惯例，环境变量字符串都是name=value这样的形式，大多数name由大写字母加下划线组成，一般把name的部分叫做环境变量，value的部分则是环境变量的值。环境变量定义了进程的运行环境，一些比较重要的环境变量的含义如下：</p>
<h4 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a><strong>PATH</strong></h4><p>可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值：</p>
<p>$ echo $PATH</p>
<h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a><strong>SHELL</strong></h4><p>当前Shell，它的值通常是/bin/bash。</p>
<h4 id="TERM"><a href="#TERM" class="headerlink" title="TERM"></a><strong>TERM</strong></h4><p>当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。</p>
<h4 id="LANG"><a href="#LANG" class="headerlink" title="LANG"></a><strong>LANG</strong></h4><p>语言和locale，决定了字符编码以及时间、货币等信息的显示格式。</p>
<h4 id="HOME"><a href="#HOME" class="headerlink" title="HOME"></a><strong>HOME</strong></h4><p>当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。</p>
<h4 id="getenv函数"><a href="#getenv函数" class="headerlink" title="getenv函数"></a><strong>getenv函数</strong></h4><p>获取环境变量值</p>
<p>​    char *getenv(const char *name);     成功：返回环境变量的值；失败：NULL (name不存在)</p>
<h4 id="setenv函数"><a href="#setenv函数" class="headerlink" title="setenv函数"></a><strong>setenv函数</strong></h4><p>设置环境变量的值    </p>
<p>​    int setenv(const char *name, const char *value, int overwrite);      成功：0；失败：-1</p>
<p>​    参数overwrite取值：    1：覆盖原环境变量 </p>
<p>0：不覆盖。(该参数常用于设置新环境变量，如：ABC = haha-day-night)</p>
<h4 id="unsetenv函数"><a href="#unsetenv函数" class="headerlink" title="unsetenv函数"></a><strong>unsetenv函数</strong></h4><p>删除环境变量name的定义</p>
<p>​    int unsetenv(const char *name);     成功：0；失败：-1 </p>
<p>​    注意事项：name不存在仍返回0(成功)，当name命名为”ABC=”时则会出错。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><strong>进程控制</strong></h2><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><strong>fork函数</strong></h4><p>创建一个子进程。</p>
<p>pid_t fork(void);    失败返回-1；成功返回：① 父进程返回子进程的ID(非负)    ②子进程返回 0 </p>
<p>pid_t类型表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1)</p>
<p>​    注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。</p>
<a rel=Linux系统编程-进程 href="/2019/09/10/Linux系统编程-进程/fork6.png" title="" data-fancybox="images"><img src="/2019/09/10/Linux系统编程-进程/fork6.png"></a>

<p>从上图我们可以很清晰的看到，当n为3时候，循环创建了(2^n)-1个子进程，而不是N的子进程。需要在循环的过程，保证子进程不再执行fork ，因此当(fork() == 0)时，子进程应该立即break;才正确。</p>
<h4 id="循环创建n个子进程"><a href="#循环创建n个子进程" class="headerlink" title="循环创建n个子进程"></a><strong>循环创建n个子进程</strong></h4><p>一次fork函数调用可以创建一个子进程。那么创建N个子进程应该怎样实现呢？</p>
<p>简单想，for(i = 0; i &lt; n; i++) { fork() } 即可。但这样创建的是N个子进程吗？</p>
<h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a><strong>getpid函数</strong></h4><p>获取当前进程ID</p>
<p>​    pid_t getpid(void);        </p>
<h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a><strong>getppid函数</strong></h4><p>​    获取当前进程的父进程ID</p>
<p>​        pid_t getppid(void);</p>
<p>区分一个函数是“系统函数”还是“库函数”依据：</p>
<p>​    ① 是否访问内核数据结构</p>
<p>​    ② 是否访问外部硬件资源        二者有任一 → 系统函数；二者均无 → 库函数</p>
<h4 id="getuid函数"><a href="#getuid函数" class="headerlink" title="getuid函数"></a><strong>getuid函数</strong></h4><p>获取当前进程实际用户ID</p>
<p>uid_t getuid(void);</p>
<p>​    获取当前进程有效用户ID</p>
<p>uid_t geteuid(void);</p>
<h4 id="getgid函数"><a href="#getgid函数" class="headerlink" title="getgid函数"></a><strong>getgid函数</strong></h4><p>​    获取当前进程使用用户组ID</p>
<p>gid_t getgid(void);</p>
<p>​    获取当前进程有效用户组ID</p>
<p>gid_t getegid(void);</p>
<h2 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a><strong>进程共享</strong></h2><p>父子进程之间在fork后。有哪些相同，那些相异之处呢？</p>
<p>刚fork之后：</p>
<p>父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…</p>
<p>父子不同处: 1.进程ID   2.fork返回值   3.父进程ID    4.进程运行时间    5.闹钟(定时器)   6.未决信号集</p>
<p>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</p>
<p>当然不是!父子进程间遵循<strong>读时共享写时复制</strong>的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。   </p>
<p>重点注意！躲避父子进程共享全局变量的知识误区！</p>
<p>【重点】：父子进程共享：1. 文件描述符(打开文件的结构体)  2. mmap建立的映射区 (进程间通信详解)</p>
<p>特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。</p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><strong>gdb调试</strong></h3><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p>
<p>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</p>
<p>set follow-fork-mode parent 设置跟踪父进程。</p>
<p>注意，一定要在fork函数调用之前设置才有效。</p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a><strong>exec函数族</strong></h2><p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</p>
<p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</p>
<p>其实有六种以exec开头的函数，统称exec函数：</p>
<p>int execl(const char *path, const char *arg, …);</p>
<p>int execlp(const char *file, const char *arg, …);</p>
<p>int execle(const char *path, const char *arg, …, char *const envp[]);</p>
<p>int execv(const char *path, char *const argv[]);</p>
<p>int execvp(const char *file, char *const argv[]);</p>
<p>int execve(const char *path, char *const argv[], char *const envp[]);</p>
<h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h4><p>加载一个进程，借助PATH环境变量         </p>
<p>int execlp(const char *file, const char *arg, …);        成功：无返回；失败：-1</p>
<p>​    参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</p>
<p>​    该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。</p>
<h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h4><p>加载一个进程， 通过 路径+程序名 来加载。 </p>
<p>​    int execl(const char *path, const char *arg, …);        成功：无返回；失败：-1</p>
<p>对比execlp，如加载”ls”命令带有-l，-F参数</p>
<p>execlp(“ls”, “ls”, “-l”, “-F”, NULL);         使用程序名在PATH中搜索。</p>
<p>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL);    使用参数1给出的绝对路径搜索。</p>
<h4 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h4><p>加载一个进程，使用自定义环境变量env</p>
<p>int execvp(const char *file, const char *argv[]);</p>
<p>变参形式： ①… ② argv[]  (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …)) </p>
<p>变参终止条件：① NULL结尾 ② 固参指定</p>
<p>execvp与execlp参数形式不同，原理一致。</p>
<h4 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a><strong>exec函数族一般规律</strong></h4><p>exec函数一旦调用成功即执行新的程序，不返回。<strong>只有失败才返回，错误值-1</strong>。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</p>
<p>l (list)            命令行参数列表</p>
<p>p (path)            搜素file时使用path变量</p>
<p>v (vector)            使用命令行参数数组</p>
<p>e (environment)    使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p>
<p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示。</p>
<a rel=Linux系统编程-进程 href="/2019/09/10/Linux系统编程-进程/fork5.png" title="" data-fancybox="images"><img src="/2019/09/10/Linux系统编程-进程/fork5.png"></a>

<h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a><strong>回收子进程</strong></h2><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a><strong>孤儿进程</strong></h4><p>​    孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a><strong>僵尸进程</strong></h4><p>僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。  </p>
<p>特别注意，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。思考！用什么办法可清除掉僵尸进程呢？</p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a><strong>wait函数</strong></h4><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p>
<p>① 阻塞等待子进程退出 </p>
<p>② 回收子进程残留资源 </p>
<p>③ 获取子进程结束状态(退出原因)。</p>
<p>​    <strong>pid_t wait(int *status);</strong>     成功：清理掉的子进程ID；失败：-1 (没有子进程)</p>
<p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p>
<p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</p>
<p> \1.  WIFEXITED(status) 为非0    → 进程正常结束</p>
<p>​    WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</p>
<p> \2.     WIFSIGNALED(status) 为非0 → 进程异常终止</p>
<p>​    WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p>
<p>*3.     WIFSTOPPED(status) 为非0 → 进程处于暂停状态</p>
<p>​    WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。</p>
<p>​    WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行</p>
<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h4><p>作用同wait，但可指定pid进程清理，可以不阻塞。</p>
<p>​    <strong>pid_t waitpid(pid_t pid, int *status, in options);</strong>    成功：返回清理掉的子进程ID；失败：-1(无子进程)</p>
<p>特殊参数和返回情况：</p>
<p>参数pid： </p>
<p><strong>&gt; 0 回收指定ID的子进程</strong>    </p>
<p><strong>-1 回收任意子进程（相当于wait）</strong></p>
<p>0 回收和当前调用waitpid一个组的所有子进程</p>
<p>​        &lt; -1 回收指定进程组内的任意子进程</p>
<p>返回0：参3为WNOHANG，且子进程正在运行。</p>
<p>注意：<strong>一次wait或waitpid调用只能清理一个子进程</strong>，清理多个子进程应使用循环。</p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-09-10T07:52:28.611Z" itemprop="dateUpdated">2019-09-10 15:52:28</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2019/09/10/Linux系统编程-进程/" target="_blank" rel="external">www.huangshurong.top/2019/09/10/Linux系统编程-进程/</a>
        
    </div>
    <footer>
        <a href="www.huangshurong.top">
            <img src="/img/yong.png" alt="HSR">
            HSR
        </a>
    </footer>
</blockquote>

        
        <div class="post-footer">
            
            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=www.huangshurong.top/2019/09/10/Linux系统编程-进程/&title=《Linux系统编程-进程》 — 庸的博客&pic=www.huangshurong.top/img/yong.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=www.huangshurong.top/2019/09/10/Linux系统编程-进程/&title=《Linux系统编程-进程》 — 庸的博客&source=这是一个菜鸡的博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/09/10/Linux系统编程-进程间通信/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Linux系统编程-进程间通信</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/09/10/Linux系统编程-线程/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Linux系统编程-线程</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#程序和进程"><span class="post-toc-number">1.</span> <span class="post-toc-text">程序和进程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#并发"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">并发</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单道程序设计"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">单道程序设计</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多道程序设计"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">多道程序设计</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CPU和MMU"><span class="post-toc-number">2.</span> <span class="post-toc-text">CPU和MMU</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进程控制块PCB"><span class="post-toc-number">3.</span> <span class="post-toc-text">进程控制块PCB</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进程状态"><span class="post-toc-number">4.</span> <span class="post-toc-text">进程状态</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#环境变量"><span class="post-toc-number">5.</span> <span class="post-toc-text">环境变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#PATH"><span class="post-toc-number">5.0.1.</span> <span class="post-toc-text">PATH</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#SHELL"><span class="post-toc-number">5.0.2.</span> <span class="post-toc-text">SHELL</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#TERM"><span class="post-toc-number">5.0.3.</span> <span class="post-toc-text">TERM</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#LANG"><span class="post-toc-number">5.0.4.</span> <span class="post-toc-text">LANG</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HOME"><span class="post-toc-number">5.0.5.</span> <span class="post-toc-text">HOME</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#getenv函数"><span class="post-toc-number">5.0.6.</span> <span class="post-toc-text">getenv函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#setenv函数"><span class="post-toc-number">5.0.7.</span> <span class="post-toc-text">setenv函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#unsetenv函数"><span class="post-toc-number">5.0.8.</span> <span class="post-toc-text">unsetenv函数</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进程控制"><span class="post-toc-number">6.</span> <span class="post-toc-text">进程控制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#fork函数"><span class="post-toc-number">6.0.1.</span> <span class="post-toc-text">fork函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#循环创建n个子进程"><span class="post-toc-number">6.0.2.</span> <span class="post-toc-text">循环创建n个子进程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#getpid函数"><span class="post-toc-number">6.0.3.</span> <span class="post-toc-text">getpid函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#getppid函数"><span class="post-toc-number">6.0.4.</span> <span class="post-toc-text">getppid函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#getuid函数"><span class="post-toc-number">6.0.5.</span> <span class="post-toc-text">getuid函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#getgid函数"><span class="post-toc-number">6.0.6.</span> <span class="post-toc-text">getgid函数</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进程共享"><span class="post-toc-number">7.</span> <span class="post-toc-text">进程共享</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#gdb调试"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">gdb调试</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#exec函数族"><span class="post-toc-number">8.</span> <span class="post-toc-text">exec函数族</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#execlp函数"><span class="post-toc-number">8.0.1.</span> <span class="post-toc-text">execlp函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#execl函数"><span class="post-toc-number">8.0.2.</span> <span class="post-toc-text">execl函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#execvp函数"><span class="post-toc-number">8.0.3.</span> <span class="post-toc-text">execvp函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#exec函数族一般规律"><span class="post-toc-number">8.0.4.</span> <span class="post-toc-text">exec函数族一般规律</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#回收子进程"><span class="post-toc-number">9.</span> <span class="post-toc-text">回收子进程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#孤儿进程"><span class="post-toc-number">9.0.1.</span> <span class="post-toc-text">孤儿进程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#僵尸进程"><span class="post-toc-number">9.0.2.</span> <span class="post-toc-text">僵尸进程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#wait函数"><span class="post-toc-number">9.0.3.</span> <span class="post-toc-text">wait函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#waitpid函数"><span class="post-toc-number">9.0.4.</span> <span class="post-toc-text">waitpid函数</span></a></li></ol></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.huangshurong.top" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                HSR &copy; 2017 - 2019
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=www.huangshurong.top/2019/09/10/Linux系统编程-进程/&title=《Linux系统编程-进程》 — 庸的博客&pic=www.huangshurong.top/img/yong.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=www.huangshurong.top/2019/09/10/Linux系统编程-进程/&title=《Linux系统编程-进程》 — 庸的博客&source=这是一个菜鸡的博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aS24jMQwFQN//0h4gqwQTt9+jbCCWSivD6I9KC7ZE8naLx/1rfP/9fVxf+f9dyZNv7xgYGBgfy7hfjuupP3rl9VSun3P93odUDAyMAxh5kH10Vx6U8+uLZcLAwMAoJ51MJd+GYmBgYMwYs20fBgYGxgqjDZpJaqy9Kzk8v+AsjoGB8YGMlSD47t9vr29gYGD8eca9HO12MN/k5UH2l1lhYGBszVhPyueNFy0mXzIMDIy9GclDZ2XIvGCwsln88d3AwMA4gJEn1161ZbwO00V7BwYGxgGMWUkgP6y27WJtVg0DA+McxiwpNkvrv+q4i4GBcQJjljLLy5zr4bjYVmJgYGzKmKX1k8NnEpTzdN6TRcHAwDiGsZLuT8qQ+ZIl+Kj+iYGBsRFjlgi7B6NtqkhC9pNmCwwMjO0Y7bTaUJhsB1+VwsPAwNiVkYS/ZKJtgG7/KZotMDAwtmPUlwbUPB62ZYMn88HAwNiUkSfO2n/+RAkTAwNjC8asYWulwSJPz80KDBgYGPsxZu0R+cvWWzeiRjQMDIxjGPnjkhTb7GnttwIDA+MExixxNqskzraedYIPAwNjO8a9HG3aKz/i5u1fGBgYpzFmYa4Npu0GdKUsioGBsStjJcjOGizy1F4R6DEwMA5grLSLFemwtqaafyswMDAwFhq88nTbEgkDAwNjIaQmabVZWMfAwDiNsV4MyENnG4gxMDAwZoWBtoSZbBnzxaoBGBgYn8r4B28N9RtpjrmFAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
