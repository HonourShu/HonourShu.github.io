<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>庸的博客</title>
  
  <subtitle>爱代码,爱生活~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.huangshurong.top/"/>
  <updated>2019-09-10T04:03:45.634Z</updated>
  <id>www.huangshurong.top/</id>
  
  <author>
    <name>HSR</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统编程-进程</title>
    <link href="www.huangshurong.top/2019/09/10/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/"/>
    <id>www.huangshurong.top/2019/09/10/Linux系统编程-进程/</id>
    <published>2019-09-10T03:07:27.000Z</published>
    <updated>2019-09-10T04:03:45.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a><strong>程序和进程</strong></h2><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p><p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p><p>程序 → 剧本(纸)        进程 → 戏(舞台、演员、灯光、道具…)</p><p>同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)</p><p>如：同时开两个终端。各自都有一个bash但彼此ID不同。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h2><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p><p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p><img src="/2019/09/10/Linux系统编程-进程/fork1.png" title="This is an example image"><h2 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a><strong>单道程序设计</strong></h2><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p><h2 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><strong>多道程序设计</strong></h2><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p><p><strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p><h2 id="CPU和MMU"><a href="#CPU和MMU" class="headerlink" title="CPU和MMU"></a><strong>CPU和MMU</strong></h2><img src="/2019/09/10/Linux系统编程-进程/fork2.png" title="This is an example image"><img src="/2019/09/10/Linux系统编程-进程/fork3.png" title="This is an example image"><h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a><strong>进程控制块PCB</strong></h2><p>我们知道，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p><p>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h文件中可以查看struct task_struct 结构体定义。其内部成员有很多，我们重点掌握以下部分即可：</p><p>* 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</p><p>* 进程的状态，有就绪、运行、挂起、停止等状态。</p><p>* 进程切换时需要保存和恢复的一些CPU寄存器。</p><p>* 描述虚拟地址空间的信息。</p><p>* 描述控制终端的信息。</p><p>* 当前工作目录（Current Working Directory）。</p><p>* umask掩码。</p><p>* 文件描述符表，包含很多指向file结构体的指针。</p><p>* 和信号相关的信息。</p><p>* 用户id和组id。</p><p>* 会话（Session）和进程组。</p><p>* 进程可以使用的资源上限（Resource Limit）。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h2><p>进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。</p><img src="/2019/09/10/Linux系统编程-进程/fork4.png"><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a><strong>环境变量</strong></h2><p>按照惯例，环境变量字符串都是name=value这样的形式，大多数name由大写字母加下划线组成，一般把name的部分叫做环境变量，value的部分则是环境变量的值。环境变量定义了进程的运行环境，一些比较重要的环境变量的含义如下：</p><h4 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a><strong>PATH</strong></h4><p>可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值：</p><p>$ echo $PATH</p><h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a><strong>SHELL</strong></h4><p>当前Shell，它的值通常是/bin/bash。</p><h4 id="TERM"><a href="#TERM" class="headerlink" title="TERM"></a><strong>TERM</strong></h4><p>当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。</p><h4 id="LANG"><a href="#LANG" class="headerlink" title="LANG"></a><strong>LANG</strong></h4><p>语言和locale，决定了字符编码以及时间、货币等信息的显示格式。</p><h4 id="HOME"><a href="#HOME" class="headerlink" title="HOME"></a><strong>HOME</strong></h4><p>当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。</p><h3 id="getenv函数"><a href="#getenv函数" class="headerlink" title="getenv函数"></a><strong>getenv函数</strong></h3><p>获取环境变量值</p><p>​    char *getenv(const char *name);     成功：返回环境变量的值；失败：NULL (name不存在)</p><h3 id="setenv函数"><a href="#setenv函数" class="headerlink" title="setenv函数"></a><strong>setenv函数</strong></h3><p>设置环境变量的值    </p><p>​    int setenv(const char *name, const char *value, int overwrite);      成功：0；失败：-1</p><p>​    参数overwrite取值：    1：覆盖原环境变量 </p><p>0：不覆盖。(该参数常用于设置新环境变量，如：ABC = haha-day-night)</p><h3 id="unsetenv函数"><a href="#unsetenv函数" class="headerlink" title="unsetenv函数"></a><strong>unsetenv函数</strong></h3><p>删除环境变量name的定义</p><p>​    int unsetenv(const char *name);     成功：0；失败：-1 </p><p>​    注意事项：name不存在仍返回0(成功)，当name命名为”ABC=”时则会出错。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><strong>进程控制</strong></h2><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><strong>fork函数</strong></h3><p>创建一个子进程。</p><p>pid_t fork(void);    失败返回-1；成功返回：① 父进程返回子进程的ID(非负)    ②子进程返回 0 </p><p>pid_t类型表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1)</p><p>​    注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。</p><img src="/2019/09/10/Linux系统编程-进程/fork6.png"><p>从上图我们可以很清晰的看到，当n为3时候，循环创建了(2^n)-1个子进程，而不是N的子进程。需要在循环的过程，保证子进程不再执行fork ，因此当(fork() == 0)时，子进程应该立即break;才正确。</p><h4 id="循环创建n个子进程"><a href="#循环创建n个子进程" class="headerlink" title="循环创建n个子进程"></a><strong>循环创建n个子进程</strong></h4><p>一次fork函数调用可以创建一个子进程。那么创建N个子进程应该怎样实现呢？</p><p>简单想，for(i = 0; i &lt; n; i++) { fork() } 即可。但这样创建的是N个子进程吗？</p><h3 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a><strong>getpid函数</strong></h3><p>获取当前进程ID</p><p>​    pid_t getpid(void);        </p><h3 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a><strong>getppid函数</strong></h3><p>​    获取当前进程的父进程ID</p><p>​        pid_t getppid(void);</p><p>区分一个函数是“系统函数”还是“库函数”依据：</p><p>​    ① 是否访问内核数据结构</p><p>​    ② 是否访问外部硬件资源        二者有任一 → 系统函数；二者均无 → 库函数</p><h3 id="getuid函数"><a href="#getuid函数" class="headerlink" title="getuid函数"></a><strong>getuid函数</strong></h3><p>获取当前进程实际用户ID</p><p>uid_t getuid(void);</p><p>​    获取当前进程有效用户ID</p><p>uid_t geteuid(void);</p><h3 id="getgid函数"><a href="#getgid函数" class="headerlink" title="getgid函数"></a><strong>getgid函数</strong></h3><p>​    获取当前进程使用用户组ID</p><p>gid_t getgid(void);</p><p>​    获取当前进程有效用户组ID</p><p>gid_t getegid(void);</p><h3 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a><strong>进程共享</strong></h3><p>父子进程之间在fork后。有哪些相同，那些相异之处呢？</p><p>刚fork之后：</p><p>父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…</p><p>父子不同处: 1.进程ID   2.fork返回值   3.父进程ID    4.进程运行时间    5.闹钟(定时器)   6.未决信号集</p><p>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</p><p>当然不是!父子进程间遵循<strong>读时共享写时复制</strong>的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。   </p><p>重点注意！躲避父子进程共享全局变量的知识误区！</p><p>【重点】：父子进程共享：1. 文件描述符(打开文件的结构体)  2. mmap建立的映射区 (进程间通信详解)</p><p>特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。</p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><strong>gdb调试</strong></h3><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p><p>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</p><p>set follow-fork-mode parent 设置跟踪父进程。</p><p>注意，一定要在fork函数调用之前设置才有效。</p><h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a><strong>exec函数族</strong></h2><p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</p><p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</p><p>其实有六种以exec开头的函数，统称exec函数：</p><p>int execl(const char *path, const char *arg, …);</p><p>int execlp(const char *file, const char *arg, …);</p><p>int execle(const char *path, const char *arg, …, char *const envp[]);</p><p>int execv(const char *path, char *const argv[]);</p><p>int execvp(const char *file, char *const argv[]);</p><p>int execve(const char *path, char *const argv[], char *const envp[]);</p><h3 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h3><p>加载一个进程，借助PATH环境变量         </p><p>int execlp(const char *file, const char *arg, …);        成功：无返回；失败：-1</p><p>​    参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</p><p>​    该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。</p><h3 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h3><p>加载一个进程， 通过 路径+程序名 来加载。 </p><p>​    int execl(const char *path, const char *arg, …);        成功：无返回；失败：-1</p><p>对比execlp，如加载”ls”命令带有-l，-F参数</p><p>execlp(“ls”, “ls”, “-l”, “-F”, NULL);         使用程序名在PATH中搜索。</p><p>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL);    使用参数1给出的绝对路径搜索。</p><h3 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h3><p>加载一个进程，使用自定义环境变量env</p><p>int execvp(const char *file, const char *argv[]);</p><p>变参形式： ①… ② argv[]  (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …)) </p><p>变参终止条件：① NULL结尾 ② 固参指定</p><p>execvp与execlp参数形式不同，原理一致。</p><h3 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a><strong>exec函数族一般规律</strong></h3><p>exec函数一旦调用成功即执行新的程序，不返回。<strong>只有失败才返回，错误值-1</strong>。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</p><p>l (list)            命令行参数列表</p><p>p (path)            搜素file时使用path变量</p><p>v (vector)            使用命令行参数数组</p><p>e (environment)    使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p><p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示。</p><img src="/2019/09/10/Linux系统编程-进程/fork5.png"><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a><strong>回收子进程</strong></h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a><strong>孤儿进程</strong></h3><p>​    孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a><strong>僵尸进程</strong></h3><p>僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。  </p><p>特别注意，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。思考！用什么办法可清除掉僵尸进程呢？</p><h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a><strong>wait函数</strong></h3><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p><p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p><p>① 阻塞等待子进程退出 </p><p>② 回收子进程残留资源 </p><p>③ 获取子进程结束状态(退出原因)。</p><p>​    <strong>pid_t wait(int *status);</strong>     成功：清理掉的子进程ID；失败：-1 (没有子进程)</p><p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p><p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</p><p> \1.  WIFEXITED(status) 为非0    → 进程正常结束</p><p>​    WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</p><p> \2.     WIFSIGNALED(status) 为非0 → 进程异常终止</p><p>​    WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p><p>*3.     WIFSTOPPED(status) 为非0 → 进程处于暂停状态</p><p>​    WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。</p><p>​    WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行</p><h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h3><p>作用同wait，但可指定pid进程清理，可以不阻塞。</p><p>​    <strong>pid_t waitpid(pid_t pid, int *status, in options);</strong>    成功：返回清理掉的子进程ID；失败：-1(无子进程)</p><p>特殊参数和返回情况：</p><p>参数pid： </p><p><strong>&gt; 0 回收指定ID的子进程</strong>    </p><p><strong>-1 回收任意子进程（相当于wait）</strong></p><p>0 回收和当前调用waitpid一个组的所有子进程</p><p>​        &lt; -1 回收指定进程组内的任意子进程</p><p>返回0：参3为WNOHANG，且子进程正在运行。</p><p>注意：<strong>一次wait或waitpid调用只能清理一个子进程</strong>，清理多个子进程应使用循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;程序和进程&quot;&gt;&lt;a href=&quot;#程序和进程&quot; class=&quot;headerlink&quot; title=&quot;程序和进程&quot;&gt;&lt;/a&gt;&lt;strong&gt;程序和进程&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程-线程</title>
    <link href="www.huangshurong.top/2019/09/10/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    <id>www.huangshurong.top/2019/09/10/Linux系统编程-线程/</id>
    <published>2019-09-10T02:00:27.247Z</published>
    <updated>2019-09-10T03:08:30.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a><strong>线程概念</strong></h2><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)<br>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。    独居(进程)；合租(线程)。<br>Linux下：    线程：最小的执行单位<br>             进程：最小分配资源单位，可看成是只有一个线程的进程。</p><img src="/2019/09/10/Linux系统编程-线程/p1.png" title="This is an example image"><h2 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a><strong>Linux内核线程实现原理</strong></h2><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p><ol><li><p>轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</p></li><li><p>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</p></li><li><p>进程可以蜕变成线程</p></li><li><p>线程可看做寄存器和栈的集合</p></li><li><p>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</p></li></ol><p>察看LWP号：ps –Lf pid 查看指定线程的lwp号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程概念&quot;&gt;&lt;a href=&quot;#线程概念&quot; class=&quot;headerlink&quot; title=&quot;线程概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;线程概念&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;LWP：light weight process 轻量级的进程，本质仍是进程(在Linux
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程-信号</title>
    <link href="www.huangshurong.top/2019/09/08/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/"/>
    <id>www.huangshurong.top/2019/09/08/Linux系统编程-信号/</id>
    <published>2019-09-08T02:30:53.000Z</published>
    <updated>2019-09-08T16:41:04.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h2><p>信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪……他们都有共性：1. 简单 2. 不能携带大量信息 3. 满足某个特设条件才发送。</p><p>信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p><p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p><h2 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h2><p>A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</p><p>信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p><h2 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a>与信号相关的事件和状态</h2><h3 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号:"></a>产生信号:</h3><ol><li>按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</li><li>系统调用产生，如：kill、raise、abort</li><li>软件条件产生，如：定时器alarm</li><li>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</li><li>命令产生，如：kill命令</li></ol><h3 id="递达："><a href="#递达：" class="headerlink" title="递达："></a>递达：</h3><p>递送并且到达进程。</p><h3 id="未决："><a href="#未决：" class="headerlink" title="未决："></a>未决：</h3><p>产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 </p><h3 id="信号的处理方式"><a href="#信号的处理方式" class="headerlink" title="信号的处理方式:"></a>信号的处理方式:</h3><ol><li>执行默认动作 </li><li>忽略(丢弃) </li><li>捕捉(调用户处理函数)<br> Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</li></ol><h3 id="阻塞信号集-信号屏蔽字-："><a href="#阻塞信号集-信号屏蔽字-：" class="headerlink" title="阻塞信号集(信号屏蔽字)："></a>阻塞信号集(信号屏蔽字)：</h3><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)</p><h3 id="未决信号集"><a href="#未决信号集" class="headerlink" title="未决信号集:"></a>未决信号集:</h3><p>1.信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。<br>2.信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p><h2 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h2><p>可以使用kill –l命令查看当前系统可使用的信号有哪些。<br>1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL         5) SIGTRAP<br>6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1<br>11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM<br>16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP<br>21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ<br>26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR<br>31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3<br>38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8<br>43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13<br>48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12<br>53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7<br>58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2<br>63) SIGRTMAX-1    64) SIGRTMAX<br>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</p><h2 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h2><p>与变量三要素类似的，每个信号也有其必备4要素，分别是：</p><ol><li>编号 2. 名称 3. 事件 4. 默认处理动作</li></ol><p>可通过man 7 signal查看帮助文档获取。也可查看/usr/src/linux-headers-3.16.0-30/arch/s390/include/uapi/asm/signal.h<br>注意从man 7 signal帮助文档中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.<br>这里特别强调了9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。<br>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信号的概念&quot;&gt;&lt;a href=&quot;#信号的概念&quot; class=&quot;headerlink&quot; title=&quot;信号的概念&quot;&gt;&lt;/a&gt;信号的概念&lt;/h2&gt;&lt;p&gt;信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪……他们都有共性：1
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
