<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[C++STL02]]></title>
      <url>/2019/10/26/C-STL02/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++STL01]]></title>
      <url>/2019/10/18/C-STL01/</url>
      <content type="html"><![CDATA[<h2 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a><strong>三大组件</strong></h2><h4 id="容器-vector"><a href="#容器-vector" class="headerlink" title="容器 vector"></a>容器 vector</h4><h4 id="算法-algorithm"><a href="#算法-algorithm" class="headerlink" title="算法 algorithm"></a>算法 algorithm</h4><h4 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 iterator</h4><p>每个容器都有专属迭代器</p>
<p>vector&lt; int &gt; v;</p>
<p>vector&lt; int &gt;::iterator it = </p>
<p>v.begin() 指向第一个数据</p>
<p>v.end() 指向容器最后位置的后一个地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*(p+i)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//声明容器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//声明一个容器，这个容器中存放int类型的数据  对象名称v</span></span><br><span class="line">    <span class="comment">//向容器中加入数据</span></span><br><span class="line"></span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line">    <span class="comment">//遍历容器中的数据</span></span><br><span class="line">    <span class="comment">//利用迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator itBegin = v.begin();//itBegin指向的是v容器中的起始位置</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator itEnd = v.end();//itEnd指向容器中最后一个位置的下一个地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// while(itBegin != itEnd)</span></span><br><span class="line">    <span class="comment">// &#123;   </span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;*itBegin&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     itBegin++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//第二种遍历方法</span></span><br><span class="line">    <span class="comment">// for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;*it&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种遍历方法  利用算法</span></span><br><span class="line">    for_each(v.begin(), v.end(), myPrint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"大头儿子"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"小头爸爸"</span>, <span class="number">32</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"隔壁王叔叔"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"围裙妈妈"</span>, <span class="number">28</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.push_back(p1);</span><br><span class="line">    v.push_back(p2);</span><br><span class="line">    v.push_back(p3);</span><br><span class="line">    v.push_back(p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;Person&gt;::iterator it=v.begin();it!=v.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"姓名："</span>&lt;&lt;(*it).m_Name&lt;&lt;<span class="string">" 年龄："</span>&lt;&lt;it-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存放自定义类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person *&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"大头儿子"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"小头爸爸"</span>, <span class="number">32</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"隔壁王叔叔"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"围裙妈妈"</span>, <span class="number">28</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.push_back(&amp;p1);</span><br><span class="line">    v.push_back(&amp;p2);</span><br><span class="line">    v.push_back(&amp;p3);</span><br><span class="line">    v.push_back(&amp;p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;Person *&gt;::iterator it=v.begin();it!=v.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"姓名："</span>&lt;&lt;(*it)-&gt;m_Name&lt;&lt;<span class="string">" 年龄："</span>&lt;&lt;(*it)-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.push_back(i);</span><br><span class="line">        v2.push_back(i + <span class="number">10</span>);</span><br><span class="line">        v3.push_back(i + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将小容器放入大容器中</span></span><br><span class="line">    v.push_back(v1);</span><br><span class="line">    v.push_back(v2);</span><br><span class="line">    v.push_back(v3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.begin(); it!=v.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit=(*it).begin();vit!=(*it).end();vit++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;*vit&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="comment">// test02();</span></span><br><span class="line">    <span class="comment">// test03();</span></span><br><span class="line">    test05();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String容器"><a href="#String容器" class="headerlink" title="String容器"></a><strong>String容器</strong></h2><p>构造，赋值</p>
<p>对字符存取[]和at 的区别：[]访问越界 直接挂掉 at会抛出异常</p>
<p>substr配合find查找邮件用户名</p>
<p>char * 和string 互转：char *可以隐式转换为 string，反之不行</p>
<p>转大小写：toupper和tolower</p>
<p>find 如果找不到 返回-1，找到返回第一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;<span class="comment">//默认构造</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(str)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">string</span> str3 = str;</span><br><span class="line">    <span class="built_in">string</span> str4 = <span class="string">"abcd"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str5</span><span class="params">(<span class="number">10</span>, <span class="string">'a'</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str4 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; str5 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本赋值</span></span><br><span class="line">    str = <span class="string">"hello"</span>;</span><br><span class="line">    str2 = str4;</span><br><span class="line">    <span class="comment">//string &amp;assign(const char *s, int n);把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line">    str3.assign(str, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;s[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s.at(i)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//[]和at()区别？[]访问越界 直接挂掉 at会抛出异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;s[100]&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s.at(<span class="number">100</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(out_of_range &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"越界异常"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"我"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"爱中国"</span>;</span><br><span class="line">    s1 += s2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    s1.append(<span class="string">"!"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = s.find(<span class="string">"bcf"</span>);<span class="comment">//找不到返回时 -1</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pos: "</span>&lt;&lt;pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> pos2 = s.rfind(<span class="string">"bc"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pos2: "</span>&lt;&lt;pos2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换</span></span><br><span class="line">    <span class="built_in">string</span> s3 = <span class="string">"hello"</span>;</span><br><span class="line">    s3.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"111111"</span>);<span class="comment">//从1开始的3个字符串替换为后面的字符串</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//比较</span></span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s1.compare(s2)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"s1等于s2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s1.compare(s2)==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"s1大于s2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"s1小于s2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abcde"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = s1.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"s2: "</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需求 查找一个右键的 用户名</span></span><br><span class="line">    <span class="built_in">string</span> email = <span class="string">"zhangtao@sina.com"</span>;</span><br><span class="line">    <span class="built_in">string</span> user = email.substr();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos = email.find(<span class="string">"@"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pos: "</span>&lt;&lt;pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> usrName = email.substr(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"用户名: "</span>&lt;&lt;usrName&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line">    s1.insert(<span class="number">1</span>,<span class="string">"222"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    s1.erase(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; s &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//string -&gt; const char*</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = s.c_str();</span><br><span class="line">    func(p);<span class="comment">//const char *隐式转换为 string</span></span><br><span class="line">    <span class="comment">//const char* -&gt;string</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="comment">// func2(s2);//string 不能隐式转换为const char *</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">char</span> &amp;a = s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> &amp;b = s[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    a = <span class="string">'1'</span>;</span><br><span class="line">    b = <span class="string">'2'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>*)s.c_str()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    s = <span class="string">"pppp"</span>;</span><br><span class="line">    <span class="comment">// a = '1';</span></span><br><span class="line">    <span class="comment">// b = '2';</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>*)s.c_str()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test09</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abCdEfG"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if(s[i]&gt;='a' &amp;&amp; s[i]&lt;= 'z')</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     s[i] -= 32; </span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        s[i] = <span class="built_in">toupper</span>(s[i]);</span><br><span class="line">        <span class="comment">// s[i] = tolower(s[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="comment">// test02();</span></span><br><span class="line">    <span class="comment">// test03();</span></span><br><span class="line">    <span class="comment">// test04();</span></span><br><span class="line">    <span class="comment">// test05();</span></span><br><span class="line">    <span class="comment">// test06();</span></span><br><span class="line">    <span class="comment">// test07();</span></span><br><span class="line">    <span class="comment">// test08();</span></span><br><span class="line">    test09();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector容器"><a href="#Vector容器" class="headerlink" title="Vector容器"></a><strong>Vector容器</strong></h2><p>单端数据、动态数组</p>
<p>构造、赋值</p>
<p>大小size，重置大小resize，容量capacity</p>
<p>是否为空empty，交换swap</p>
<p>巧用swap收缩空间</p>
<p>reserve预留空间</p>
<p>insert插入（迭代器）、erase删除（迭代器）、clear（）清空容器</p>
<p>pop_back尾删 front 第一个数据 back 最后一个数据</p>
<p>逆序遍历 reverse_iterator    rbegin()      rend()</p>
<p>如果区分迭代器是否支持随机访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin();it!=v.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(arr, arr+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(v1.begin(), v1.end());</span><br><span class="line">    printVector(v2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    printVector(v3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值使用</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line">    v4.assign(v3.begin(), v3.end());</span><br><span class="line">    printVector(v4);</span><br><span class="line"></span><br><span class="line">    v4.swap(v2);</span><br><span class="line">    printVector(v4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v4.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(v4.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"v4为空!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"v4不为空!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    v4.resize(<span class="number">10</span>);</span><br><span class="line">    printVector(v4);</span><br><span class="line"></span><br><span class="line">    v4.resize(<span class="number">3</span>);</span><br><span class="line">    printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//巧用swap收缩空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的容量："</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的大小："</span>&lt;&lt;v.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    v.resize(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的容量："</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的大小："</span>&lt;&lt;v.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//巧用swap</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (v).swap(v);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的容量："</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的大小："</span>&lt;&lt;v.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.reserve(<span class="number">100000</span>);<span class="comment">//预留出空间</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">        <span class="keyword">if</span>(p!=&amp;v[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">10</span>);</span><br><span class="line">    v.push_back(<span class="number">30</span>);</span><br><span class="line">    v.push_back(<span class="number">20</span>);</span><br><span class="line">    v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的front: "</span>&lt;&lt;v.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的back: "</span>&lt;&lt;v.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    v.insert(v.begin(), <span class="number">2</span>, <span class="number">100</span>);<span class="comment">//参数1：迭代器，参数2：个数N，参数3：具体插入内容</span></span><br><span class="line">    printVector(v);</span><br><span class="line"></span><br><span class="line">    v.pop_back();<span class="comment">//尾删</span></span><br><span class="line">    printVector(v);</span><br><span class="line"></span><br><span class="line">    v.erase(v.begin());<span class="comment">//删除</span></span><br><span class="line">    printVector(v);</span><br><span class="line"></span><br><span class="line">    v.erase(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">if</span>(v.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"为空"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v.clear();<span class="comment">//清空所有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//逆序遍历</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printVector(v);</span><br><span class="line">    <span class="comment">//逆序迭代器reverse_iterator</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it=v.rbegin();it!=v.rend();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vector迭代器是随机访问的迭代器，支持跳跃访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itBegin = v.begin();</span><br><span class="line">    itBegin = itBegin +<span class="number">3</span>;<span class="comment">//如果不报错，这个迭代器支持随机访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// list&lt;int&gt; l;</span></span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;10;i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     l.push_back(i);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// list&lt;int&gt;::iterator lit = l.begin();</span></span><br><span class="line">    <span class="comment">// lit = lit + 1;//不支持随机访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="comment">// test02();</span></span><br><span class="line">    <span class="comment">// test03();</span></span><br><span class="line">    <span class="comment">// test04();</span></span><br><span class="line">    <span class="comment">// test05();</span></span><br><span class="line">    test06();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Deque容器"><a href="#Deque容器" class="headerlink" title="Deque容器"></a><strong>Deque容器</strong></h2><p>双端数组  没有容量</p>
<p>API、赋值、构造、大小、交换、插入、删除</p>
<p>头部删除、头部插入</p>
<p>pop_front</p>
<p>push_front</p>
<p>3种迭代器：普通迭代器iterator、逆序迭代器reverse_iterator、只读迭代器const_iterator</p>
<p>排序：sort()   头文件：#include &lt; algorithm &gt;</p>
<p>sort(d.begin(), d.end())；默认从小到大</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//普通迭代器iterator</span></span><br><span class="line">    <span class="comment">//逆序迭代器reverse_iterator</span></span><br><span class="line">    <span class="comment">//只读迭代器const_iterator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">40</span>);</span><br><span class="line">    d.push_back(<span class="number">30</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    printDeque(d);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d2(d.begin(), d.end());</span><br><span class="line">    d2.push_back(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    d.swap(d2);</span><br><span class="line">    printDeque(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不为空，大小为："</span> &lt;&lt; d2.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">30</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line">    printDeque(d);</span><br><span class="line"></span><br><span class="line">    d.pop_back();</span><br><span class="line">    d.pop_front();</span><br><span class="line">    printDeque(d);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d2;</span><br><span class="line">    d2.push_back(<span class="number">50</span>);</span><br><span class="line">    d2.push_back(<span class="number">30</span>);</span><br><span class="line">    d2.insert(d2.begin(), d.begin(), d.end());</span><br><span class="line"></span><br><span class="line">    printDeque(d2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.push_back(<span class="number">5</span>);</span><br><span class="line">    d.push_back(<span class="number">1</span>);</span><br><span class="line">    d.push_back(<span class="number">17</span>);</span><br><span class="line">    d.push_back(<span class="number">25</span>);</span><br><span class="line">    d.push_back(<span class="number">3</span>);</span><br><span class="line">    printDeque(d);</span><br><span class="line"></span><br><span class="line">    sort(d.begin(), d.end());</span><br><span class="line">    printDeque(d);</span><br><span class="line"></span><br><span class="line">    sort(d.begin(), d.end(), myCompare);</span><br><span class="line">    printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="comment">// test02();</span></span><br><span class="line">    test03();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++基础09]]></title>
      <url>/2019/10/17/C-%E5%9F%BA%E7%A1%8009/</url>
      <content type="html"><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a><strong>类型转换</strong></h2><h3 id="静态转换-static-case"><a href="#静态转换-static-case" class="headerlink" title="静态转换 static_case"></a><strong>静态转换 static_case</strong></h3><p>使用方式：static_case&lt;目标类型&gt; (原始数据)</p>
<p>可以进行基础数据类型和父子之间的转换</p>
<p>没有父子关系的自定义类型不能静态转换</p>
<h3 id="动态转换-dynamic-case"><a href="#动态转换-dynamic-case" class="headerlink" title="动态转换 dynamic_case"></a><strong>动态转换 dynamic_case</strong></h3><p>不可以转换基础类型</p>
<p>dynamic_cast非常严格，失去精度或者不安全都不可转换</p>
<p>父子之间：</p>
<p>​    父转子：不可以</p>
<p>​    子转父：可以</p>
<p>​    发生多态：都可以</p>
<h3 id="常量转换-const-cast"><a href="#常量转换-const-cast" class="headerlink" title="常量转换 const_cast"></a><strong>常量转换 const_cast</strong></h3><p>不能对非指针或者非引用的变量就进行转换</p>
<h3 id="重新解释转换-reinterpret-cast"><a href="#重新解释转换-reinterpret-cast" class="headerlink" title="重新解释转换 reinterpret_cast"></a><strong>重新解释转换 reinterpret_cast</strong></h3><p>最不安全，不推荐</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态转换 static_cast</span></span><br><span class="line"><span class="comment">//基础类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"d= "</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父子之间转换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *base = <span class="literal">NULL</span>;</span><br><span class="line">    Child *child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把base转为Child*类型 向下  不安全</span></span><br><span class="line">    Child *child2 = <span class="keyword">static_cast</span>&lt;Child*&gt;(base);</span><br><span class="line">    <span class="comment">//把child转为Base*类型 向上 安全</span></span><br><span class="line">    Base *base2 = <span class="keyword">static_cast</span>&lt;Base*&gt;(child);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转为other类型</span></span><br><span class="line">    <span class="comment">//Other *other = static_cast&lt;Other*&gt;(base);//无效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态转换 dynamic_cast</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//基础类型不可以转换</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">    <span class="comment">//dynamic_cast非常严格，失去精度或者不安全都不可转换</span></span><br><span class="line">    <span class="comment">//double d = dynamic_cast&lt;double&gt;(c);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *base = <span class="literal">NULL</span>;</span><br><span class="line">    Child *child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把base转为Child*类型 向下  不安全</span></span><br><span class="line">    <span class="comment">//Child *child2 = dynamic_cast&lt;Child*&gt;(base);</span></span><br><span class="line">    <span class="comment">//把child转为Base*类型 向上 安全</span></span><br><span class="line">    Base *base2 = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(child);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生多态</span></span><br><span class="line">    Base *base3 = <span class="keyword">new</span> Child;</span><br><span class="line">    Child *child3 = <span class="keyword">dynamic_cast</span>&lt;Child*&gt;(base3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dynamic_cast如果发生了多态，那么可以让基类转为派生类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量转换 const_cast</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//去除const</span></span><br><span class="line">    <span class="keyword">int</span> *newp = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//加上const</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *newp2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> *&gt;(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能对非指针或者非引用的变量就进行转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;numref = num;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;numref2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> &amp;&gt;(numref);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新解释转换 reinterpret_cast</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(a);</span><br><span class="line"></span><br><span class="line">    Base *base = <span class="literal">NULL</span>;</span><br><span class="line">    Other *other = <span class="keyword">reinterpret_cast</span>&lt;Other *&gt;(base);</span><br><span class="line">    <span class="comment">//最不安全，不推荐</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型异常的基本使用"><a href="#类型异常的基本使用" class="headerlink" title="类型异常的基本使用"></a><strong>类型异常的基本使用</strong></h2><p>try试图执行try{}中的内容</p>
<p>在可能出现异常的地方抛出异常  throw</p>
<p>try下面catch捕获异常</p>
<p>catch( 捕获类型 )  … 代表所有其他类型</p>
<p>如果不想处理异常，继续向上抛出 throw;</p>
<p>如果没有任何处理异常的地方，那么成员调用terminate函数，中断程序</p>
<p>自定义异常类，可以抛出自定义的对象，捕获这种自定义的异常</p>
<p>栈解旋：从try开始到throw抛出异常之前，所有栈上的对象都会被释放的过程</p>
<p>栈上构造顺序和析构顺序相反</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myException</span> //自定义异常类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"自定义的异常"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"构造函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"析构函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//throw -1;//抛出int类型异常</span></span><br><span class="line">        <span class="comment">//throw 3.14; //抛出double类型异常，异常必须处理，否则编译出错</span></span><br><span class="line">        <span class="comment">//throw 'a';</span></span><br><span class="line">        <span class="comment">//栈解旋：从try开始到throw抛出异常之前，所有栈上的对象都会被释放的过程</span></span><br><span class="line">        Person p1, p2;</span><br><span class="line">        <span class="keyword">throw</span> myException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int ret = myDevide(a, b);//早期如果返回-1，无法区分到底是结果还是异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        myDevide(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"int类型异常捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">double</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"double类型异常捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(myException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"其他类型异常捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">double</span>)<span class="comment">//如果异常都没有处理，那么成员调用terminate函数，使程序中断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"main函数中double类型异常捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"main函数中其他类型异常捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常的接口声明"><a href="#异常的接口声明" class="headerlink" title="异常的接口声明"></a><strong>异常的接口声明</strong></h2><p>如果想抛出特定的异常，可以利用异常的接口声明</p>
<p>throw（）不抛出任何异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>)</span><span class="comment">//throw(int)只能抛出int类型异常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">char</span>,<span class="keyword">double</span>)</span><span class="comment">//throw(int)只能抛出int类型异常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常变量的生命周期"><a href="#异常变量的生命周期" class="headerlink" title="异常变量的生命周期"></a><strong>异常变量的生命周期</strong></h2><p>如果 MyException e，会多开销一份数据</p>
<p>如果 MyException *e，不new会提前释放对象，new的话要自己释放对象delete</p>
<p>推荐 MyException &amp;e， 容易些，而且就一份数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyException()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MyException的默认构造"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyException(<span class="keyword">const</span> MyException &amp;myexception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MyException的拷贝构造"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyException()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MyException的析构调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//throw MyException();</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        doWork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch(MyException &amp;e)//MyException e会多开销一份数据，加引用就不会了</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;"捕获异常"&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">catch</span>(MyException *e)<span class="comment">//MyException e会多开销一份数据，加引用就不会了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"捕获异常"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> e;<span class="comment">//靠自觉释放对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常的多态使用"><a href="#异常的多态使用" class="headerlink" title="异常的多态使用"></a><strong>异常的多态使用</strong></h2><p>利用多态来实现printError同一个接口的使用</p>
<p>抛出不同的错误对象，提示不同的错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异常基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseException</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullPointerException</span> :</span><span class="keyword">public</span> BaseException</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"空指针异常"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutofRangeException</span> :</span><span class="keyword">public</span> BaseException</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"越界异常"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> NullPointerException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        doWork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(BaseException &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="系统提供的标准异常"><a href="#系统提供的标准异常" class="headerlink" title="系统提供的标准异常"></a><strong>系统提供的标准异常</strong></h2><p>系统提供标准异常，要包含头文件#include &lt; stdexcept &gt;</p>
<p>throw out_of_range(“年龄越界了”);</p>
<p>catch(out_of_range &amp;e){  cout&lt;&lt;e.what()&lt;&lt;endl;  }</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//系统提供标准异常，要包含头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">if</span>(age&lt;<span class="number">0</span> || age&gt;<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//throw out_of_range("年龄越界了");</span></span><br><span class="line">            <span class="keyword">throw</span> length_error(<span class="string">"长度越界了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"张三"</span>, <span class="number">222</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(out_of_range &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(length_error &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写自己的异常类"><a href="#编写自己的异常类" class="headerlink" title="编写自己的异常类"></a><strong>编写自己的异常类</strong></h2><p>自己的异常类需要继承于 exception 类</p>
<p>重写 虚析构 和 what()函数</p>
<p>内部维护以错误信息 字符串</p>
<p>构造的时候传入 错误信息字符串，在what方法返回这个字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOutofRangeException</span> :</span><span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyOutofRangeException(<span class="built_in">string</span> effInfo)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_ErrorInfo = effInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~MyOutofRangeException()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_ErrorInfo.c_str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> m_ErrorInfo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">if</span>(age&lt;<span class="number">0</span> || age&gt;<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> MyOutofRangeException(<span class="string">"我自己的越界异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"张三"</span>, <span class="number">222</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(MyOutofRangeException &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a><strong>标准输入流</strong></h2><p>cin.get()缓冲区中读取一个字符</p>
<p>cin.get(两个参数)不读换行符</p>
<p>cin.getline()读取换行，并且扔掉</p>
<p>cin.ignore() 忽略（N）N代表忽略字符数</p>
<p>cin.peek()偷窥  偷看1个字符然后放回去</p>
<p>cin.putback()放回，把字符放回缓冲区</p>
<p><strong>输入流案例</strong></p>
<ol>
<li><p>判断用户输入的是字符串还是数字，利用偷窥或者放回</p>
</li>
<li><p>让用户输入指定返回内的数字，如果输入不正确，重新输入</p>
<p>cin.fail()    标志位 0正常 1不正常</p>
<p>cin.clear()    重置标志位</p>
<p>cin.sync()    清空缓冲区</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入as 缓冲区中 a s 换行 1.拿a 2.拿s 3.拿换行 4.等待输入</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c= "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c = <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c= "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c = <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c= "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    c = <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c= "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cin,get(两个参数)读取字符串时，不会把换行符拿走，遗留在缓冲区中</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">cin</span>.get(buf, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"换行还在缓冲区"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"换行不在缓冲区"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cin.getline()把换行符读取，并且扔掉</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">cin</span>.getline(buf, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"换行还在缓冲区"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"换行不在缓冲区"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.ignore(); <span class="comment">//没有参数代表忽略一个字符，带参数n，代表忽略n个字符</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c= "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入as，偷看一眼，然后再放回缓冲区，缓冲区中还是as</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.peek();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c= "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c = <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c= "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//放回，把字符放回缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.get();</span><br><span class="line">    <span class="built_in">cin</span>.putback(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1044</span>];</span><br><span class="line">    <span class="built_in">cin</span>.getline(buf, <span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例一:判断用户输入的是字符串还是数字？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入一串数字或者字符串"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//偷窥</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.peek();</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"您输入的是数字"</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"您输入的是字符串"</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//案例二: 让用户输入1到10的数字，如果输入有误重新输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的数字为: "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"对不起，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"标志位: "&lt;&lt;cin.fail()&lt;&lt;endl;//标志位 0正常，1不正常</span></span><br><span class="line">        <span class="built_in">cin</span>.clear();</span><br><span class="line">        <span class="built_in">cin</span>.sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    <span class="comment">//test03();</span></span><br><span class="line">    <span class="comment">//test04();</span></span><br><span class="line">    <span class="comment">//test05();</span></span><br><span class="line">    <span class="comment">//test06();</span></span><br><span class="line">    <span class="comment">//test07();</span></span><br><span class="line">    test08();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a><strong>标准输出流</strong></h2><p><strong>流对象的成员函数</strong></p>
<p><strong>控制符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>.put(<span class="string">'a'</span>).put(<span class="string">'b'</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = <span class="string">"helloworld"</span>;</span><br><span class="line">    <span class="built_in">cout</span>.write(buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过流成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">99</span>;</span><br><span class="line">    <span class="built_in">cout</span>.width(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span>.fill(<span class="string">'*'</span>);</span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::left);</span><br><span class="line">    <span class="built_in">cout</span>.unsetf(ios::dec);</span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::hex);</span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::showbase);</span><br><span class="line">    <span class="built_in">cout</span>.unsetf(ios::hex);</span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::oct);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">99</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">20</span>)</span><br><span class="line">         &lt;&lt;setfill(<span class="string">'~'</span>)</span><br><span class="line">         &lt;&lt; setiosflags(ios::showbase)</span><br><span class="line">         &lt;&lt;setiosflags(ios::left) </span><br><span class="line">         &lt;&lt; hex </span><br><span class="line">         &lt;&lt; num </span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    test03();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a><strong>文件读写</strong></h2><p><strong>写文件</strong></p>
<p>​    ofstream ofs;</p>
<p>​    open 指定打开方式</p>
<p>​    is_open()判断是否打开成功</p>
<p>​    ofs&lt;&lt;”数据”</p>
<p>​    ofs.close();</p>
<p><strong>读文件</strong></p>
<p>​    ifstream ifs;</p>
<p>​    指定方式打开</p>
<p>​    判断是否打开成功</p>
<p>​    三种方式读取文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//以输出的方式打开文件</span></span><br><span class="line">    <span class="comment">//ofstream ofs("./test.txt", ios::out | ios::trunc);</span></span><br><span class="line"></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.open(<span class="string">"./test.txt"</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ofs.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ofs&lt;&lt;<span class="string">"姓名：abc"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ofs&lt;&lt;<span class="string">"年龄：100"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ofs&lt;&lt;<span class="string">"性别：男"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.open(<span class="string">"./test.txt"</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.is_open())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"打开失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (!ifs.eof())</span><br><span class="line">    &#123;</span><br><span class="line">       ifs.getline(buf2, <span class="keyword">sizeof</span>(buf2));</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;buf2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种  不推荐</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = ifs.get()) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++基础08]]></title>
      <url>/2019/10/16/C-%E5%9F%BA%E7%A1%8008/</url>
      <content type="html"><![CDATA[<h2 id="函数模板基本使用"><a href="#函数模板基本使用" class="headerlink" title="函数模板基本使用"></a><strong>函数模板基本使用</strong></h2><p>template&lt;class/typename T&gt;   告诉编译器<strong>紧跟</strong>的代码里出现T不要报错</p>
<p>myswap(T &amp;a, T &amp;b)   类型也需要传入，类型参数化</p>
<p>myswap(a,b)   自动类型推导 按照a b的类型来替换T</p>
<p>myswap()   显示指定类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型参数化  泛型编程  -- 模板技术</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //<span class="title">T</span>是一个通用类型，等价于  <span class="title">template</span>&lt;typename T&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">mySwap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//自动类型推导,必须有参数类型才可以推导</span></span><br><span class="line">    <span class="comment">//放入的变量要相同</span></span><br><span class="line">    mySwap(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示指定类型</span></span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line">    <span class="comment">//模板必须要推导出T才可以使用</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a= "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"b= "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">1.1</span>;</span><br><span class="line">    mySwap(c, d);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c= "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"d= "</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数模板案例-–通用数组排序"><a href="#函数模板案例-–通用数组排序" class="headerlink" title="函数模板案例 –通用数组排序"></a><strong>函数模板案例 –通用数组排序</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">mySwap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">mySort</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">len</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> max = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[max]&lt;arr[j])</span><br><span class="line">            &#123;</span><br><span class="line">                max = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max != i)</span><br><span class="line">        &#123;</span><br><span class="line">            mySwap(arr[max], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">printArray</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">len</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> charArr[] = <span class="string">"helloworld"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="keyword">sizeof</span>(charArr)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">    mySort(charArr, num);</span><br><span class="line">    printArray(charArr, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> intArr[] = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">32</span>, <span class="number">2</span>, <span class="number">25</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="keyword">sizeof</span>(intArr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    mySort(intArr, num2);</span><br><span class="line">    printArray(intArr, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数模板与普通函数的区别和调用规则"><a href="#函数模板与普通函数的区别和调用规则" class="headerlink" title="函数模板与普通函数的区别和调用规则"></a><strong>函数模板与普通函数的区别和调用规则</strong></h2><p><strong>区别：</strong></p>
<p>​    普通函数可以进行隐式类型转换，而函数模板不可以</p>
<p><strong>调用规则：</strong></p>
<p>​    如果出现重载，优先使用普通函数调用，如果没有实现会出现错误</p>
<p>​    如果想强制调用模板，那么可以使用空参数列表</p>
<p>​    函数模板也可以发生重载</p>
<p>​    如果函数模板可以产生更好的匹配，那么优先调用函数模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">myPlus</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myPlus2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'c'</span>;</span><br><span class="line">    myPlus(a, b);</span><br><span class="line">    <span class="comment">//myPlus(a,c);无法推导类型</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;myPlus2(a, c)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//普通函数可以进行隐式类型转换</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">myPrint</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"函数模板调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">myPrint</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>, <span class="title">T</span> <span class="title">c</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"函数模板调用abc"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"普通函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//如果出现重载，优先使用普通函数调用，如果没有实现会出现错误</span></span><br><span class="line">    myPrint(a, b);</span><br><span class="line">    <span class="comment">//如果想强制调用模板，那么可以使用空参数列表</span></span><br><span class="line">    myPrint&lt;&gt;(a, b);</span><br><span class="line">    <span class="comment">//函数模板也可以发生重载</span></span><br><span class="line">    myPrint(a, b, c);</span><br><span class="line">    <span class="comment">//如果函数模板可以产生更好的匹配，那么优先调用函数模板</span></span><br><span class="line">    <span class="keyword">char</span> e = <span class="string">'e'</span>;</span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">'d'</span>;</span><br><span class="line">    myPrint(e, d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    test02();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板机制"><a href="#模板机制" class="headerlink" title="模板机制"></a><strong>模板机制</strong></h2><p>模板并不是万能的，不能通用所有的数据类型</p>
<p>模板不能直接调用，生成后的模板函数才可以调用</p>
<p>二次编译，第一次对模板进行编译，第二次对替换T类型后的代码进行二次编译</p>
<h2 id="模板的局限性以及解决"><a href="#模板的局限性以及解决" class="headerlink" title="模板的局限性以及解决"></a><strong>模板的局限性以及解决</strong></h2><p>函数不能解决所有的类型</p>
<p>如果出现不能解决的类型，可以通过第三具体化来解决问题</p>
<p>通过具体化自定义数据类型，解决问题</p>
<p>如果具体化能够优先匹配就选择具体化</p>
<p>语法 template&lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">myCompare</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过具体化自定义数据类型，解决问题</span></span><br><span class="line"><span class="comment">//如果具体化能够优先匹配就选择具体化</span></span><br><span class="line"><span class="comment">//语法 template&lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> myCompare&lt;Person&gt;(Person &amp;a, Person &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.m_age == b.m_age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">bool</span> ret = myCompare(a, b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"ret= "</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"Jerry"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ret = myCompare(p1, p2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"ret= "</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板的基本使用"><a href="#类模板的基本使用" class="headerlink" title="类模板的基本使用"></a><strong>类模板的基本使用</strong></h2><p>与函数模板的区别</p>
<p>​    可以有默认类型参数</p>
<p>​    函数模板可以进行自动类型推导，而类模板不行</p>
<p>​    成员函数 一开始不会创建出来，而是在允许时才去创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="title">class</span> <span class="title">AgeType</span> = <span class="title">int</span>&gt; //类模板可以有默认类型参数</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(NameType name, AgeType age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"姓名: "</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name&lt;&lt;<span class="string">" 年龄: "</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person() &#123;&#125;</span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//类模板不支持自动类型推导</span></span><br><span class="line">    <span class="comment">//Person p("孙悟空", 100);</span></span><br><span class="line"></span><br><span class="line">    Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p(<span class="string">"孙悟空"</span>, <span class="number">100</span>);</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj.showPerson1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj.showPerson2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 一开始不会创建出来，而是在允许时才去创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myClass&lt;Person1&gt; m;</span><br><span class="line">    m.func1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//m.func2();//无法调用</span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板做函数的参数"><a href="#类模板做函数的参数" class="headerlink" title="类模板做函数的参数"></a><strong>类模板做函数的参数</strong></h2><p>三种方式</p>
<pre><code>1. 显示指定类型
 2. 参数模板化
 3. 整体模板化</code></pre><p>查看类型名称</p>
<p>typeid(T).name()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="title">class</span> <span class="title">AgeType</span> = <span class="title">int</span>&gt; //类模板可以有默认类型参数</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(NameType name, AgeType age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"姓名: "</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name&lt;&lt;<span class="string">" 年龄: "</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person() &#123;&#125;</span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 指定传入类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 参数模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doWork2</span>(<span class="title">Person</span>&lt;T1, T2&gt; &amp;<span class="title">P</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//如何查看类型</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(T2).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    P.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整体模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doWork3</span>(<span class="title">T</span> &amp;<span class="title">p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(T).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p1(<span class="string">"MT"</span>, <span class="number">10</span>);</span><br><span class="line">    doWork(p1);</span><br><span class="line"></span><br><span class="line">    Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p2(<span class="string">"MT2"</span>, <span class="number">5</span>);</span><br><span class="line">    doWork2(p2);</span><br><span class="line"></span><br><span class="line">    Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p3(<span class="string">"MT3"</span>, <span class="number">2</span>);</span><br><span class="line">    doWork3(p3);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板碰到继承问题以及解决"><a href="#类模板碰到继承问题以及解决" class="headerlink" title="类模板碰到继承问题以及解决"></a><strong>类模板碰到继承问题以及解决</strong></h2><p>基类如果是模板类，必须让子类告诉编译器 基类中的T到底是什么类型</p>
<p>如果不告诉编译器，那么僵无法分配内存，无法编译</p>
<p>利用参数列表class Child :public Base&lt; int &gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Child 继承于Base 必须要告诉Base中T的类型，否则T无法分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span><span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//child2也是模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Child2</span> :</span><span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_B;</span><br><span class="line">    Child2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(T2).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Child2&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; child;<span class="comment">//由用户指定类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板类外实现成员函数"><a href="#类模板类外实现成员函数" class="headerlink" title="类模板类外实现成员函数"></a><strong>类模板类外实现成员函数</strong></h2><p>template &lt;class T1, class T2&gt;<br>Person&lt;T1, T2&gt;::Person(T1 name, T2 age)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(T1 name, T2 age);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外实现成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Person</span>&lt;T1, T2&gt;:</span>:Person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Person</span>&lt;T1, T2&gt;:</span>:showPerson()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">" 年龄: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p1(<span class="string">"憨憨"</span>, <span class="number">22</span>);</span><br><span class="line">    p1.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板的分文件编写问题以及解决"><a href="#类模板的分文件编写问题以及解决" class="headerlink" title="类模板的分文件编写问题以及解决"></a><strong>类模板的分文件编写问题以及解决</strong></h2><p>.h和.cpp分别写声明和实现</p>
<p>但是由于类模板的成员函数运行阶段才去创建，导致包含.h头文件，不会创建函数的实现，无法解析外部命令</p>
<p>解决方案一: </p>
<p>​    包含.cpp文件()   （不推荐使用这种方法）</p>
<p>解决方案二: </p>
<p>​    不尽行分文件编写，写到同一个文件中，进行声明和实现，后缀名改为.hpp  (约定俗成)</p>
<p>Person.hpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(T1 name, T2 age);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Person</span>&lt;T1, T2&gt;:</span>:Person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Person</span>&lt;T1, T2&gt;:</span>:showPerson()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">" 年龄: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建议模板不要做分文件编写，写到一个类中即可，类内进行声明和实现，最后把后缀名改为 .hpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p1(<span class="string">"憨憨"</span>, <span class="number">22</span>);</span><br><span class="line">    p1.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板碰到友元函数"><a href="#类模板碰到友元函数" class="headerlink" title="类模板碰到友元函数"></a><strong>类模板碰到友元函数</strong></h2><h3 id="友元函数类内实现"><a href="#友元函数类内实现" class="headerlink" title="友元函数类内实现"></a><strong>友元函数类内实现</strong></h3><p>friend void printPerson(Person&lt;T1, T2&gt; &amp;p)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">" 年龄: "</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(T1 name, T2 age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p1(<span class="string">"憨憨"</span>, <span class="number">22</span>);</span><br><span class="line">    printPerson(p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="友元函数类外实现"><a href="#友元函数类外实现" class="headerlink" title="友元函数类外实现"></a><strong>友元函数类外实现</strong></h3><p>friend void printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);   加上&lt;&gt;才是模板函数声明，否则是普通函数声明</p>
<p>然后让编译器看到函数和类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">void</span> <span class="title">printPerson</span>(<span class="title">Person</span>&lt;T1, T2&gt; &amp;<span class="title">p</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//友元函数类内实现，利用空参数列表，告诉编译器模板函数的声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(T1 name, T2 age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">printPerson</span>(<span class="title">Person</span>&lt;T1, T2&gt; &amp;<span class="title">p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">" 年龄: "</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p1(<span class="string">"憨憨"</span>, <span class="number">22</span>);</span><br><span class="line">    printPerson(p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板的应用–数组类封装"><a href="#类模板的应用–数组类封装" class="headerlink" title="类模板的应用–数组类封装"></a><strong>类模板的应用–数组类封装</strong></h2><h3 id="MyArray-hpp"><a href="#MyArray-hpp" class="headerlink" title="MyArray.hpp"></a><strong>MyArray.hpp</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyArry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pAddress;</span><br><span class="line">    <span class="keyword">int</span> m_Capacity;</span><br><span class="line">    <span class="keyword">int</span> m_Size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyArry</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyArry(<span class="keyword">const</span> MyArry &amp;<span class="built_in">array</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Capacity = <span class="built_in">array</span>.m_Capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size = <span class="built_in">array</span>.m_Size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress[i] = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyArry()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyArry&amp; <span class="keyword">operator</span>=(MyArry &amp;<span class="built_in">array</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Capacity = <span class="built_in">array</span>.m_Capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size = <span class="built_in">array</span>.m_Size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m_Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress[i] = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_Back</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="MyArray-cpp"><a href="#MyArray-cpp" class="headerlink" title="MyArray.cpp"></a><strong>MyArray.cpp</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyArry.hpp"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;&#125;</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出int类型数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIntarray</span><span class="params">( MyArry&lt;<span class="keyword">int</span>&gt; &amp; <span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; <span class="built_in">array</span>.getSize();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">array</span>[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出Person类型数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonarray</span><span class="params">(MyArry&lt;Person&gt; &amp; <span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; <span class="built_in">array</span>.getSize();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; <span class="built_in">array</span>[i].m_Name &lt;&lt; <span class="string">" 年龄: "</span> &lt;&lt; <span class="built_in">array</span>[i].m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyArry&lt;<span class="keyword">int</span>&gt; arr(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr.push_Back(i+<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printIntarray(arr);</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"敢"</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"卤"</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"景"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"鹏"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    MyArry&lt;Person&gt; arr2(<span class="number">10</span>);</span><br><span class="line">    arr2.push_Back(p1);</span><br><span class="line">    arr2.push_Back(p2);</span><br><span class="line">    arr2.push_Back(p3);</span><br><span class="line">    arr2.push_Back(p4);</span><br><span class="line">    printPersonarray(arr2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++基础07]]></title>
      <url>/2019/10/11/C-%E5%9F%BA%E7%A1%8007/</url>
      <content type="html"><![CDATA[<h2 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a><strong>静态联编和动态联编</strong></h2><p>多态分类：静态多态(函数重载)    动态多态(虚函数  继承关系)</p>
<p>静态联编：地址早绑定，编译阶段绑定好地址</p>
<p>动态联编：地址晚绑定，运行时候绑定好地址</p>
<p>多态：父类的引用或者指针指向子类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="comment">/* args */</span>) &#123;&#125;</span><br><span class="line">    ~Animal() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"动物在说话"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="comment">/* args */</span>) &#123;&#125;</span><br><span class="line">    ~Cat() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"小猫在说话"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用doSpeak，speak函数的地址早就绑定好了，早绑定，静态联编</span></span><br><span class="line"><span class="comment">//如果想调用猫的speak，不能提前绑定好函数的地址了，所以需要在运行的时候再去确定函数地址</span></span><br><span class="line"><span class="comment">//动态联编，写法  doSpeak方法改为虚函数，在父类上声明函数，发生了多态</span></span><br><span class="line"><span class="comment">//父类的引用或者指针指向子类对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果发生了继承的关系，编译器允许进行类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Cat cat;</span><br><span class="line">    doSpeak(cat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态原理解析"><a href="#多态原理解析" class="headerlink" title="多态原理解析"></a><strong>多态原理解析</strong></h2><p>当父类有了虚函数后、内部结构就发生改变</p>
<p>内部多了一个vfptr(virtual function pointer)虚函数表指针，指向vftable 虚函数表</p>
<p>父类中结构vfptr &amp;Animal::speak </p>
<p>子类中进行继承，会继承vfptr vftable</p>
<p>构造函数中会将虚函数表指针 指向自己的虚函数表</p>
<p>如果发生了<strong>重写</strong>，会替换掉虚函数表中的原有speak，改为 &amp;Cat::speak</p>
<p>多态成立条件：</p>
<ol>
<li><p>有继承</p>
</li>
<li><p>子类重写父类虚函数函数</p>
<p>a) 返回值、函数名字、函数参数必须和父类完全一致(析构函数除外)</p>
<p>b) 子类中 virtual关键字可写可不写，建议写</p>
</li>
<li><p>类型兼容：父类指针，父类引用指向子类对象</p>
</li>
</ol>
<h2 id="多态案例–计算器案例"><a href="#多态案例–计算器案例" class="headerlink" title="多态案例–计算器案例"></a><strong>多态案例–计算器案例</strong></h2><p>早期方法不利于扩展</p>
<p>开发有原则：开闭原则—对扩展开发，对修改关闭</p>
<p>利用多态实现 – 利用后期扩展，结构性非常好，可读性高，效率稍微低，发生多态内部结构复杂</p>
<p>如果父类中有了纯虚函数，子类继承父类时必须实现纯虚函数</p>
<p>如果父类中有了纯虚函数，这个父类就无法实例化对象<br>这个类有了纯虚函数，通常称为 抽象类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstractCalculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setv1</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val1 = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setv2</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val2 = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//虚函数</span></span><br><span class="line">    <span class="comment">//virtual int getResult()&#123;return 0;&#125;</span></span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="comment">//如果父类中有了纯虚函数，子类继承父类时必须实现纯虚函数</span></span><br><span class="line">    <span class="comment">//如果父类中有了纯虚函数，这个父类就无法实例化对象</span></span><br><span class="line">    <span class="comment">//这个类有了纯虚函数，通常称为 抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val1;</span><br><span class="line">    <span class="keyword">int</span> val2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusCalculator</span>:</span> <span class="keyword">public</span> abstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 + val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCalculator</span>:</span> <span class="keyword">public</span> abstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 - val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChengCalculator</span>:</span> <span class="keyword">public</span> abstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 * val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    abstractCalculator *abc;</span><br><span class="line">    abc = <span class="keyword">new</span> PlusCalculator;</span><br><span class="line">    abc-&gt;setv1(<span class="number">10</span>);</span><br><span class="line">    abc-&gt;setv2(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;abc-&gt;getResult()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line">    abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">    abc-&gt;setv1(<span class="number">5</span>);</span><br><span class="line">    abc-&gt;setv2(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;abc-&gt;getResult()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line">    abc = <span class="keyword">new</span> ChengCalculator;</span><br><span class="line">    abc-&gt;setv1(<span class="number">5</span>);</span><br><span class="line">    abc-&gt;setv2(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;abc-&gt;getResult()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类和纯虚函数"><a href="#抽象类和纯虚函数" class="headerlink" title="抽象类和纯虚函数"></a><strong>抽象类和纯虚函数</strong></h2><p>纯虚函数写法：virtuak void func() = 0;</p>
<p>如果父类中有了纯虚函数，子类继承父类时必须实现纯虚函数</p>
<p>如果父类中有了纯虚函数，这个父类就无法实例化对象<br>这个类有了纯虚函数，通常称为 抽象类</p>
<h2 id="虚析构和纯析构函数"><a href="#虚析构和纯析构函数" class="headerlink" title="虚析构和纯析构函数"></a><strong>虚析构和纯析构函数</strong></h2><p>虚析构</p>
<p>virtual ~类名(){}</p>
<p>解决问题：通过父类指针指向子类对象释放时候不干净导致的问题</p>
<p>纯虚析构</p>
<p>virtual ~类名() = 0;</p>
<p>需要声明和实现，类内声明，类外实现</p>
<p>如果函数中出现了纯虚析构函数，那么这个类也是抽象类，不可以实例化对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//虚析构</span></span><br><span class="line">    <span class="comment">// virtual ~Animal()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;"Animal的析构调用"&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//纯虚析构</span></span><br><span class="line">    <span class="comment">//纯虚析构，需要声明和实现，类内声明，类外实现</span></span><br><span class="line">    <span class="comment">//如果函数中出现了纯虚析构函数，那么这个类也是抽象类</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Animal() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"动物在说话"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚析构的函数实现</span></span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Animal的纯虚析构调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_Name, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Cat()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Cat的析构调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] <span class="keyword">this</span>-&gt;m_Name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"小猫在说话"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> Cat(<span class="string">"Tom"</span>);</span><br><span class="line">    animal-&gt;speak();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向上类型转换和向下类型转换"><a href="#向上类型转换和向下类型转换" class="headerlink" title="向上类型转换和向下类型转换"></a><strong>向上类型转换和向下类型转换</strong></h2><p>向上类型转换：基类转派生类，不安全的</p>
<p>向下类型转换：派生类转基类，安全的</p>
<p>如果发生多态，总是安全的</p>
<h2 id="多态案例-–文字PK游戏"><a href="#多态案例-–文字PK游戏" class="headerlink" title="多态案例 –文字PK游戏"></a><strong>多态案例 –文字PK游戏</strong></h2><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a><strong>main.cpp</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Weapon.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Hero.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Monster.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Knife.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DragonSword.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建怪物</span></span><br><span class="line">    Monster *monster = <span class="keyword">new</span> Monster;</span><br><span class="line">    <span class="comment">//创建英雄</span></span><br><span class="line">    Hero *hero = <span class="keyword">new</span> Hero;</span><br><span class="line">    <span class="comment">//创建武器</span></span><br><span class="line">    Weapon *knife = <span class="keyword">new</span> Knife;</span><br><span class="line">    Weapon *dragon = <span class="keyword">new</span> DragonSword;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择武器</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请选择武器"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"1. 赤手空拳"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"2. 小刀"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"3. 屠龙宝刀"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oper;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;oper;</span><br><span class="line">    <span class="keyword">switch</span> (oper)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"你真牛X!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        hero-&gt;EquipWeapon(knife);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        hero-&gt;EquipWeapon(dragon);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">int</span> round = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="comment">//system("cls");</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"------当前第"</span>&lt;&lt;round&lt;&lt;<span class="string">"回合开始------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(hero-&gt;m_Hp &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"英雄"</span>&lt;&lt;hero-&gt;m_Name&lt;&lt;<span class="string">"已经死了，游戏结束"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hero-&gt;Attack(monster);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(monster-&gt;m_Hp &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"怪物"</span>&lt;&lt;monster-&gt;m_Name&lt;&lt;<span class="string">"已经死了，游戏通关"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        monster-&gt;Attack(hero);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hero-&gt;m_Hp &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"英雄"</span>&lt;&lt;hero-&gt;m_Name&lt;&lt;<span class="string">"已经死了，游戏结束"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"英雄"</span>&lt;&lt;hero-&gt;m_Name&lt;&lt;<span class="string">"剩余血量: "</span>&lt;&lt;hero-&gt;m_Hp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"怪物"</span>&lt;&lt;monster-&gt;m_Name&lt;&lt;<span class="string">"剩余血量: "</span>&lt;&lt;monster-&gt;m_Hp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        round ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> monster;</span><br><span class="line">    <span class="keyword">delete</span> hero;</span><br><span class="line">    <span class="keyword">delete</span> knife;</span><br><span class="line">    <span class="keyword">delete</span> dragon;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    play();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hero-h"><a href="#hero-h" class="headerlink" title="hero.h"></a><strong>hero.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Weapon.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Monster.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Hero();</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Atk;</span><br><span class="line">    <span class="keyword">int</span> m_Def;</span><br><span class="line">    <span class="keyword">int</span> m_Hp;</span><br><span class="line">    Weapon *weapon;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EquipWeapon</span><span class="params">(Weapon *weapon)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attack</span><span class="params">(Monster *monster)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="dragonsword-h"><a href="#dragonsword-h" class="headerlink" title="dragonsword.h"></a><strong>dragonsword.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Weapon.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DragonSword</span>:</span> <span class="keyword">public</span> Weapon</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DragonSword();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取基础伤害</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getBaseDamage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取吸血</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getSuckBlood</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取是否定身</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">getHold</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取是否暴击</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">getCirt</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//吸血率 定身率 暴击率</span></span><br><span class="line">    <span class="keyword">int</span> suckRate;</span><br><span class="line">    <span class="keyword">int</span> holdRate;</span><br><span class="line">    <span class="keyword">int</span> cirtRate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入概率 判断是否触发</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTrigger</span><span class="params">(<span class="keyword">int</span> rate)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="knife-h"><a href="#knife-h" class="headerlink" title="knife.h"></a><strong>knife.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Weapon.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knife</span>:</span> <span class="keyword">public</span> Weapon</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Knife();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取基础伤害</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getBaseDamage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取吸血</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getSuckBlood</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取是否定身</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">getHold</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取是否暴击</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">getCirt</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="weapon-h"><a href="#weapon-h" class="headerlink" title="weapon.h"></a><strong>weapon.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weapon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//获取基础伤害</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getBaseDamage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取吸血</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getSuckBlood</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取是否定身</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">getHold</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取是否暴击</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">getCirt</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> m_WeaponName;</span><br><span class="line">    <span class="keyword">int</span> m_BaseDamage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="monster-h"><a href="#monster-h" class="headerlink" title="monster.h"></a><strong>monster.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Weapon.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Hero.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Monster();</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_Hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_Atk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_Def;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_Hold;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attack</span><span class="params">(Hero *hero)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="dragonsword-cpp"><a href="#dragonsword-cpp" class="headerlink" title="dragonsword.cpp"></a><strong>dragonsword.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DragonSword.h"</span></span></span><br><span class="line"></span><br><span class="line">DragonSword::DragonSword()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BaseDamage = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_WeaponName = <span class="string">"屠龙宝刀"</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;suckRate = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;holdRate = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;cirtRate = <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取基础伤害</span></span><br><span class="line"><span class="keyword">int</span> DragonSword::getBaseDamage()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_BaseDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取吸血</span></span><br><span class="line"><span class="keyword">int</span> DragonSword::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isTrigger(suckRate))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_BaseDamage*<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取是否定身</span></span><br><span class="line"><span class="keyword">bool</span> DragonSword::getHold()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isTrigger(holdRate))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取是否暴击</span></span><br><span class="line"><span class="keyword">bool</span> DragonSword::getCirt()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isTrigger(cirtRate))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> DragonSword::isTrigger(<span class="keyword">int</span> rate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//随机1-100的数字</span></span><br><span class="line">    <span class="keyword">int</span> num = rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num &lt; rate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hero-cpp"><a href="#hero-cpp" class="headerlink" title="hero.cpp"></a><strong>hero.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Hero.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hero::Hero()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Hp = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Atk = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Def = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = <span class="string">"帅小景"</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weapon =<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Hero::EquipWeapon(Weapon *weapon)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;weapon = weapon;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"英雄: "</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name&lt;&lt;<span class="string">"装备了武器："</span>&lt;&lt;<span class="keyword">this</span>-&gt;weapon-&gt;m_WeaponName&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Hero::Attack(Monster *monster)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> damage = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> addHp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> isHold = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> isCrit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;weapon == <span class="literal">NULL</span>)<span class="comment">//空武器</span></span><br><span class="line">    &#123;</span><br><span class="line">        damage = <span class="keyword">this</span>-&gt;m_Atk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基础伤害</span></span><br><span class="line">       damage = <span class="keyword">this</span>-&gt;m_Atk + <span class="keyword">this</span>-&gt;weapon-&gt;getBaseDamage();</span><br><span class="line">       <span class="comment">//计算吸血</span></span><br><span class="line">       addHp = <span class="keyword">this</span>-&gt;weapon-&gt;getSuckBlood();</span><br><span class="line">       <span class="comment">//计算定身</span></span><br><span class="line">       isHold = <span class="keyword">this</span>-&gt;weapon-&gt;getHold();</span><br><span class="line">       <span class="comment">//计算暴击</span></span><br><span class="line">       isCrit = <span class="keyword">this</span>-&gt;weapon-&gt;getCirt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isCrit)</span><br><span class="line">    &#123;</span><br><span class="line">        damage = damage*<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"英雄的武器触发了暴击效果，怪物收到了双倍伤害，伤害值: "</span>&lt;&lt;damage&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isHold)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"英雄的武器触发了定身效果，怪物停止攻击一回合"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(addHp &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"英雄的武器触发了吸血效果，英雄增加的血量为: "</span>&lt;&lt;addHp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//掉怪物血量</span></span><br><span class="line">    monster-&gt;m_Hold = isHold;</span><br><span class="line">    <span class="comment">//计算真实伤害</span></span><br><span class="line">    <span class="keyword">int</span> trueDamage = (damage - monster-&gt;m_Def) &gt; <span class="number">0</span> ? damage - monster-&gt;m_Def:<span class="number">1</span>;</span><br><span class="line">    monster-&gt;m_Hp -= trueDamage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Hp += addHp;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"英雄"</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name&lt;&lt;<span class="string">"攻击了敌人 "</span>&lt;&lt;monster-&gt;m_Name&lt;&lt;<span class="string">"造成了伤害: "</span>&lt;&lt;trueDamage&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="knife-cpp"><a href="#knife-cpp" class="headerlink" title="knife.cpp"></a><strong>knife.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Knife.h"</span></span></span><br><span class="line"></span><br><span class="line">Knife::Knife()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BaseDamage = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_WeaponName = <span class="string">"小刀"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取基础伤害</span></span><br><span class="line"><span class="keyword">int</span> Knife::getBaseDamage()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_BaseDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取吸血</span></span><br><span class="line"><span class="keyword">int</span> Knife::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取是否定身</span></span><br><span class="line"><span class="keyword">bool</span> Knife::getHold()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取是否暴击</span></span><br><span class="line"><span class="keyword">bool</span> Knife::getCirt()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="monster-cpp"><a href="#monster-cpp" class="headerlink" title="monster.cpp"></a><strong>monster.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Monster.h"</span></span></span><br><span class="line"></span><br><span class="line">Monster::Monster()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Hp = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Atk = <span class="number">70</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Def = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Hold = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = <span class="string">"大敢王"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Monster::Attack(Hero *hero)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Hold)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"怪物"</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name&lt;&lt;<span class="string">"被定身了，本回合无法攻击"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> damage = (<span class="keyword">this</span>-&gt;m_Atk - hero-&gt;m_Def) &gt; <span class="number">0</span> ? <span class="keyword">this</span>-&gt;m_Atk - hero-&gt;m_Def : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    hero-&gt;m_Hp -= damage;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"怪物"</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name&lt;&lt;<span class="string">"攻击了英雄"</span>&lt;&lt;hero-&gt;m_Name&lt;&lt;<span class="string">"造成了伤害: "</span>&lt;&lt;damage&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++基础06]]></title>
      <url>/2019/10/08/C-%E5%9F%BA%E7%A1%8006/</url>
      <content type="html"><![CDATA[<h3 id="继承的引出"><a href="#继承的引出" class="headerlink" title="继承的引出"></a><strong>继承的引出</strong></h3><p>网页有很多公共部分</p>
<p>导致实现时候有很多重复的代码</p>
<p>引出继承，基类（父类）  公共网页</p>
<p>具体子类    实现不同的内容</p>
<p>语法：class 子类    :继承方式    父类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BasePage(<span class="comment">/* args */</span>)&#123;&#125;</span><br><span class="line">    ~BasePage()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"公共头部"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"公共底部"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"左侧列表"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">News</span> :</span><span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    News (<span class="comment">/* args */</span>)&#123;&#125;</span><br><span class="line">    ~News ()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"新闻播放"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YULE</span> :</span><span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    YULE()&#123;&#125;</span><br><span class="line">    ~YULE()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"娱乐项目"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"新闻网页内容: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    News news;</span><br><span class="line">    news.header();</span><br><span class="line">    news.footer();</span><br><span class="line">    news.left();</span><br><span class="line">    news.content();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"娱乐网页内容: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    YULE yl;</span><br><span class="line">    yl.header();</span><br><span class="line">    yl.footer();</span><br><span class="line">    yl.left();</span><br><span class="line">    yl.content();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a><strong>继承方式</strong></h3><p>不管是公共继承、保护继承还是私有继承，基类中的私有属性，都不可以继承下去</p>
<p>公有继承：父类中的public在子类中是public，父类中的protected在子类中还是protected</p>
<p>保护继承：父类中的public在子类中是protected，父类中的protected在子类中还是protected</p>
<p>私有继承：父类中的public在子类中是private，父类中的protected在子类中还是private</p>
<h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a><strong>继承中的对象模型</strong></h3><p>子类会继承父类中所有的内容，包括了私有属性</p>
<p>只是我们访问不到，被编译器隐藏了</p>
<h3 id="继承中的构造和析构"><a href="#继承中的构造和析构" class="headerlink" title="继承中的构造和析构"></a><strong>继承中的构造和析构</strong></h3><p>子类创建对象时，先调用父类的构造，然后调用自身的构造，析构顺序相反</p>
<p>子类不会继承父类的构造函数和析构函数</p>
<p>如果父类中没有合适的默认构造，那么子类可以利用初始化列表的方式显示的调用父类的其他构造</p>
<h3 id="继承中的同名处理"><a href="#继承中的同名处理" class="headerlink" title="继承中的同名处理"></a><strong>继承中的同名处理</strong></h3><p>成员属性：直接调用先调用子类，如果想调用父类的，需要作用域</p>
<p>成员函数：直接调用先调用子类，父类的所有版本（如默认和有参）都会被隐藏，除非加上作用域运算符去调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="comment">/* args */</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base fun调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base fun(int a)调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Son fun调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1.m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1.Base::m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    s1.fun();</span><br><span class="line">    <span class="comment">//s1.fun(10);//无法调用</span></span><br><span class="line">    s1.Base::fun(<span class="number">10</span>);</span><br><span class="line">    s1.Base::fun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承中静态成员的处理"><a href="#继承中静态成员的处理" class="headerlink" title="继承中静态成员的处理"></a><strong>继承中静态成员的处理</strong></h3><p>类似非静态成员函数、属性的处理</p>
<p>如果想访问父类中的成员，加作用域即可</p>
<h3 id="多继承的概念以及问题"><a href="#多继承的概念以及问题" class="headerlink" title="多继承的概念以及问题"></a><strong>多继承的概念以及问题</strong></h3><p>class A : public B1, puublic B2 …;</p>
<p>引发二义性问题，要通过作用域解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1(<span class="comment">/* args */</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base1() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2(<span class="comment">/* args */</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base2() &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son(<span class="comment">/* args */</span>) &#123;&#125;</span><br><span class="line">    ~Son() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Son)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Son s1;</span><br><span class="line">    <span class="comment">// s1.m_A; //二义性</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1.Base1::m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1.Base2::m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="菱形继承问题以及解决"><a href="#菱形继承问题以及解决" class="headerlink" title="菱形继承问题以及解决"></a><strong>菱形继承问题以及解决</strong></h3><p>解决问题利用虚基类</p>
<p>vbptr 虚基类指针</p>
<p>指向一张虚基类表</p>
<p>通过表找到偏移量</p>
<p>找到共有的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="comment">/* args */</span>) &#123;&#125;</span><br><span class="line">    ~Animal() &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sheep(<span class="comment">/* args */</span>) &#123;&#125;</span><br><span class="line">    ~Sheep() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tuo(<span class="comment">/* args */</span>) &#123;&#125;</span><br><span class="line">    ~Tuo() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span>:</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SheepTuo(<span class="comment">/* args */</span>) &#123;&#125;</span><br><span class="line">    ~SheepTuo() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line">    st.m_Age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;st.Sheep::m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;st.Tuo::m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;st.m_Age&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//可以直接访问，没有了二义性，只有一份m_Age</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*(<span class="keyword">int</span> *)((<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)&amp;st + <span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++基础05]]></title>
      <url>/2019/10/03/C-%E5%9F%BA%E7%A1%8005/</url>
      <content type="html"><![CDATA[<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a><strong>运算符重载</strong></h2><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a><strong>加号运算符重载</strong></h3><p>如果想让自定义数据类型 进行+运算，那么就需要重载+运算符</p>
<p>在成员函数 或者 全局函数 重写一个+运算符的函数</p>
<p>函数名 operator+() {}</p>
<p>运算符重载  也可以提供多个版本</p>
<h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a><strong>左移运算符重载</strong></h3><p>不要随意乱用符号重载</p>
<p>内置数据类型的运算符不可以重载</p>
<p>cout&lt;&lt;  直接对Person自定义数据类型 进行输出</p>
<p>重载左移运算符不能写到成员函数中，要写到全局函数中</p>
<p>ostream&amp; operator&lt;&lt;(ostream &amp;cout, Person &amp;p1){}</p>
<p>如果重载时想访问p1的私有成员，那么全局函数要做Person类的友元函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// friend ostream&amp; operator&lt;&lt;(ostream &amp;cout, Person &amp;p1);</span></span><br><span class="line">    <span class="comment">// friend Person operator+(Person &amp;p1, Person &amp;p2);</span></span><br><span class="line">    <span class="comment">// friend Person operator+(Person &amp;p1, int n);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Person()&#123;&#125;</span><br><span class="line">    Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b):m_A(a), m_B(b)&#123;&#125;</span><br><span class="line">    ~Person()&#123;&#125;</span><br><span class="line">    <span class="comment">//成员函数进行+号运算符重载</span></span><br><span class="line">    <span class="comment">// Person operator+(Person &amp;p)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     Person tmp;</span></span><br><span class="line">    <span class="comment">//     tmp.m_A = this-&gt;m_A + p.m_A;</span></span><br><span class="line">    <span class="comment">//     tmp.m_B = this-&gt;m_B + p.m_B;</span></span><br><span class="line">    <span class="comment">//     return tmp;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数进行+号运算符重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, Person &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">    Person tmp;</span><br><span class="line">    tmp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">    tmp.m_B = p1.m_B + p2.m_B;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    Person tmp;</span><br><span class="line">    tmp.m_A = p1.m_A + n;</span><br><span class="line">    tmp.m_B = p1.m_B + n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;<span class="built_in">cout</span>, Person &amp;p1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_A = "</span>&lt;&lt;p1.m_A&lt;&lt;<span class="string">" m_B = "</span>&lt;&lt;p1.m_B;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">6</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    Person p3 = p1 + p2;</span><br><span class="line">    Person p4 = p3 + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_A: "</span>&lt;&lt;p3.m_A&lt;&lt;<span class="string">"  m_B: "</span>&lt;&lt;p3.m_B&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_A: "</span>&lt;&lt;p4.m_A&lt;&lt;<span class="string">"  m_B: "</span>&lt;&lt;p4.m_B&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前置后置自增自减运算符重载"><a href="#前置后置自增自减运算符重载" class="headerlink" title="前置后置自增自减运算符重载"></a><strong>前置后置自增自减运算符重载</strong></h3><p>自己实现int类型 MyInteger</p>
<p>内部维护int数据</p>
<p>MyInteger myint</p>
<p>myint++后置       ++myint前置</p>
<p>重载++运算符 </p>
<p>operator++() 前置 先++ 后返回自身</p>
<p>operator++(int )后置 先保存原有值，内部++，返回临时值</p>
<p>–运算符同理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    MyInteger()</span><br><span class="line">    &#123;  </span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Num++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        MyInteger tmp = *<span class="keyword">this</span>;</span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_Num;</span><br><span class="line">    ~MyInteger()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;<span class="built_in">cout</span>, MyInteger &amp;myint)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;myint.m_Num;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; ++myint &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    myint++;</span><br><span class="line">    <span class="comment">//cout&lt;&lt; myint++ &lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; myint &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针运算符重载"><a href="#指针运算符重载" class="headerlink" title="指针运算符重载"></a><strong>指针运算符重载</strong></h3><p>Person类有 showAge()成员函数</p>
<p>如果new出来的Person对象，就要让程序员自觉去释放 delete</p>
<p>有了智能指针 ，让智能指针托管这个Person对象，对象的释放就不要操心了，让智能指针管理</p>
<p>为了让智能指针像普通Person*指针一样使用，就要重载 -&gt; 和 *</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span></span>;</span><br><span class="line">    ~Person();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Person::showAge()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person::Person(<span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::~Person()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person析构调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartPointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *person;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person *<span class="keyword">operator</span>-&gt;();</span><br><span class="line">    Person &amp;<span class="keyword">operator</span>*(); </span><br><span class="line">    smartPointer(Person *person);</span><br><span class="line">    ~smartPointer();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person *smartPointer::<span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person &amp;smartPointer::<span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;person;</span><br><span class="line">&#125;</span><br><span class="line">smartPointer::smartPointer(Person *person)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smartPointer::~smartPointer()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"智能指针析构"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;person != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">        <span class="keyword">this</span>-&gt;person = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Person p1(10); //自动析构</span></span><br><span class="line">    <span class="comment">// Person *p1 = new Person(10);</span></span><br><span class="line">    <span class="comment">// p1-&gt;showAge();</span></span><br><span class="line"></span><br><span class="line">    <span class="function">smartPointer <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">10</span>))</span></span>;<span class="comment">//开辟到了栈上，自动释放</span></span><br><span class="line">    sp-&gt;showAge();</span><br><span class="line">    (*sp).showAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a><strong>赋值运算符重载</strong></h3><p>系统默认给类提供 赋值运算符写法 是简单值拷贝</p>
<p>导致如果类中有指向堆区的指针，就可能出现深浅拷贝的问题</p>
<p>所以要重载 = 运算符</p>
<p>如果想链式编程  return *this</p>
<h3 id="中括号运算符重载"><a href="#中括号运算符重载" class="headerlink" title="中括号运算符重载"></a><strong>中括号运算符重载</strong></h3><p>返回数组索引的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pArray[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a><strong>关系运算符重载</strong></h3><p>自定义的数据类型，不会内部做比较 </p>
<p>所以要重载== 和 !=</p>
<h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a><strong>函数调用运算符重载</strong></h3><p>() 仿函数  对象 ()看似像函数调用</p>
<p>myadd()()  匿名对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myprint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;text&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Myprint(<span class="comment">/* args */</span>);</span><br><span class="line">    ~Myprint();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Myprint::Myprint(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Myprint::~Myprint()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Myprint p1;</span><br><span class="line">    p1(<span class="string">"hello world"</span>);</span><br><span class="line">    Myprint()(<span class="string">"666"</span>);<span class="comment">//匿名对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要重载-amp-amp-和"><a href="#不要重载-amp-amp-和" class="headerlink" title="不要重载&amp;&amp;和||"></a><strong>不要重载&amp;&amp;和||</strong></h3><p>本身有短路特性我们无法去实现这种特性，所以不要重载</p>
<h3 id="强化训练-字符串封装"><a href="#强化训练-字符串封装" class="headerlink" title="强化训练  -字符串封装"></a><strong>强化训练  -字符串封装</strong></h3><p>cout输出自定义的字符串</p>
<p>cin让用户输入字符串内容</p>
<p>重载 = 运算符</p>
<p>重载 + 运算符</p>
<p>重载 [] 运算符</p>
<p>重载 == 运算符</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     MyString str = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout&lt;&lt;str&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout&lt;&lt;"请输入新内容: "&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cin&gt;&gt;str;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;"新内容为: "&lt;&lt;str&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MyString <span class="title">str2</span><span class="params">(str)</span></span>;</span><br><span class="line"></span><br><span class="line">    MyString str3 = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    str3 = str2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str3= "</span>&lt;&lt;str3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str3 = <span class="string">"666"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str3= "</span>&lt;&lt;str3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    str3[<span class="number">0</span>] = <span class="string">'p'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str3的第一个字符为: "</span>&lt;&lt;str3[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    MyString str4 = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    str4 = str2 + str3;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str4= "</span>&lt;&lt;str4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str3 == str4)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str3和str4相等"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str3和str4不相等"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyString.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;<span class="built_in">cout</span>, MyString &amp;str);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;<span class="built_in">cin</span>, MyString &amp;str);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pString;<span class="comment">//指向堆区的指针</span></span><br><span class="line">    <span class="keyword">int</span> m_Size;<span class="comment">//字符串大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span> *str);</span><br><span class="line">    MyString(<span class="keyword">const</span> MyString &amp;str);</span><br><span class="line">    ~MyString();</span><br><span class="line"></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str);</span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> *str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line">    MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">char</span> *str);</span><br><span class="line">    MyString <span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span> *str);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString &amp;str);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>MyString.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;<span class="built_in">cout</span>, MyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str.pString;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;<span class="built_in">cin</span>, MyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.pString != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] str.pString;</span><br><span class="line">        str.pString = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line"></span><br><span class="line">    str.pString = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(buf)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str.pString, buf);</span><br><span class="line">    str.m_Size = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cin</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString::MyString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"有参构造调用"&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;pString = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pString, str);</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Size = <span class="built_in">strlen</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString::MyString(<span class="keyword">const</span> MyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;pString = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.pString)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pString, str.pString);</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Size = str.m_Size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MyString::~MyString()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"析构函数调用"&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pString != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pString;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pString = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pString != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] <span class="keyword">this</span>-&gt;pString;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pString = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;pString = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.pString)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pString, str.pString);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pString != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] <span class="keyword">this</span>-&gt;pString;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pString = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;pString = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pString, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>&amp; MyString::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;pString[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString MyString::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> newSize = <span class="keyword">this</span>-&gt;m_Size + <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="keyword">new</span> <span class="keyword">char</span>[newSize];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, newSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(tmp, <span class="keyword">this</span>-&gt;pString);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, str);</span><br><span class="line"></span><br><span class="line">    <span class="function">MyString <span class="title">newstr</span><span class="params">(tmp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString MyString::<span class="keyword">operator</span>+(<span class="keyword">const</span> MyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> newSize = <span class="keyword">this</span>-&gt;m_Size + <span class="built_in">strlen</span>(str.pString) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="keyword">new</span> <span class="keyword">char</span>[newSize];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, newSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(tmp, <span class="keyword">this</span>-&gt;pString);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, str.pString);</span><br><span class="line"></span><br><span class="line">    <span class="function">MyString <span class="title">newstr</span><span class="params">(tmp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>==(<span class="keyword">const</span> MyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;pString, str.pString) == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>-&gt;m_Size == <span class="built_in">strlen</span>(str.pString))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MyString::<span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;pString, str) == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>-&gt;m_Size == <span class="built_in">strlen</span>(str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++基础04]]></title>
      <url>/2019/09/27/C-%E5%9F%BA%E7%A1%8004/</url>
      <content type="html"><![CDATA[<h2 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a><strong>静态成员变量和静态成员函数</strong></h2><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a><strong>静态成员变量</strong></h3><p>编译阶段分配内存</p>
<p>所有对象共享内存</p>
<p>通过对象访问，通过类名访问</p>
<p>有权限控制</p>
<p>类内进行声明，类外进行初始化</p>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a><strong>静态成员函数</strong></h3><p>不可以访问普通成员变量，可以访问静态成员变量</p>
<p>普通成员函数都可以访问</p>
<p>静态成员函数也有权限</p>
<p>通过对象访问，通过类名访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_other;<span class="comment">//私有权限在类外不能访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="comment">/* args */</span>);</span><br><span class="line">    ~Person();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_Age;</span><br><span class="line">    <span class="comment">//加入static就是静态成员变量，会共享数据</span></span><br><span class="line">    <span class="comment">//静态成员变量，在类内声明，在类外进行初始化</span></span><br><span class="line">    <span class="comment">//静态成员变量 也有权限的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员函数</span></span><br><span class="line">    <span class="comment">//不可以访问普通成员变量，可以访问静态成员变量</span></span><br><span class="line">    <span class="comment">//静态成员函数有权限</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"func调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通成员函数可以访问静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::m_Age = <span class="number">0</span>; <span class="comment">//类外初始化实现</span></span><br><span class="line"><span class="keyword">int</span> Person::m_other =<span class="number">0</span>;<span class="comment">//在类外可以初始化</span></span><br><span class="line">Person::Person(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::~Person()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1 通过对象访问属性</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_Age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_Age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p1: "</span>&lt;&lt;p1.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p2: "</span>&lt;&lt;p2.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 通过类名访问属性</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"通过类名访问: "</span>&lt;&lt;Person::m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员函数调用</span></span><br><span class="line">    p1.func();</span><br><span class="line">    p2.func();</span><br><span class="line">    Person::func();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式案例"><a href="#单例模式案例" class="headerlink" title="单例模式案例"></a><strong>单例模式案例</strong></h2><h3 id="主席案例"><a href="#主席案例" class="headerlink" title="主席案例"></a><strong>主席案例</strong></h3><p>目的 为了让类中只有一个实例，实例不需要自己释放</p>
<p>将 默认构造 和 拷贝构造 私有化</p>
<p>内部维护一个 对象指针</p>
<p>私有化唯一指针</p>
<p>对外提供 getinstance 方法来访问这个指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求 单例模式 为了创建类中的对象，并且保证只有一个对象实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChairMan</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    ChairMan(<span class="comment">/* args */</span>);</span><br><span class="line">    <span class="comment">//拷贝构造私有化</span></span><br><span class="line">    ChairMan(<span class="keyword">const</span> ChairMan&amp;c);</span><br><span class="line">    <span class="keyword">static</span> ChairMan * singleMan;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> ChairMan *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleMan;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ChairMan();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChairMan::ChairMan(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"创建国家主席"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChairMan::~ChairMan()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChairMan * ChairMan::singleMan = <span class="keyword">new</span> ChairMan;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ChairMan::singleMan;</span></span><br><span class="line">    ChairMan *cm1 = ChairMan::getInstance();</span><br><span class="line">    <span class="comment">//ChairMan *cm2 = new ChairMan(*cm1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Main函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印机案例"><a href="#打印机案例" class="headerlink" title="打印机案例"></a><strong>打印机案例</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    Printer(<span class="comment">/* args */</span>)&#123; m_count =<span class="number">0</span>;&#125;</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer &amp;p)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Printer *singlePrinter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singlePrinter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printText</span><span class="params">(<span class="built_in">string</span> text)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_count++;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;text&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"打印机使用了"</span>&lt;&lt;m_count&lt;&lt;<span class="string">"次"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Printer()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Printer * Printer::singlePrinter = <span class="keyword">new</span> Printer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Printer *printer = Printer::getInstance();</span><br><span class="line"></span><br><span class="line">    printer-&gt;printText(<span class="string">"离职报告"</span>);</span><br><span class="line">    printer-&gt;printText(<span class="string">"入职报告"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-对象模型初探"><a href="#C-对象模型初探" class="headerlink" title="C++对象模型初探"></a><strong>C++对象模型初探</strong></h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a><strong>成员变量和成员函数分开存储</strong></h3><p>空类的大小为 1</p>
<p>只有非静态成员变量才属于对象身上，且计算大小按字节对齐</p>
<p>普通成员函数、静态成员函数和静态成员变量都不属于对象身上</p>
<h3 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a><strong>this指针的使用</strong></h3><p>指针永远指向当前对象</p>
<p>解决命名冲突</p>
<p>*this 指向对象本体</p>
<p>非静态的成员函数才有this指针</p>
<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a><strong>空指针访问成员函数</strong></h3><p>如果成员函数没有用到this，那么空指针可以直接访问</p>
<p>如果成员函数用的this指针，就用注意，可以加if判断，如果this为NULL就return</p>
<h3 id="常函数、常对象"><a href="#常函数、常对象" class="headerlink" title="常函数、常对象"></a><strong>常函数、常对象</strong></h3><p>常函数 void func() const {} 常函数</p>
<p>常函数修饰this指针 const Type *const this</p>
<p>常函数 不能修改this指针执行的值</p>
<p>常对象 在对象前加入const修饰 const Person p1</p>
<p>常对象 不可以调用普通的成员函数</p>
<p>常对象可以调用常函数</p>
<p>用mutable修饰的关键字是在常函数可以修改的</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a><strong>友元</strong></h3><h4 id="全局函数做友元函数"><a href="#全局函数做友元函数" class="headerlink" title="全局函数做友元函数"></a>全局函数做友元函数</h4><p>全局函数写到类中做声明，并且在最前面加上关键字friend</p>
<h4 id="整个类做友元类"><a href="#整个类做友元类" class="headerlink" title="整个类做友元类"></a>整个类做友元类</h4><p>firend class 类名</p>
<p>友元的是单向的、不可传递的</p>
<h4 id="成员函数做友元函数"><a href="#成员函数做友元函数" class="headerlink" title="成员函数做友元函数"></a>成员函数做友元函数</h4><p>friend void 类名::成员函数();</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++基础03]]></title>
      <url>/2019/09/26/C-%E5%9F%BA%E7%A1%8003/</url>
      <content type="html"><![CDATA[<h2 id="面向对象设计案例"><a href="#面向对象设计案例" class="headerlink" title="面向对象设计案例"></a><strong>面向对象设计案例</strong></h2><h3 id="立方体案例"><a href="#立方体案例" class="headerlink" title="立方体案例"></a>立方体案例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设计立方体类(Cube)，</span></span><br><span class="line"><span class="comment">求出立方体的面积(2*a*b+2*a*c+2*b*c)和体积(a*b*c)，</span></span><br><span class="line"><span class="comment">分别用全局函数和全员函数判断两个立方体是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cube</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setL</span><span class="params">(<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_L = l;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_L;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setW</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_W = w;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getW</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_W;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setH</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_H = h;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getH</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_H;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getCubeS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s = (m_L*m_W + m_H*m_L + m_H*m_W)*<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"立方体的面积为: "</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getCubeV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> v = m_H * m_L * m_W;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"立方体的体积为: "</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">compareCubebyClass</span><span class="params">(Cube &amp;cub)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">bool</span> ret = m_H == cub.getH() &amp;&amp; m_L == cub.getL() &amp;&amp; m_W == cub.getW();</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_L;</span><br><span class="line">	<span class="keyword">int</span> m_W;</span><br><span class="line">	<span class="keyword">int</span> m_H;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareCube</span><span class="params">(Cube &amp;cub1, Cube &amp;cub2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cub1.getL() == cub2.getL() &amp;&amp; cub1.getH() == cub2.getH() &amp;&amp; cub1.getW() == cub2.getW())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cube c1, c2;</span><br><span class="line">	<span class="keyword">bool</span> ret, ret2;</span><br><span class="line">	</span><br><span class="line">	c1.setH(<span class="number">10</span>);</span><br><span class="line">	c1.setL(<span class="number">10</span>);</span><br><span class="line">	c1.setW(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	c2.setH(<span class="number">10</span>);</span><br><span class="line">	c2.setL(<span class="number">11</span>);</span><br><span class="line">	c2.setW(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	ret = compareCube(c1, c2);</span><br><span class="line">	<span class="keyword">if</span>(ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"相等"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"不相等"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret2 = c1.compareCubebyClass(c2);</span><br><span class="line">	<span class="keyword">if</span>(ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"成员函数：相等"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"成员函数：不相等"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test01();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点和圆的关系-分文件编写"><a href="#点和圆的关系-分文件编写" class="headerlink" title="点和圆的关系(分文件编写)"></a><strong>点和圆的关系(分文件编写)</strong></h3><h4 id="point-h"><a href="#point-h" class="headerlink" title="point.h"></a>point.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_X;</span><br><span class="line">	<span class="keyword">int</span> m_Y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="point-cpp"><a href="#point-cpp" class="headerlink" title="point.cpp"></a>point.cpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Point::setX(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	m_X = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Point::getX()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Point::setY(<span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">	m_Y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Point::getY()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="circle-h"><a href="#circle-h" class="headerlink" title="circle.h"></a>circle.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">int</span> r)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getR</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setCenter</span><span class="params">(Point p)</span></span>;	</span><br><span class="line">	<span class="function">Point <span class="title">getCenter</span><span class="params">()</span></span>;	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">isInCirclebyClass</span><span class="params">(Point &amp;p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_R;</span><br><span class="line">	Point m_Center;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="circle-cpp"><a href="#circle-cpp" class="headerlink" title="circle.cpp"></a>circle.cpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Circle::setR(<span class="keyword">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	m_R = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Circle::getR()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Circle::setCenter(Point p)</span><br><span class="line">&#123;</span><br><span class="line">	m_Center = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point Circle::getCenter()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> m_Center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Circle::isInCirclebyClass(Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> distance = ( m_Center.getX()-p.getX())*(m_Center.getX()-p.getX())</span><br><span class="line">	               + (m_Center.getY()-p.getY())*(m_Center.getY()-p.getY());</span><br><span class="line">	<span class="keyword">int</span> rDistance = m_R*m_R;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(rDistance == distance )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"成员函数：点在圆上"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(rDistance &gt; distance)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"成员函数：点在圆内"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"成员函数：点在圆外"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设计一个圆形类(Circle)和一个点类(Point)，计算点和圆的关系 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isInCircle</span><span class="params">(Circle &amp;c, Point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> distance = (c.getCenter().getX()-p.getX())*(c.getCenter().getX()-p.getX())</span><br><span class="line">	               + (c.getCenter().getY()-p.getY())*(c.getCenter().getY()-p.getY());</span><br><span class="line">	<span class="keyword">int</span> rDistance = c.getR()*c.getR();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(rDistance == distance )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"点在圆上"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(rDistance &gt; distance)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"点在圆内"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"点在圆外"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point p1;</span><br><span class="line">	p1.setX(<span class="number">11</span>);</span><br><span class="line">	p1.setY(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	Circle c1;</span><br><span class="line">	Point center;</span><br><span class="line">	center.setX(<span class="number">10</span>);</span><br><span class="line">	center.setY(<span class="number">0</span>);</span><br><span class="line">	c1.setCenter(center);</span><br><span class="line">	c1.setR(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	isInCircle(c1, p1);</span><br><span class="line">	c1.isInCirclebyClass(p1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的构造和析构"><a href="#对象的构造和析构" class="headerlink" title="对象的构造和析构"></a><strong>对象的构造和析构</strong></h2><h3 id="初始化和清理"><a href="#初始化和清理" class="headerlink" title="初始化和清理"></a><strong>初始化和清理</strong></h3><p><strong>构造函数</strong>和<strong>析构函数</strong>会被编译器自动调用，完成对象的初始化和对象清理工作。</p>
<p>系统会默认调用构造函数与析构函数，是系统提供的两个空实现的函数</p>
<p>构造函数写法:</p>
<p>​    与类名相同，没有返回值，不写void，可以发生重载(可以有参数)</p>
<p>​    构造函数有编译器自动调用，不是手动调用，而且只会调用一次</p>
<p>析构函数写法:</p>
<p>​    与类名相同，类名前加一个符号 “~” ，也没有返回值，不写void，不能发生重载(没有参数)</p>
<p>​    自动调用，只会调用一次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"析构函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;<span class="comment">//默认调用了构造函数与析构函数，是系统提供的两个空实现的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造的分类和调用"><a href="#构造的分类和调用" class="headerlink" title="构造的分类和调用"></a><strong>构造的分类和调用</strong></h3><h4 id="按照参数进行分类"><a href="#按照参数进行分类" class="headerlink" title="按照参数进行分类"></a>按照参数进行分类</h4><p>​    无参构造函数(默认构造函数)</p>
<p>​    有参构造函数</p>
<h4 id="按照类型进行分类"><a href="#按照类型进行分类" class="headerlink" title="按照类型进行分类"></a>按照类型进行分类</h4><p>​    普通构造函数</p>
<p>​    拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"无参构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Person(<span class="keyword">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"有参构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Person(<span class="keyword">const</span> Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		m_Age = p.m_Age;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"拷贝构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"析构函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p3;<span class="comment">//默认，不加括号</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//有参</span></span><br><span class="line">	</span><br><span class="line">	p1.m_Age = <span class="number">10</span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;<span class="comment">//拷贝</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"p2的年龄为: "</span>&lt;&lt;p2.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示法调用</span></span><br><span class="line">	Person p4 = Person(<span class="number">100</span>)；</span><br><span class="line">	Person p5 = Person(p4)；</span><br><span class="line">	</span><br><span class="line">	Person(<span class="number">100</span>);<span class="comment">//叫匿名对象，匿名对象特定，如果编译器发现对象是匿名的，那么在这行代码结束后就释放这个对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//不能用拷贝构造函数初始化匿名对象</span></span><br><span class="line">	<span class="comment">//如 Person(P5) 编译器会当成 Person p5; 对象的声明</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a><strong>拷贝构造函数的调用时机</strong></h3><ol>
<li>用已经创建好的对象来初始化新的对象</li>
<li>以值传递的方式给函数参数传值</li>
<li>以值的方式返回局部对象 </li>
</ol>
<h3 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a><strong>构造函数的调用规则</strong></h3><ol>
<li>如果提供了有参的构造，那么系统就不会提供默认的构造了，但是会提供拷贝构造</li>
<li>如果提供了拷贝构造函数，系统就不会提供其他的构造函数了</li>
</ol>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a><strong>深拷贝和浅拷贝</strong></h3><ol>
<li>系统默认提供的拷贝构造会进行简单的值拷贝</li>
<li>如果属性 里有指向堆区空间的数据，那么简单的浅拷贝会导致重复释放内存的异常</li>
<li>解决上述问题，需要我们自己提供拷贝构造函数，进行深拷贝</li>
</ol>
<h3 id="初始化列表的基本使用"><a href="#初始化列表的基本使用" class="headerlink" title="初始化列表的基本使用"></a><strong>初始化列表的基本使用</strong></h3><p>在构造函数后面 + :  属性(值、参数), 属性(值、参数), 属性(值、参数) …</p>
<h3 id="类对象作为成员"><a href="#类对象作为成员" class="headerlink" title="类对象作为成员"></a><strong>类对象作为成员</strong></h3><p>当类对象作为类的成员时，构造顺序是先构造类对象的构造，然后构造自己，而析构顺序则与构造函数相反</p>
<h3 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a><strong>explicit关键字</strong></h3><p>防止构造函数中的隐式类型转换</p>
<h3 id="动态对象创建"><a href="#动态对象创建" class="headerlink" title="动态对象创建"></a><strong>动态对象创建</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="comment">/* args */</span>);</span><br><span class="line">    Person(<span class="keyword">int</span> a);</span><br><span class="line">    ~Person();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::Person(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"默认构造调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"有参构造调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person::~Person()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"析构函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;<span class="comment">//栈区开辟</span></span><br><span class="line">    Person *p2 = <span class="keyword">new</span> Person;<span class="comment">//堆区开辟</span></span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line">    <span class="comment">//所有new出来的对象，都会返回该类型的指针</span></span><br><span class="line">    <span class="comment">//malloc返回void * 还要强转</span></span><br><span class="line">    <span class="comment">//malloc 不会调用构造函数，而new会</span></span><br><span class="line">    <span class="comment">//new是运算符 malloc是函数</span></span><br><span class="line">    <span class="comment">//delete用来释放堆区空间，也是运算符，配合new使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// void *p3 = new Person;</span></span><br><span class="line">    <span class="comment">// delete p3;</span></span><br><span class="line">    <span class="comment">//当用void*接受new出来的指针，会出现释放的问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过new开辟数组，一定会调用默认构造函数，所以一定要提供默认构造</span></span><br><span class="line">    Person * pArray = <span class="keyword">new</span> Person[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//在栈上开辟数组，可以指定有参构造</span></span><br><span class="line">    Person pArray2[<span class="number">2</span>] = &#123;Person(<span class="number">1</span>), Person(<span class="number">2</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放数组</span></span><br><span class="line">    <span class="keyword">delete</span> [] pArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++基础02]]></title>
      <url>/2019/09/25/C-%E5%9F%BA%E7%A1%8002/</url>
      <content type="html"><![CDATA[<h3 id="设计类-抽象类"><a href="#设计类-抽象类" class="headerlink" title="设计类 抽象类"></a><strong>设计类 抽象类</strong></h3><ol>
<li><p>class 类名</p>
<p>{</p>
<p>​    public 公共权限</p>
<p>​                设置成员属性</p>
<p>​                设置成员函数</p>
<p>}；</p>
<p>使用类 创建对象 实例化对象</p>
<p>类名 对象名</p>
<p>通过对象 来设置属性 调用成员函数</p>
</li>
<li><p>类和对象的关系？</p>
<p>类是对对象的抽象，对象是对类的实例</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * pi * m_R;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> m_R;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_R = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"c1的周长为："</span>&lt;&lt;c1.calculateZC()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h3><p>用来代替宏函数</p>
<p>#define定义的函数  没有类型，没有作用域概念，而且自加自减操作会出现错误</p>
<p>内联函数注意事项</p>
<p>​    inline void func(); //内联函数声明</p>
<p>​    inline void func(){ } //如果函数声明的时候，没有加inline关键字，那么这个函数依然不算内联函数</p>
<p>类内部的成员函数，会默认加上inline关键字，但以下情况编译器可能考虑不会将函数进行内联编译</p>
<p>​    ①不能存在任何形式的循环语句</p>
<p>​    ②不能存在过多的条件判断语句</p>
<p>​    ③函数体不能过于庞大</p>
<p>​    ④不能对函数进行取址操作</p>
<p>内联仅仅只是给编译器的一个建议，加上关键字，编译器不一定按照内联处理，但不加关键字，编译器也可能给你进行内联处理</p>
<h3 id="函数的默认参数以及占位参数"><a href="#函数的默认参数以及占位参数" class="headerlink" title="函数的默认参数以及占位参数"></a>函数的默认参数以及占位参数</h3><h4 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">20</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"a + b = "</span>&lt;&lt;a + b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数参数注意事项：</p>
<p>如果有一个位置有默认参数，那么从这个位置开始，从左往右都必须有默认参数</p>
<p>传入参数，如果有参数，就用传入的参数，没有参数就用默认参数</p>
<p>如果函数声明里有了默认参数，那么函数实现时候必须没有默认参数，声明和实现中，只能有一个有默认参数，不能同时出现</p>
<h4 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	func(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有了占位参数，函数调用时必须要提供这个参数，但是用不到参数</p>
<p>占位参数，没什么大用途，只有后面重载 ++符号才有一点用处</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h3><p>函数在同一个作用域，函数名称相同</p>
<p>函数的参数的个数不同、类型不同、顺序不同</p>
<p>返回值不能作为函数重载的条件</p>
<p>当函数重载碰到默认参数时，要注意避免二义性问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">10</span>);<span class="comment">//这样就会出现二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用的重载版本</p>
<p>const 可以作为重载条件</p>
<h3 id="extern-C"><a href="#extern-C" class="headerlink" title="extern  C"></a>extern  C</h3><p>用于解决C++文件中调用C语言的代码</p>
<p>C++中，函数是可以发生重载的，编译器会把这个函数名称改变</p>
<p>C++中想调用C语言函数</p>
<p>​    extern “C” void show(); //show()是你想调用的C语言的函数名，按照C语言方式做链接</p>
<p>或者在C语言中做以下处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="C和C-下的封装的区别"><a href="#C和C-下的封装的区别" class="headerlink" title="C和C++下的封装的区别"></a>C和C++下的封装的区别</h3><h4 id="C语言的封装"><a href="#C语言的封装" class="headerlink" title="C语言的封装"></a>C语言的封装</h4><p>属性和行为分开处理了，类型检测不够</p>
<h4 id="C-的封装"><a href="#C-的封装" class="headerlink" title="C++的封装"></a>C++的封装</h4><p>严格类型转换检测，让属性和行为（变量和函数）绑定到一起</p>
<p>属性和行为作为一个整体来表示生活中具体的事物</p>
<p>控制权限: </p>
<p>​    public    公共权限</p>
<p>​    protected    保护权限</p>
<p>​    private    私有权限</p>
<p>struct 和 class 是一个意思， 唯一不同的是默认权限， 前者是public，后者是private</p>
<p>私有权限 就是私有成员（属性、函数），在类的内部可以访问，在类的外部和子类都不可以访问</p>
<p>公共权限 在类的内部和外部都可以访问</p>
<p>保护权限 类的内部可以访问，当前类的子类可以访问，类外部不能访问</p>
<h4 id="建议成员变量设置为私有private"><a href="#建议成员变量设置为私有private" class="headerlink" title="建议成员变量设置为私有private"></a>建议成员变量设置为私有private</h4><p>自己提供公共的对外接口来进行set或者get方法访问</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++基础01]]></title>
      <url>/2019/09/25/C-%E5%9F%BA%E7%A1%8001/</url>
      <content type="html"><![CDATA[<h3 id="打印hello-world"><a href="#打印hello-world" class="headerlink" title="打印hello world"></a><strong>打印hello world</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双冒号作用域运算符"><a href="#双冒号作用域运算符" class="headerlink" title="双冒号作用域运算符"></a><strong>双冒号作用域运算符</strong></h3><p>全局作用域 直接加::</p>
<h3 id="namespace-命名空间"><a href="#namespace-命名空间" class="headerlink" title="namespace 命名空间"></a><strong>namespace 命名空间</strong></h3><ol>
<li>用于解决名称冲突问题</li>
<li>必须在全局作用域下声明</li>
<li>命名空间下可以放入函数、变量、结构体、类</li>
<li>命名空间可以嵌套命名空间</li>
<li>命名空间是开放的，可以随时加入新的成员</li>
<li>匿名命名空间</li>
<li>命名空间可以起别名</li>
</ol>
<h3 id="using使用"><a href="#using使用" class="headerlink" title="using使用"></a><strong>using使用</strong></h3><h4 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h4><p>using 命名空间名::成员；</p>
<p>如果局部范围内还有该成员，会出现二义性问题，要注意避免</p>
<h4 id="using编译指令"><a href="#using编译指令" class="headerlink" title="using编译指令"></a>using编译指令</h4><p>using namespace 命名空间名;</p>
<p>如果局部范围还有该命名空间内的成员相同名字的成员，则使用后者</p>
<p>如果打开多个房间，也有注意二义性问题</p>
<h3 id="C-对C语言的增强"><a href="#C-对C语言的增强" class="headerlink" title="C++对C语言的增强"></a><strong>C++对C语言的增强</strong></h3><ol>
<li><h4 id="全局变量检测增强"><a href="#全局变量检测增强" class="headerlink" title="全局变量检测增强"></a>全局变量检测增强</h4></li>
<li><h4 id="函数检测增强"><a href="#函数检测增强" class="headerlink" title="函数检测增强"></a>函数检测增强</h4><p>参数类型检测增强，返回值检测增强、函数调用参数检测增强</p>
</li>
<li><h4 id="类型转换检测增强"><a href="#类型转换检测增强" class="headerlink" title="类型转换检测增强"></a>类型转换检测增强</h4></li>
<li><h4 id="结构体增强"><a href="#结构体增强" class="headerlink" title="结构体增强"></a>结构体增强</h4><p>可以放入函数，使用时可以不加struct关键字</p>
</li>
<li><h4 id="bool类型增强"><a href="#bool类型增强" class="headerlink" title="bool类型增强"></a>bool类型增强</h4><p>C语言中没有</p>
</li>
<li><h4 id="三目运算符增强"><a href="#三目运算符增强" class="headerlink" title="三目运算符增强"></a>三目运算符增强</h4><p>C中返回的是值，C++中返回的是变量</p>
</li>
<li><h4 id="const关键字增强"><a href="#const关键字增强" class="headerlink" title="const关键字增强"></a>const关键字增强</h4><p>C语言中，const修饰的变量是伪常量，编译器会分配内存</p>
<p>C++中，const会放入符号表中</p>
<p>C语言中的const默认是外部链接，而C++中是内部链接</p>
<p>const分配内存情况</p>
<p>​    ①对变量取地址会分配临时内存</p>
<p>​    ②extern编译器也会给const变量分配内存</p>
<p>​    ③用普通变量初始化const的变量</p>
<p>​    ④自定义数据类型，加const也会分配内存</p>
<p>尽量以const替换#define</p>
<p>​    ①const有类型</p>
<p>​    ②const有作用域</p>
</li>
<li><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ol>
<li><p>引用基本语法</p>
<p>Type &amp;别名 = 原名</p>
<p>int a = 10;</p>
<p>int &amp;b = a;</p>
</li>
<li><p>引用必须初始化，初始化后不可以修改</p>
</li>
<li><p>对数组建立引用</p>
<p>①int arr[10];</p>
<p>​    int (&amp;pArr)[10] = arr;</p>
<p>②typedef int(ARRAYREF)[10];</p>
<p>​    ARRAYREF &amp;pArr2 = arr;</p>
</li>
<li><p>参数的传递方式</p>
<ol>
<li>值传递</li>
<li>地址传递</li>
<li>引用传递</li>
</ol>
</li>
<li><p>引用的注意事项</p>
<ol>
<li>引用必须引用一块合法的内存空间，不能有NULL引用</li>
<li>不要返回一个局部变量的引用</li>
<li>如果函数的返回值是引用，那么这个函数的调用可以作为左值</li>
<li>引用的本质再C++内部实现是一个指针常量</li>
</ol>
</li>
<li><p>引用的使用</p>
<ol>
<li><p>指针的引用</p>
<p>用一级指针引用可以代替二级指针</p>
<p>struct Person</p>
<p>{</p>
<p>};</p>
<p>fun(Person * &amp;a);</p>
</li>
<li><p>常量的引用</p>
<p>const int &amp;ref = 10;</p>
<p>加入const后， 编译器处理方式为： int tmp = 10， const int &amp;ref = 10；</p>
<p>但可以通过指针修改</p>
<p>int *p = (int *)&ref;</p>
<p>*p = 1000;</p>
<p>常量引用使用场景 用来修饰形参为只读</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux网络编程-高并发服务器]]></title>
      <url>/2019/09/22/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<img src="/2019/09/22/Linux网络编程-高并发服务器/server1.png">

<h2 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a><strong>多进程并发服务器</strong></h2><p>使用多进程并发服务器时要考虑以下几点：</p>
<ol>
<li><p>父进程最大文件描述个数(父进程中需要close关闭accept返回的新文件描述符)</p>
</li>
<li><p>系统内创建进程个数(与内存大小相关)</p>
</li>
<li><p>进程创建过多是否降低整体服务性能(进程调度)</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a><strong>server</strong></h3></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 800</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sigchild</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">		;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>;</span></span><br><span class="line">	newact.sa_handler = do_sigchild;</span><br><span class="line">	sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">	newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigaction(SIGCHLD, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line"></span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">			Close(listenfd);</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">				n = Read(connfd, buf, MAXLINE);</span><br><span class="line">				<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">						inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">						ntohs(cliaddr.sin_port));</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">					buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">				Write(connfd, buf, n);</span><br><span class="line">			&#125;</span><br><span class="line">			Close(connfd);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			Close(connfd);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			perr_exit(<span class="string">"fork"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a><strong>client</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">int</span> sockfd, n;</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			Write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a><strong>多线程并发服务器</strong></h2><p>在使用线程模型开发服务器时需考虑以下问题：</p>
<ol>
<li><p>调整进程内最大文件描述符上限</p>
</li>
<li><p>线程如有共享数据，考虑线程同步</p>
</li>
<li><p>服务于客户端线程退出时，退出处理。（退出值，分离态）</p>
</li>
<li><p>系统负载，随着链接客户端增加，导致其它线程不能及时得到CPU</p>
</li>
</ol>
<h3 id="server-1"><a href="#server-1" class="headerlink" title="server"></a><strong>server</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> = (<span class="title">struct</span> <span class="title">s_info</span>*)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="comment">/* 可以在创建线程前设置线程创建属性,设为分离态,哪种效率高内？ */</span></span><br><span class="line">	pthread_detach(pthread_self());</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		n = Read(ts-&gt;connfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">				inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">				ntohs((*ts).cliaddr.sin_port));</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">		Write(ts-&gt;connfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(ts-&gt;connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span></span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">		ts[i].cliaddr = cliaddr;</span><br><span class="line">		ts[i].connfd = connfd;</span><br><span class="line">		<span class="comment">/* 达到线程最大数时，pthread_create出错处理, 增加服务器稳定性 */</span></span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span>*)&amp;ts[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="client-1"><a href="#client-1" class="headerlink" title="client"></a><strong>client</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">int</span> sockfd, n;</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多路I-O转接服务器"><a href="#多路I-O转接服务器" class="headerlink" title="多路I/O转接服务器"></a><strong>多路I/O转接服务器</strong></h2><p>多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。</p>
<p>主要使用的方法有三种</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h3><ol>
<li><p>select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数</p>
</li>
<li><p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">			fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	nfds: 		监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态</span></span><br><span class="line"><span class="comment">	readfds：	监控有读数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">	writefds：	监控写数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">	exceptfds：	监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</span></span><br><span class="line"><span class="comment">	timeout：	定时阻塞监控时间，3种情况</span></span><br><span class="line"><span class="comment">				1.NULL，永远等下去</span></span><br><span class="line"><span class="comment">				2.设置timeval，等待固定时间</span></span><br><span class="line"><span class="comment">				3.设置timeval里时间均为0，检查描述字后立即返回，轮询*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">		<span class="keyword">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">		<span class="keyword">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; 	<span class="comment">//把文件描述符集合里fd清0</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; 	<span class="comment">//测试文件描述符集合里fd是否置1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; 	<span class="comment">//把文件描述符集合里fd位置1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>; 			<span class="comment">//把文件描述符集合里所有位清0</span></span><br></pre></td></tr></table></figure>

<h4 id="server-2"><a href="#server-2" class="headerlink" title="server"></a><strong>server</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, maxi, maxfd, listenfd, connfd, sockfd;</span><br><span class="line">	<span class="keyword">int</span> nready, client[FD_SETSIZE]; 	<span class="comment">/* FD_SETSIZE 默认为 1024 */</span></span><br><span class="line">	<span class="keyword">ssize_t</span> n;</span><br><span class="line">	fd_set rset, allset;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> str[INET_ADDRSTRLEN]; 			<span class="comment">/* #define INET_ADDRSTRLEN 16 */</span></span><br><span class="line">	<span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">Listen(listenfd, <span class="number">20</span>); 		<span class="comment">/* 默认最大128 */</span></span><br><span class="line"></span><br><span class="line">maxfd = listenfd; 			<span class="comment">/* 初始化 */</span></span><br><span class="line">maxi = <span class="number">-1</span>;					<span class="comment">/* client[]的下标 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">	client[i] = <span class="number">-1</span>; 		<span class="comment">/* 用-1初始化client[] */</span></span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;allset);</span><br><span class="line">FD_SET(listenfd, &amp;allset); <span class="comment">/* 构造select监控文件描述符集 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">	rset = allset; 			<span class="comment">/* 每次循环时都从新设置select监控信号集 */</span></span><br><span class="line">	nready = select(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nready &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">"select error"</span>);</span><br><span class="line">	<span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123; <span class="comment">/* new client connection */</span></span><br><span class="line">		cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">				inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">				ntohs(cliaddr.sin_port));</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				client[i] = connfd; <span class="comment">/* 保存accept返回的文件描述符到client[]里 */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 达到select能监控的文件个数上限 1024 */</span></span><br><span class="line">		<span class="keyword">if</span> (i == FD_SETSIZE) &#123;</span><br><span class="line">			<span class="built_in">fputs</span>(<span class="string">"too many clients\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		FD_SET(connfd, &amp;allset); 	<span class="comment">/* 添加一个新的文件描述符到监控信号集里 */</span></span><br><span class="line">		<span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">			maxfd = connfd; 		<span class="comment">/* select第一个参数需要 */</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">			maxi = i; 				<span class="comment">/* 更新client[]最大下标值 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>; 				<span class="comment">/* 如果没有更多的就绪文件描述符继续回到上面select阻塞监听,</span></span><br><span class="line"><span class="comment">										负责处理未处理完的就绪文件描述符 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123; 	<span class="comment">/* 检测哪个clients 有数据就绪 */</span></span><br><span class="line">			<span class="keyword">if</span> ( (sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( (n = Read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">					Close(sockfd);		<span class="comment">/* 当client关闭链接时，服务器端也关闭对应链接 */</span></span><br><span class="line">					FD_CLR(sockfd, &amp;allset); <span class="comment">/* 解除select监控此文件描述符 */</span></span><br><span class="line">					client[i] = <span class="number">-1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> j;</span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">						buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">					Write(sockfd, buf, n);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client-2"><a href="#client-2" class="headerlink" title="client"></a><strong>client</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">int</span> sockfd, n;</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong>poll</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> fd; <span class="comment">/* 文件描述符 */</span></span><br><span class="line">		<span class="keyword">short</span> events; <span class="comment">/* 监控的事件 */</span></span><br><span class="line">		<span class="keyword">short</span> revents; <span class="comment">/* 监控事件中满足条件返回的事件 */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/*POLLIN			普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND</span></span><br><span class="line"><span class="comment">	POLLRDNORM		数据可读</span></span><br><span class="line"><span class="comment">	POLLRDBAND		优先级带数据可读</span></span><br><span class="line"><span class="comment">	POLLPRI 		高优先级可读数据</span></span><br><span class="line"><span class="comment">	POLLOUT		普通或带外数据可写</span></span><br><span class="line"><span class="comment">	POLLWRNORM		数据可写</span></span><br><span class="line"><span class="comment">	POLLWRBAND		优先级带数据可写</span></span><br><span class="line"><span class="comment">	POLLERR 		发生错误</span></span><br><span class="line"><span class="comment">	POLLHUP 		发生挂起</span></span><br><span class="line"><span class="comment">	POLLNVAL 		描述字不是一个打开的文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	nfds 			监控数组中有多少文件描述符需要被监控</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	timeout 		毫秒级等待</span></span><br><span class="line"><span class="comment">		-1：阻塞等，#define INFTIM -1 				Linux中没有定义此宏</span></span><br><span class="line"><span class="comment">		0：立即返回，不阻塞进程</span></span><br><span class="line"><span class="comment">		&gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值*/</span></span><br></pre></td></tr></table></figure>

<p>如果不再监控某个文件描述符时，可以把pollfd中，fd设置为-1，poll不再监控此pollfd，下次返回时，把revents设置为0。</p>
<h4 id="server-3"><a href="#server-3" class="headerlink" title="server"></a><strong>server</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">	<span class="keyword">int</span> nready;</span><br><span class="line">	<span class="keyword">ssize_t</span> n;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="keyword">socklen_t</span> clilen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">	client[<span class="number">0</span>].events = POLLRDNORM; 					<span class="comment">/* listenfd监听普通读事件 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">		client[i].fd = <span class="number">-1</span>; 							<span class="comment">/* 用-1初始化client[]里剩下元素 */</span></span><br><span class="line">	maxi = <span class="number">0</span>; 										<span class="comment">/* client[]数组有效元素中最大元素下标 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>); 			<span class="comment">/* 阻塞 */</span></span><br><span class="line">		<span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123; 		<span class="comment">/* 有客户端链接请求 */</span></span><br><span class="line">			clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">			connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">					inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">					ntohs(cliaddr.sin_port));</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					client[i].fd = connfd; 	<span class="comment">/* 找到client[]中空闲的位置，存放accept返回的connfd */</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == OPEN_MAX)</span><br><span class="line">				perr_exit(<span class="string">"too many clients"</span>);</span><br><span class="line"></span><br><span class="line">			client[i].events = POLLRDNORM; 		<span class="comment">/* 设置刚刚返回的connfd，监控读事件 */</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">				maxi = i; 						<span class="comment">/* 更新client[]中最大元素下标 */</span></span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>; 						<span class="comment">/* 没有更多就绪事件时,继续回到poll阻塞 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) &#123; 			<span class="comment">/* 检测client[] */</span></span><br><span class="line">			<span class="keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (errno == ECONNRESET) &#123; <span class="comment">/* 当收到 RST标志时 */</span></span><br><span class="line">						<span class="comment">/* connection reset by client */</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">"client[%d] aborted connection\n"</span>, i);</span><br><span class="line">						Close(sockfd);</span><br><span class="line">						client[i].fd = <span class="number">-1</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						perr_exit(<span class="string">"read error"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">/* connection closed by client */</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, i);</span><br><span class="line">					Close(sockfd);</span><br><span class="line">					client[i].fd = <span class="number">-1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">						buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">						Writen(sockfd, buf, n);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>; 				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client-3"><a href="#client-3" class="headerlink" title="client"></a><strong>client</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">int</span> sockfd, n;</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><strong>epoll</strong></h3><p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p>
<p>目前epell是linux大规模并发网络程序中的热门首选模型。</p>
<p>epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p>
<p>可以使用cat命令查看一个进程可以打开的socket描述符上限。</p>
<p>​    cat /proc/sys/fs/file-max</p>
<p>如有需要，可以通过修改配置文件的方式修改该上限值。</p>
<p>​    sudo vi /etc/security/limits.conf</p>
<p>​    在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。</p>
<p>​    * soft nofile 65536</p>
<p>​    * hard nofile 100000</p>
<img src="/2019/09/22/Linux网络编程-高并发服务器/server2.png">

<h4 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a><strong>基础API</strong></h4><ol>
<li>创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。</li>
</ol>
<p>​    #include &lt;sys/epoll.h&gt;</p>
<p>​    int epoll_create(int size)        size：监听数目</p>
<ol start="2">
<li><p>控制某个epoll监控的文件描述符上的事件：注册、修改、删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span></span><br><span class="line">		epfd：	为epoll_creat的句柄</span><br><span class="line">		op：		表示动作，用<span class="number">3</span>个宏来表示：</span><br><span class="line">			EPOLL_CTL_ADD (注册新的fd到epfd)，</span><br><span class="line">			EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</span><br><span class="line">			EPOLL_CTL_DEL (从epfd删除一个fd)；</span><br><span class="line">		event：	告诉内核需要监听的事件</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">			<span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">			<span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">			<span class="keyword">void</span> *ptr;</span><br><span class="line">			<span class="keyword">int</span> fd;</span><br><span class="line">			<span class="keyword">uint32_t</span> u32;</span><br><span class="line">			<span class="keyword">uint64_t</span> u64;</span><br><span class="line">		&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line">		EPOLLIN ：	表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span><br><span class="line">		EPOLLOUT：	表示对应的文件描述符可以写</span><br><span class="line">		EPOLLPRI：	表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span><br><span class="line">		EPOLLERR：	表示对应的文件描述符发生错误</span><br><span class="line">		EPOLLHUP：	表示对应的文件描述符被挂断；</span><br><span class="line">		EPOLLET： 	将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</span><br><span class="line">		EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待所监控文件描述符上有事件的产生，类似于select()调用。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span></span><br><span class="line">		events：		用来存内核得到事件的集合，</span><br><span class="line">		maxevents：	告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</span><br><span class="line">		timeout：	是超时时间</span><br><span class="line">			<span class="number">-1</span>：	阻塞</span><br><span class="line">			<span class="number">0</span>：	立即返回，非阻塞</span><br><span class="line">			&gt;<span class="number">0</span>：	指定毫秒</span><br><span class="line">		返回值：	成功返回有多少文件描述符就绪，时间到时返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="server-4"><a href="#server-4" class="headerlink" title="server"></a><strong>server</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">	<span class="keyword">int</span> nready, efd, res;</span><br><span class="line">	<span class="keyword">ssize_t</span> n;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="keyword">socklen_t</span> clilen;</span><br><span class="line">	<span class="keyword">int</span> client[OPEN_MAX];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">		client[i] = <span class="number">-1</span>;</span><br><span class="line">	maxi = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	efd = epoll_create(OPEN_MAX);</span><br><span class="line">	<span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"epoll_create"</span>);</span><br><span class="line"></span><br><span class="line">	tep.events = EPOLLIN; tep.data.fd = listenfd;</span><br><span class="line"></span><br><span class="line">	res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">"epoll_ctl"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		nready = epoll_wait(efd, ep, OPEN_MAX, <span class="number">-1</span>); <span class="comment">/* 阻塞监听 */</span></span><br><span class="line">		<span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">			perr_exit(<span class="string">"epoll_wait"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nready; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(ep[i].events &amp; EPOLLIN))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (ep[i].data.fd == listenfd) &#123;</span><br><span class="line">				clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">				connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, </span><br><span class="line">						inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)), </span><br><span class="line">						ntohs(cliaddr.sin_port));</span><br><span class="line">				<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; OPEN_MAX; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (client[j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						client[j] = connfd; <span class="comment">/* save descriptor */</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (j == OPEN_MAX)</span><br><span class="line">					perr_exit(<span class="string">"too many clients"</span>);</span><br><span class="line">				<span class="keyword">if</span> (j &gt; maxi)</span><br><span class="line">					maxi = j; 		<span class="comment">/* max index in client[] array */</span></span><br><span class="line"></span><br><span class="line">				tep.events = EPOLLIN; </span><br><span class="line">				tep.data.fd = connfd;</span><br><span class="line">				res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);</span><br><span class="line">				<span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">					perr_exit(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sockfd = ep[i].data.fd;</span><br><span class="line">				n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">				<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= maxi; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (client[j] == sockfd) &#123;</span><br><span class="line">							client[j] = <span class="number">-1</span>;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">					<span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">						perr_exit(<span class="string">"epoll_ctl"</span>);</span><br><span class="line"></span><br><span class="line">					Close(sockfd);</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"client[%d] closed connection\n"</span>, j);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">						buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">					Writen(sockfd, buf, n);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	close(efd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client-4"><a href="#client-4" class="headerlink" title="client"></a><strong>client</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">int</span> sockfd, n;</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="epoll进阶"><a href="#epoll进阶" class="headerlink" title="epoll进阶"></a><strong>epoll进阶</strong></h2><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a><strong>事件模型</strong></h3><p>EPOLL事件有两种模型：</p>
<p>Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p>
<p>Level Triggered (LT) 水平触发只要有数据都会触发。</p>
<p>思考如下步骤：</p>
<ol>
<li><p>假定我们已经把一个用来从管道中读取数据的文件描述符(RFD)添加到epoll描述符。</p>
</li>
<li><p>管道的另一端写入了2KB的数据</p>
</li>
<li><p>调用epoll_wait，并且它会返回RFD，说明它已经准备好读取操作</p>
</li>
<li><p>读取1KB的数据</p>
</li>
<li><p>调用epoll_wait……</p>
</li>
</ol>
<p>在这个过程中，有两种工作模式：</p>
<h4 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a><strong>ET模式</strong></h4><p>ET模式即Edge Triggered工作模式。</p>
<p>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。</p>
<p>1) 基于非阻塞文件句柄</p>
<p>2) 只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</p>
<h4 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a><strong>LT模式</strong></h4><p>LT模式即Level Triggered工作模式。</p>
<p>与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。</p>
<p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p>
<p>ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once).</p>
<h3 id="实例一："><a href="#实例一：" class="headerlink" title="实例一："></a><strong>实例一：</strong></h3><p>基于管道epoll ET触发模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> efd, i;</span><br><span class="line">	<span class="keyword">int</span> pfd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE], ch = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">	pipe(pfd);</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		close(pfd[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; i++)</span><br><span class="line">				buf[i] = ch;</span><br><span class="line">			buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">			ch++;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (; i &lt; MAXLINE; i++)</span><br><span class="line">				buf[i] = ch;</span><br><span class="line">			buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">			ch++;</span><br><span class="line"></span><br><span class="line">			write(pfd[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">			sleep(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		close(pfd[<span class="number">1</span>]);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		struct epoll_event event;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span></span><br><span class="line">		<span class="keyword">int</span> res, len;</span><br><span class="line">		close(pfd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">		efd = epoll_create(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">/* event.events = EPOLLIN; */</span></span><br><span class="line">		event.events = EPOLLIN | EPOLLET;		<span class="comment">/* ET 边沿触发 ，默认是水平触发 */</span></span><br><span class="line">		event.data.fd = pfd[<span class="number">0</span>];</span><br><span class="line">	epoll_ctl(efd, EPOLL_CTL_ADD, pfd[<span class="number">0</span>], &amp;event);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"res %d\n"</span>, res);</span><br><span class="line">			<span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == pfd[<span class="number">0</span>]) &#123;</span><br><span class="line">				len = read(pfd[<span class="number">0</span>], buf, MAXLINE/<span class="number">2</span>);</span><br><span class="line">				write(STDOUT_FILENO, buf, len);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(pfd[<span class="number">0</span>]);</span><br><span class="line">		close(efd);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		perror(<span class="string">"fork"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例二："><a href="#实例二：" class="headerlink" title="实例二："></a><strong>实例二：</strong></h3><p>基于网络C/S模型的epoll ET触发模式</p>
<h4 id="server-5"><a href="#server-5" class="headerlink" title="server"></a><strong>server</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="keyword">int</span> i, efd;</span><br><span class="line"></span><br><span class="line">	listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span></span><br><span class="line">	<span class="keyword">int</span> res, len;</span><br><span class="line">	efd = epoll_create(<span class="number">10</span>);</span><br><span class="line">	event.events = EPOLLIN | EPOLLET;		<span class="comment">/* ET 边沿触发 ，默认是水平触发 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">	cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">	connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">			inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">			ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">	event.data.fd = connfd;</span><br><span class="line">	epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"res %d\n"</span>, res);</span><br><span class="line">		<span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == connfd) &#123;</span><br><span class="line">			len = read(connfd, buf, MAXLINE/<span class="number">2</span>);</span><br><span class="line">			write(STDOUT_FILENO, buf, len);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client-5"><a href="#client-5" class="headerlink" title="client"></a><strong>client</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">int</span> sockfd, i;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; i++)</span><br><span class="line">			buf[i] = ch;</span><br><span class="line">		buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">		ch++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (; i &lt; MAXLINE; i++)</span><br><span class="line">			buf[i] = ch;</span><br><span class="line">		buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">		ch++;</span><br><span class="line"></span><br><span class="line">		write(sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例三："><a href="#实例三：" class="headerlink" title="实例三："></a><strong>实例三：</strong></h3><p>基于网络C/S非阻塞模型的epoll ET触发模式</p>
<h4 id="server-6"><a href="#server-6" class="headerlink" title="server"></a><strong>server</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="keyword">int</span> i, efd, flag;</span><br><span class="line"></span><br><span class="line">	listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span></span><br><span class="line">	<span class="keyword">int</span> res, len;</span><br><span class="line">	efd = epoll_create(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">/* event.events = EPOLLIN; */</span></span><br><span class="line">	event.events = EPOLLIN | EPOLLET;		<span class="comment">/* ET 边沿触发 ，默认是水平触发 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line">	cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">	connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,</span><br><span class="line">			inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">			ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">	flag = fcntl(connfd, F_GETFL);</span><br><span class="line">	flag |= O_NONBLOCK;</span><br><span class="line">	fcntl(connfd, F_SETFL, flag);</span><br><span class="line">	event.data.fd = connfd;</span><br><span class="line">	epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"epoll_wait begin\n"</span>);</span><br><span class="line">		res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"epoll_wait end res %d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == connfd) &#123;</span><br><span class="line">			<span class="keyword">while</span> ((len = read(connfd, buf, MAXLINE/<span class="number">2</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">				write(STDOUT_FILENO, buf, len);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client-6"><a href="#client-6" class="headerlink" title="client"></a><strong>client</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">int</span> sockfd, i;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; i++)</span><br><span class="line">			buf[i] = ch;</span><br><span class="line">		buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">		ch++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (; i &lt; MAXLINE; i++)</span><br><span class="line">			buf[i] = ch;</span><br><span class="line">		buf[i<span class="number">-1</span>] = <span class="string">'\n'</span>;</span><br><span class="line">		ch++;</span><br><span class="line"></span><br><span class="line">		write(sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池并发服务器"><a href="#线程池并发服务器" class="headerlink" title="线程池并发服务器"></a><strong>线程池并发服务器</strong></h2><ol>
<li><p>预先创建阻塞于accept多线程，使用互斥锁上锁保护accept</p>
</li>
<li><p>预先创建多线程，由主线程调用accept</p>
</li>
</ol>
<h2 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a><strong>UDP服务器</strong></h2><p>传输层主要应用的协议模型有两种，一种是TCP协议，另外一种则是UDP协议。TCP协议在网络通信中占主导地位，绝大多数的网络通信借助TCP协议完成数据传输。但UDP也是网络通信中不可或缺的重要通信手段。</p>
<p>相较于TCP而言，UDP通信的形式更像是发短信。不需要在数据传输之前建立、维护连接。只专心获取数据就好。省去了三次握手的过程，通信速度可以大大提高，但与之伴随的通信的稳定性和正确率便得不到保证。因此，我们称UDP为“无连接的不可靠报文传递”。</p>
<p>那么与我们熟知的TCP相比，UDP有哪些优点和不足呢？由于无需创建连接，所以UDP开销较小，数据传输速度快，实时性较强。多用于对实时性要求较高的通信场合，如视频会议、电话会议等。但随之也伴随着数据传输不可靠，传输数据的正确率、传输顺序和流量都得不到控制和保证。所以，通常情况下，使用UDP协议进行数据传输，为保证数据的正确性，我们需要在应用层添加辅助校验协议来弥补UDP的不足，以达到数据可靠传输的目的。</p>
<p>与TCP类似的，UDP也有可能出现缓冲区被填满后，再接收数据时丢包的现象。由于它没有TCP滑动窗口的机制，通常采用如下两种方法解决：</p>
<p>1) 服务器应用层设计流量控制，控制发送数据速度。</p>
<p>2) 借助setsockopt函数改变接收缓冲区大小。如：</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</p>
<p>​    int n = 220x1024</p>
<p>​    setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;n, sizeof(n));</p>
<h4 id="C-S模型-UDP"><a href="#C-S模型-UDP" class="headerlink" title="C/S模型-UDP"></a><strong>C/S模型-UDP</strong></h4><img src="/2019/09/22/Linux网络编程-高并发服务器/server3.png">

<p>由于UDP不需要维护连接，程序逻辑简单了很多，但是UDP协议是不可靠的，保证通讯可靠性的机制需要在应用层实现。</p>
<p>编译运行server，在两个终端里各开一个client与server交互，看看server是否具有并发服务的能力。用Ctrl+C关闭server，然后再运行server，看此时client还能否和server联系上。和前面TCP程序的运行结果相比较，体会无连接的含义。</p>
<h4 id="server-7"><a href="#server-7" class="headerlink" title="server"></a><strong>server</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	bind(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		n = recvfrom(sockfd, buf, MAXLINE,<span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">			perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>, </span><br><span class="line">				inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">				ntohs(cliaddr.sin_port));</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">		n = sendto(sockfd, buf, n, <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">			perror(<span class="string">"sendto error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">client</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> sockfd, n;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		n = sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">			perror(<span class="string">"sendto error"</span>);</span><br><span class="line">		n = recvfrom(sockfd, buf, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">			perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">		write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多播-组播"><a href="#多播-组播" class="headerlink" title="多播(组播)"></a><strong>多播(组播)</strong></h4><p>组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p>
<p>224.0.0.0～224.0.0.255        为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</p>
<p>224.0.1.0～224.0.1.255        是公用组播地址，可以用于Internet；欲使用需申请。</p>
<p>224.0.2.0～238.255.255.255    为用户可用的组播地址（临时组地址），全网范围内有效；</p>
<p>239.0.0.0～239.255.255.255    为本地管理组播地址，仅在特定的本地范围内有效。</p>
<p>可使用ip ad命令查看网卡编号，如：</p>
<p>itcast$ ip ad</p>
<p>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default </p>
<p>​    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</p>
<p>​    inet 127.0.0.1/8 scope host lo</p>
<p>​       valid_lft forever preferred_lft forever</p>
<p>​    inet6 ::1/128 scope host </p>
<p>​       valid_lft forever preferred_lft forever</p>
<p>2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000</p>
<p>​    link/ether 00:0c:29:0a:c4:f4 brd ff:ff:ff:ff:ff:ff</p>
<p>​    inet6 fe80::20c:29ff:fe0a:c4f4/64 scope link </p>
<p>​       valid_lft forever preferred_lft forever</p>
<p>if_nametoindex 命令可以根据网卡名，获取网卡序号。</p>
<h4 id="server-8"><a href="#server-8" class="headerlink" title="server"></a><strong>server</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd, i ;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>, <span class="title">clientaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE] = <span class="string">"itcast\n"</span>;</span><br><span class="line">	<span class="keyword">char</span> ipstr[INET_ADDRSTRLEN]; <span class="comment">/* 16 Bytes */</span></span><br><span class="line">	<span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">	<span class="keyword">ssize_t</span> len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 构造用于UDP通信的套接字 */</span></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">	serveraddr.sin_family = AF_INET; <span class="comment">/* IPv4 */</span></span><br><span class="line">	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">/* 本地任意IP INADDR_ANY = 0 */</span></span><br><span class="line">	serveraddr.sin_port = htons(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">	bind(sockfd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*设置组地址*/</span></span><br><span class="line">	inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);</span><br><span class="line">	<span class="comment">/*本地任意IP*/</span></span><br><span class="line">	inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);</span><br><span class="line">	<span class="comment">/* eth0 --&gt; 编号 命令：ip ad */</span></span><br><span class="line">	group.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);</span><br><span class="line">	setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &amp;group, <span class="keyword">sizeof</span>(group));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*构造 client 地址 IP+端口 */</span></span><br><span class="line">	bzero(&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));</span><br><span class="line">	clientaddr.sin_family = AF_INET; <span class="comment">/* IPv4 */</span></span><br><span class="line">	inet_pton(AF_INET, GROUP, &amp;clientaddr.sin_addr.s_addr);</span><br><span class="line">	clientaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//fgets(buf, sizeof(buf), stdin);</span></span><br><span class="line">		sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;clientaddr, <span class="keyword">sizeof</span>(clientaddr));</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client-7"><a href="#client-7" class="headerlink" title="client"></a><strong>client</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 6666</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_PORT 9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GROUP <span class="meta-string">"239.0.0.2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>, <span class="title">localaddr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> confd;</span><br><span class="line">	<span class="keyword">ssize_t</span> len;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 定义组播结构体 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span> <span class="title">group</span>;</span></span><br><span class="line">	confd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化本地端地址</span></span><br><span class="line">	bzero(&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line">	localaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">"0.0.0.0"</span> , &amp;localaddr.sin_addr.s_addr);</span><br><span class="line">	localaddr.sin_port = htons(CLIENT_PORT);</span><br><span class="line"></span><br><span class="line">	bind(confd, (struct sockaddr *)&amp;localaddr, <span class="keyword">sizeof</span>(localaddr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*设置组地址*/</span></span><br><span class="line">	inet_pton(AF_INET, GROUP, &amp;group.imr_multiaddr);</span><br><span class="line">	<span class="comment">/*本地任意IP*/</span></span><br><span class="line">	inet_pton(AF_INET, <span class="string">"0.0.0.0"</span>, &amp;group.imr_address);</span><br><span class="line">	<span class="comment">/* eth0 --&gt; 编号 命令：ip ad */</span></span><br><span class="line">	group.imr_ifindex = if_nametoindex(<span class="string">"eth0"</span>);</span><br><span class="line">	<span class="comment">/*设置client 加入多播组 */</span></span><br><span class="line">	setsockopt(confd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;group, <span class="keyword">sizeof</span>(group));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		len = recvfrom(confd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		write(STDOUT_FILENO, buf, len);</span><br><span class="line">	&#125;</span><br><span class="line">	close(confd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="socket-IPC（本地套接字domain）"><a href="#socket-IPC（本地套接字domain）" class="headerlink" title="socket IPC（本地套接字domain）"></a><strong>socket IPC（本地套接字domain）</strong></h2><p>socket API原本是为网络通讯设计的，但后来在socket的框架上发展出一种IPC机制，就是UNIX Domain Socket。虽然网络socket也可用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket也提供面向流和面向数据包两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。</p>
<p>UNIX Domain Socket是全双工的，API接口语义丰富，相比其它IPC机制有明显的优越性，目前已成为使用最广泛的IPC机制，比如X Window服务器和GUI程序之间就是通过UNIXDomain Socket通讯的。</p>
<p>使用UNIX Domain Socket的过程和网络socket十分相似，也要先调用socket()创建一个socket文件描述符，address family指定为AF_UNIX，type可以选择SOCK_DGRAM或SOCK_STREAM，protocol参数仍然指定为0即可。</p>
<p>UNIX Domain Socket与网络socket编程最明显的不同在于地址格式不同，用结构体sockaddr_un表示，网络编程的socket地址是IP地址加端口号，而UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存在，则bind()错误返回。</p>
<p>对比网络套接字地址结构和本地套接字地址结构：</p>
<p>struct sockaddr_in {</p>
<p>__kernel_sa_family_t <strong>sin_family</strong>;             /* Address family */      地址结构类型</p>
<p>__be16 <strong>sin_port</strong>;                         /* Port number */        端口号</p>
<p>struct in_addr <strong>sin_addr</strong>;                    /* Internet address */    IP地址</p>
<p>};</p>
<p>struct sockaddr_un {</p>
<p>__kernel_sa_family_t <strong>sun_family</strong>;         /* AF_UNIX */            地址结构类型</p>
<p>char <strong>sun_path</strong>[UNIX_PATH_MAX];         /* pathname */        socket文件名(含路径)</p>
<p>};</p>
<p>以下程序将UNIX Domain socket绑定到一个地址。</p>
<p>​    size = offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path);</p>
<p>​    #define offsetof(type, member) ((int)&amp;((type *)0)-&gt;MEMBER)</p>
<h3 id="server-9"><a href="#server-9" class="headerlink" title="server"></a><strong>server</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QLEN 10</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Create a server endpoint of a connection.</span></span><br><span class="line"><span class="comment">* Returns fd if all OK, &lt;0 on error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_listen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, len, err, rval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">un</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a UNIX domain stream socket */</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">/* in case it already exists */</span></span><br><span class="line">	unlink(name); 			</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill in socket address structure */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;un, <span class="number">0</span>, <span class="keyword">sizeof</span>(un));</span><br><span class="line">	un.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">strcpy</span>(un.sun_path, name);</span><br><span class="line">	len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bind the name to the descriptor */</span></span><br><span class="line">	<span class="keyword">if</span> (bind(fd, (struct sockaddr *)&amp;un, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (listen(fd, QLEN) &lt; <span class="number">0</span>) &#123; <span class="comment">/* tell kernel we're a server */</span></span><br><span class="line">		rval = <span class="number">-3</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(fd);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(rval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_accept</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">uid_t</span> *uidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> clifd, len, err, rval;</span><br><span class="line">	<span class="keyword">time_t</span> staletime;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">un</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">sizeof</span>(un);</span><br><span class="line">	<span class="keyword">if</span> ((clifd = accept(listenfd, (struct sockaddr *)&amp;un, &amp;len)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>); <span class="comment">/* often errno=EINTR, if signal caught */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* obtain the client's uid from its calling address */</span></span><br><span class="line">	len -= offsetof(struct sockaddr_un, sun_path); <span class="comment">/* len of pathname */</span></span><br><span class="line">	un.sun_path[len] = <span class="number">0</span>; <span class="comment">/* null terminate */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stat(un.sun_path, &amp;statbuf) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (S_ISSOCK(statbuf.st_mode) == <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-3</span>; <span class="comment">/* not a socket */</span></span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (uidptr != <span class="literal">NULL</span>)</span><br><span class="line">		*uidptr = statbuf.st_uid; <span class="comment">/* return uid of caller */</span></span><br><span class="line">	<span class="comment">/* we're done with pathname now */</span></span><br><span class="line">	unlink(un.sun_path); </span><br><span class="line">	<span class="keyword">return</span>(clifd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(clifd);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(rval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lfd, cfd, n, i;</span><br><span class="line">	<span class="keyword">uid_t</span> cuid;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	lfd = serv_listen(<span class="string">"foo.socket"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (lfd) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-3</span>:perror(<span class="string">"listen"</span>); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-2</span>:perror(<span class="string">"bind"</span>); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-1</span>:perror(<span class="string">"socket"</span>); <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cfd = serv_accept(lfd, &amp;cuid);</span><br><span class="line">	<span class="keyword">if</span> (cfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (cfd) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-3</span>:perror(<span class="string">"not a socket"</span>); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-2</span>:perror(<span class="string">"a bad filename"</span>); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-1</span>:perror(<span class="string">"accept"</span>); <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">r_again:</span><br><span class="line">		n = read(cfd, buf, <span class="number">1024</span>);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">		<span class="keyword">goto</span> r_again;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the other side has been closed.\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">		write(cfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	close(cfd);</span><br><span class="line">	close(lfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="client-8"><a href="#client-8" class="headerlink" title="client"></a><strong>client</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLI_PATH <span class="meta-string">"/var/tmp/"</span> <span class="comment">/* +5 for pid = 14 chars */</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Create a client endpoint and connect to a server.</span></span><br><span class="line"><span class="comment">* Returns fd if all OK, &lt;0 on error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cli_conn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, len, err, rval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">un</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a UNIX domain stream socket */</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill socket address structure with our address */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;un, <span class="number">0</span>, <span class="keyword">sizeof</span>(un));</span><br><span class="line">	un.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">sprintf</span>(un.sun_path, <span class="string">"%s%05d"</span>, CLI_PATH, getpid());</span><br><span class="line">	len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(un.sun_path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* in case it already exists */</span></span><br><span class="line">	unlink(un.sun_path); </span><br><span class="line">	<span class="keyword">if</span> (bind(fd, (struct sockaddr *)&amp;un, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill socket address structure with server's address */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;un, <span class="number">0</span>, <span class="keyword">sizeof</span>(un));</span><br><span class="line">	un.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">strcpy</span>(un.sun_path, name);</span><br><span class="line">	len = offsetof(struct sockaddr_un, sun_path) + <span class="built_in">strlen</span>(name);</span><br><span class="line">	<span class="keyword">if</span> (connect(fd, (struct sockaddr *)&amp;un, len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		rval = <span class="number">-4</span>;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span>(fd);</span><br><span class="line">	errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(fd);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(rval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, n;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	fd = cli_conn(<span class="string">"foo.socket"</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (fd) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-4</span>:perror(<span class="string">"connect"</span>); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-3</span>:perror(<span class="string">"listen"</span>); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-2</span>:perror(<span class="string">"bind"</span>); <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-1</span>:perror(<span class="string">"socket"</span>); <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其它常用函数"><a href="#其它常用函数" class="headerlink" title="其它常用函数"></a><strong>其它常用函数</strong></h2><h4 id="名字与地址转换"><a href="#名字与地址转换" class="headerlink" title="名字与地址转换"></a><strong>名字与地址转换</strong></h4><p>gethostbyname根据给定的主机名，获取主机信息。</p>
<p>过时，仅用于IPv4，且线程不安全。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> h_errno;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">128</span>];</span><br><span class="line">	host = gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, host-&gt;h_name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*(host-&gt;h_aliases) != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *host-&gt;h_aliases++);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (host-&gt;h_addrtype) &#123;</span><br><span class="line">		<span class="keyword">case</span> AF_INET:</span><br><span class="line">			<span class="keyword">while</span> (*(host-&gt;h_addr_list) != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, inet_ntop(AF_INET, (*host-&gt;h_addr_list++), str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"unknown address type\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gethostbyaddr函数。</p>
<p>此函数只能获取域名解析服务器的url和/etc/hosts里登记的IP对应的域名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> h_errno;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">128</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;addr);</span><br><span class="line">	host = gethostbyaddr((<span class="keyword">char</span> *)&amp;addr, <span class="number">4</span>, AF_INET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, host-&gt;h_name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*(host-&gt;h_aliases) != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *host-&gt;h_aliases++);</span><br><span class="line">	<span class="keyword">switch</span> (host-&gt;h_addrtype) &#123;</span><br><span class="line">		<span class="keyword">case</span> AF_INET:</span><br><span class="line">			<span class="keyword">while</span> (*(host-&gt;h_addr_list) != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, inet_ntop(AF_INET, (*host-&gt;h_addr_list++), str, <span class="keyword">sizeof</span>(str)));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"unknown address type\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getservbyname</p>
<p>getservbyport</p>
<p>根据服务程序名字或端口号获取信息。使用频率不高。</p>
<p>getaddrinfo</p>
<p>getnameinfo</p>
<p>freeaddrinfo</p>
<p>可同时处理IPv4和IPv6，线程安全的。</p>
<h4 id="套接口和地址关联"><a href="#套接口和地址关联" class="headerlink" title="套接口和地址关联"></a><strong>套接口和地址关联</strong></h4><p>getsockname</p>
<p>根据accpet返回的sockfd，得到临时端口号</p>
<p>getpeername</p>
<p>根据accpet返回的sockfd，得到远端链接的端口号，在exec后可以获取客户端信息。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux网络编程-Socket编程]]></title>
      <url>/2019/09/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Socket%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a><strong>套接字概念</strong></h2><p>Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。</p>
<p>既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p>
<p>套接字的内核实现较为复杂，不宜在学习初期深入学习。</p>
<p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p>
<p>套接字通信原理如下图所示：</p>
<img src="/2019/09/17/Linux网络编程-Socket编程/socket1.png">  

<p>套接字通讯原理示意</p>
<p><strong>在网络通信中，套接字一定是成对出现的。</strong>一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p>
<p>TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。本章的主要内容是socket API，主要介绍TCP协议的函数接口，最后介绍UDP协议和UNIX Domain Socket的函数接口。</p>
<img src="/2019/09/17/Linux网络编程-Socket编程/socket2.png">  

<p>网络编程接口</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a><strong>预备知识</strong></h2><h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a><strong>网络字节序</strong></h3><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。</p>
<p>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。</p>
<p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做<strong>网络字节序和主机字节序的转换</strong>。</p>
<p>#include &lt;arpa/inet.h&gt;</p>
<p>uint32_t htonl(uint32_t hostlong);</p>
<p>uint16_t htons(uint16_t hostshort);</p>
<p>uint32_t ntohl(uint32_t netlong);</p>
<p>uint16_t ntohs(uint16_t netshort);</p>
<p>h表示host，n表示network，l表示32位长整数，s表示16位短整数。</p>
<p>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p>
<h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a><strong>IP地址转换函数</strong></h3><p>早期：</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>#include &lt;netinet/in.h&gt;</p>
<p>#include &lt;arpa/inet.h&gt;</p>
<p>int inet_aton(const char *cp, struct in_addr *inp);</p>
<p>in_addr_t inet_addr(const char *cp);</p>
<p>char *inet_ntoa(struct in_addr in);</p>
<p>只能处理IPv4的ip地址</p>
<p>不可重入函数</p>
<p>注意参数是struct in_addr</p>
<p>现在：</p>
<p>​    #include &lt;arpa/inet.h&gt;</p>
<p>​    int inet_pton(int af, const char *src, void *dst);</p>
<p>​    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</p>
<p>支持IPv4和IPv6</p>
<p>可重入函数</p>
<p>其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr。</p>
<p>因此函数接口是void *addrptr。</p>
<h3 id="sockaddr数据结构"><a href="#sockaddr数据结构" class="headerlink" title="sockaddr数据结构"></a><strong>sockaddr数据结构</strong></h3><p>strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p>
<img src="/2019/09/17/Linux网络编程-Socket编程/socket3.png">  

<p>sockaddr数据结构</p>
<p>struct sockaddr {</p>
<p>​    sa_family_t sa_family;         /* address family, AF_xxx */</p>
<p>​    char sa_data[14];            /* 14 bytes of protocol address */</p>
<p>};</p>
<p>使用 sudo grep -r “struct sockaddr_in {“  /usr 命令可查看到struct sockaddr_in结构体的定义。一般其默认的存储位置：/usr/include/linux/in.h 文件中。</p>
<p>struct sockaddr_in {</p>
<p>​    __kernel_sa_family_t sin_family;             /* Address family */      地址结构类型</p>
<p>​    __be16 sin_port;                             /* Port number */        端口号</p>
<p>​    struct in_addr sin_addr;                    /* Internet address */    IP地址</p>
<p>​    /* Pad to size of `struct sockaddr’. */</p>
<p>​    unsigned char <strong>pad[</strong>SOCK_SIZE__ - sizeof(short int) -</p>
<p>​    sizeof(unsigned short int) - sizeof(struct in_addr)];</p>
<p>};</p>
<p>struct in_addr {                        /* Internet address. */</p>
<p>​    __be32 s_addr;</p>
<p>};</p>
<p>struct sockaddr_in6 {</p>
<p>​    unsigned short int sin6_family;         /* AF_INET6 */</p>
<p>​    __be16 sin6_port;                     /* Transport layer port # */</p>
<p>​    __be32 sin6_flowinfo;                 /* IPv6 flow information */</p>
<p>​    struct in6_addr sin6_addr;            /* IPv6 address */</p>
<p>​    __u32 sin6_scope_id;                 /* scope id (new in RFC2553) */</p>
<p>};</p>
<p>struct in6_addr {</p>
<p>​    union {</p>
<p>​        __u8 u6_addr8[16];</p>
<p>​        __be16 u6_addr16[8];</p>
<p>​        __be32 u6_addr32[4];</p>
<p>​    } in6_u;</p>
<p>​    #define s6_addr         in6_u.u6_addr8</p>
<p>​    #define s6_addr16     in6_u.u6_addr16</p>
<p>​    #define s6_addr32         in6_u.u6_addr32</p>
<p>};</p>
<p>#define UNIX_PATH_MAX 108</p>
<p>​    struct sockaddr_un {</p>
<p>​    __kernel_sa_family_t sun_family;     /* AF_UNIX */</p>
<p>​    char sun_path[UNIX_PATH_MAX];     /* pathname */</p>
<p>};</p>
<p>Pv4和IPv6的地址格式定义在netinet/in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，IPv6地址用sockaddr_in6结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在sys/un.h中，用sock-addr_un结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数AF_INET、AF_INET6、AF_UNIX。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void *类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void *类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如：</p>
<p>struct sockaddr_in servaddr;</p>
<p>bind(listen_fd, (struct sockaddr <em>)&amp;servaddr, sizeof(servaddr));        /</em> initialize servaddr */</p>
<h2 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a><strong>网络套接字函数</strong></h2><h3 id="socket模型创建流程图"><a href="#socket模型创建流程图" class="headerlink" title="socket模型创建流程图"></a><strong>socket模型创建流程图</strong></h3><img src="/2019/09/17/Linux网络编程-Socket编程/socket4.png">  

<p>socket API</p>
<h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a><strong>socket函数</strong></h3><p>#include &lt;sys/types.h&gt; /* See NOTES */</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>int socket(int domain, int type, int protocol);</p>
<p>domain:</p>
<p>​    AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</p>
<p>​    AF_INET6 与上面类似，不过是来用IPv6的地址</p>
<p>​    AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</p>
<p>type:</p>
<p>​    SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</p>
<p>​    SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</p>
<p>​    SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</p>
<p>​    SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</p>
<p>​    SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</p>
<p>protocol:</p>
<p>​    传0 表示使用默认协议。</p>
<p>返回值：</p>
<p>​    成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</p>
<p>socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</p>
<h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a><strong>bind函数</strong></h3><p>#include &lt;sys/types.h&gt; /* See NOTES */</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>sockfd：</p>
<p>​    socket文件描述符</p>
<p>addr:</p>
<p>​    构造出IP地址加端口号</p>
<p>addrlen:</p>
<p>​    sizeof(addr)长度</p>
<p>返回值：</p>
<p>​    成功返回0，失败返回-1, 设置errno</p>
<p>​    服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。</p>
<p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如：</p>
<p>struct sockaddr_in servaddr;</p>
<p>bzero(&amp;servaddr, sizeof(servaddr));</p>
<p>servaddr.sin_family = AF_INET;</p>
<p>servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</p>
<p>servaddr.sin_port = htons(6666);</p>
<p>首先将整个结构体清零，然后设置地址类型为AF_INET，<strong>网络地址为INADDR_ANY，这个宏表示本地的任意IP地址</strong>，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。</p>
<h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a><strong>listen函数</strong></h3><p>#include &lt;sys/types.h&gt; /* See NOTES */</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>int listen(int sockfd, int backlog);</p>
<p>sockfd:</p>
<p>​    socket文件描述符</p>
<p>backlog:</p>
<p>​    排队建立3次握手队列和刚刚建立3次握手队列的链接数和</p>
<p>查看系统默认backlog</p>
<p>cat /proc/sys/net/ipv4/tcp_max_syn_backlog</p>
<p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p>
<h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a><strong>accept函数</strong></h3><p>#include &lt;sys/types.h&gt;         /* See NOTES */</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p>
<p>sockdf:</p>
<p>​    socket文件描述符</p>
<p>addr:</p>
<p>​    传出参数，返回链接客户端地址信息，含IP地址和端口号</p>
<p>addrlen:</p>
<p>​    传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</p>
<p>返回值：</p>
<p>​    成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</p>
<p>三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。</p>
<p>我们的服务器程序结构是这样的：</p>
<p>while (1) {</p>
<p>​    cliaddr_len = sizeof(cliaddr);</p>
<p>​    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</p>
<p>​    n = read(connfd, buf, MAXLINE);</p>
<p>​    ……</p>
<p>​    close(connfd);</p>
<p>}</p>
<p>整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。</p>
<h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a><strong>connect函数</strong></h3><p>#include &lt;sys/types.h&gt;                     /* See NOTES */</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>sockdf:</p>
<p>​    socket文件描述符</p>
<p>addr:</p>
<p>​    传入参数，指定服务器端地址信息，含IP地址和端口号</p>
<p>addrlen:</p>
<p>​    传入参数,传入sizeof(addr)大小</p>
<p>返回值：</p>
<p>​    成功返回0，失败返回-1，设置errno</p>
<p>客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。</p>
<h2 id="C-S模型-TCP"><a href="#C-S模型-TCP" class="headerlink" title="C/S模型-TCP"></a><strong>C/S模型-TCP</strong></h2><p>下图是基于TCP协议的客户端/服务器程序的一般流程：</p>
<img src="/2019/09/17/Linux网络编程-Socket编程/socket5.png">  

<p>TCP协议通讯流程</p>
<p>服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。</p>
<p>数据传输的过程：</p>
<p>建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端/服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。</p>
<p>如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。</p>
<p>在学习socket API时要注意应用程序和TCP协议层是如何交互的： 应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段 应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a><strong>server</strong></h3><p>下面通过最简单的客户端/服务器程序的实例来学习socket API。</p>
<p>server.c的作用是从客户端读字符，然后将每个字符转换为大写并回送给客户端。</p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a><strong>client</strong></h3><p>client.c的作用是从命令行参数中获得一个字符串发给服务器，然后接收服务器返回的字符串并打印。</p>
<p>由于客户端不需要固定的端口号，因此不必调用bind()，客户端的端口号由内核自动分配。注意，客户端不是不允许调用bind()，只是没有必要调用bind()固定一个端口号，服务器也不是必须调用bind()，但如果服务器不调用bind()，内核会自动给服务器分配监听端口，每次启动服务器时端口号都不一样，客户端要连接服务器就会遇到麻烦。</p>
<p>客户端和服务器启动后可以使用netstat命令查看链接情况：</p>
<p>netstat -apn|grep 6666</p>
<h2 id="出错处理封装函数"><a href="#出错处理封装函数" class="headerlink" title="出错处理封装函数"></a><strong>出错处理封装函数</strong></h2><p>上面的例子不仅功能简单，而且简单到几乎没有什么错误处理，我们知道，系统调用不能保证每次都成功，必须进行出错处理，这样一方面可以保证程序逻辑正常，另一方面可以迅速得到故障信息。</p>
<p>为使错误处理的代码不影响主程序的可读性，我们把与socket相关的一些系统函数加上错误处理代码包装成新的函数，做成一个模块wrap.c：</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux网络编程-网络基础]]></title>
      <url>/2019/09/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h2 id="协议的概念"><a href="#协议的概念" class="headerlink" title="协议的概念"></a><strong>协议的概念</strong></h2><h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a><strong>什么是协议</strong></h3><p>从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。</p>
<p>假设，A、B双方欲传输文件。规定：</p>
<p>第一次，传输文件名，接收方接收到文件名，应答OK给传输方；</p>
<p>第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK；</p>
<p>第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。</p>
<p>由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。</p>
<p>这种仅在A、B之间被遵守的协议称之为<strong>原始协议</strong>。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个<strong>标准协议</strong>。最早的ftp协议就是由此衍生而来。</p>
<p>TCP协议注重数据的传输。http协议着重于数据的解释。</p>
<h3 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a><strong>典型协议</strong></h3><p>传输层 常见协议有TCP/UDP协议。</p>
<p>应用层 常见的协议有HTTP协议，FTP协议。</p>
<p>网络层 常见协议有IP协议、ICMP协议、IGMP协议。</p>
<p>网络接口层 常见协议有ARP协议、RARP协议。</p>
<p>TCP传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<p>HTTP超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。</p>
<p>FTP文件传输协议（File Transfer Protocol）</p>
<p>IP协议是因特网互联协议（Internet Protocol）</p>
<p>ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p>
<p>IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</p>
<p>ARP协议是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。</p>
<p>RARP是反向地址转换协议，通过MAC地址确定IP地址。</p>
<h2 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a><strong>网络应用程序设计模式</strong></h2><h3 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a><strong>C/S模式</strong></h3><p>​    传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p>
<h3 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a><strong>B/S模式</strong></h3><p>浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><p>​    对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而<strong>提高数据传输效率</strong>。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间<strong>所采用的协议相对灵活</strong>。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。</p>
<p>​    因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏魔兽世界。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。</p>
<p>​    C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。<strong>工作量</strong>将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的<strong>安全性构成威胁</strong>。这也是很多用户不愿使用C/S模式应用程序的重要原因。</p>
<p>​    B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作<strong>开发量较小</strong>。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，<strong>不受平台限制</strong>。如早期的偷菜游戏，在各个平台上都可以完美运行。</p>
<p>​    B/S模式的缺点也较明显。由于使用第三方浏览器，因此<strong>网络应用支持受限</strong>。另外，没有客户端放到对方主机上，<strong>缓存数据不尽如人意</strong>，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，<strong>协议选择不灵活</strong>。</p>
<p>​    因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。</p>
<h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a><strong>分层模型</strong></h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a><strong>OSI七层模型</strong></h3><img src="/2019/09/16/Linux网络编程-网络基础/net1.png"> 

<p>OSI模型</p>
<p><strong>1.</strong> <strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p>
<p><strong>2.</strong> <strong>数据链路层</strong>：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</p>
<p><strong>3.</strong> <strong>网络层</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
<p><strong>4.</strong> <strong>传输层</strong>：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</p>
<p><strong>5.</strong> <strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</p>
<p><strong>6.</strong> <strong>表示层</strong>：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</p>
<p><strong>7.</strong> <strong>应用层</strong>：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</p>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a><strong>TCP/IP四层模型</strong></h3><p>TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示：</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net2.png"> 

<p>TCP/IP模型</p>
<p>一般在应用开发过程中，讨论最多的是TCP/IP模型。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a><strong>通信过程</strong></h2><p>两台计算机通过TCP/IP协议通讯的过程如下所示：</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net3.png"> 

<p>TCP/IP通信过程</p>
<p>上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net4.png"> 

<p>跨路由通信</p>
<p>链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。</p>
<p>网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。</p>
<p>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。</p>
<p>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</p>
<p>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</p>
<p>目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net5.png"> 

<p>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</p>
<p>虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</p>
<h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a><strong>协议格式</strong></h2><h3 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a><strong>数据包封装</strong></h3><p>传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net6.png"> 

<p>TCP/TP数据包封装</p>
<p>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</p>
<h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a><strong>以太网帧格式</strong></h3><p>以太网的帧格式如下所示：</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net7.png"> 

<p>以太网帧格式</p>
<p>其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。</p>
<p>以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。<strong>最大值1500称为以太网的最大传输单元（MTU）</strong>，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。</p>
<h3 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a><strong>ARP数据报格式</strong></h3><p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</p>
<p>每台主机都维护一个ARP缓存表，可以用arp -a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。想一想，为什么表项要有过期时间而不是一直有效？</p>
<p>ARP数据报的格式如下所示：</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net8.png"> 

<p>ARP数据报格式</p>
<p>源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。</p>
<p>看一个具体的例子。</p>
<p>请求帧如下（为了清晰在每行的前面加了字节计数，每行16个字节）：</p>
<p>以太网首部（14字节）</p>
<p>0000: ff ff ff ff ff ff 00 05 5d 61 58 a8 08 06</p>
<p>ARP帧（28字节）</p>
<p>0000: 00 01</p>
<p>0010: 08 00 06 04 00 01 00 05 5d 61 58 a8 c0 a8 00 37</p>
<p>0020: 00 00 00 00 00 00 c0 a8 00 02</p>
<p>填充位（18字节）</p>
<p>0020: 00 77 31 d2 50 10</p>
<p>0030: fd 78 41 d3 00 00 00 00 00 00 00 00</p>
<p>以太网首部：目的主机采用广播地址，源主机的MAC地址是00:05:5d:61:58:a8，上层协议类型0x0806表示ARP。</p>
<p>ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0001表示请求目的主机的MAC地址，源主机MAC地址为00:05:5d:61:58:a8，源主机IP地址为c0 a8 00 37（192.168.0.55），目的主机MAC地址全0待填写，目的主机IP地址为c0 a8 00 02（192.168.0.2）。</p>
<p>由于以太网规定最小数据长度为46字节，ARP帧长度只有28字节，因此有18字节填充位，填充位的内容没有定义，与具体实现相关。</p>
<p>应答帧如下：</p>
<p>以太网首部</p>
<p>0000: 00 05 5d 61 58 a8 00 05 5d a1 b8 40 08 06</p>
<p>ARP帧</p>
<p>0000: 00 01</p>
<p>0010: 08 00 06 04 00 02 00 05 5d a1 b8 40 c0 a8 00 02</p>
<p>0020: 00 05 5d 61 58 a8 c0 a8 00 37</p>
<p>填充位</p>
<p>0020: 00 77 31 d2 50 10</p>
<p>0030: fd 78 41 d3 00 00 00 00 00 00 00 00</p>
<p>以太网首部：目的主机的MAC地址是00:05:5d:61:58:a8，源主机的MAC地址是00:05:5d:a1:b8:40，上层协议类型0x0806表示ARP。</p>
<p>ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0002表示应答，源主机MAC地址为00:05:5d:a1:b8:40，源主机IP地址为c0 a8 00 02（192.168.0.2），目的主机MAC地址为00:05:5d:61:58:a8，目的主机IP地址为c0 a8 00 37（192.168.0.55）。</p>
<p>思考题：如果源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？</p>
<h3 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a><strong>IP段格式</strong></h3><img src="/2019/09/16/Linux网络编程-网络基础/net9.png"> 

<p>IP数据报格式</p>
<p>IP数据报的首部长度和数据长度都是可变长的，<strong>但总是4字节的整数倍</strong>。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，<strong>最小值为5</strong>，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说<strong>首部长度最大是60字节</strong>。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</p>
<p>想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？</p>
<h3 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a><strong>UDP数据报格式</strong></h3><img src="/2019/09/16/Linux网络编程-网络基础/net10.png"> 

<p>UDP数据段</p>
<p>下面分析一帧基于UDP的TFTP协议帧。</p>
<p>以太网首部</p>
<p>0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00</p>
<p>IP首部</p>
<p>0000: 45 00</p>
<p>0010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8</p>
<p>0020: 00 01</p>
<p>UDP首部</p>
<p>0020： 05 d4 00 45 00 3f ac 40</p>
<p>TFTP协议</p>
<p>0020: 00 01 ‘c’’:’’&#39;‘q’</p>
<p>0030: ‘w’’e’’r’’q’’.’’q’’w’’e’00 ‘n’’e’’t’’a’’s’’c’’i’</p>
<p>0040: ‘i’00 ‘b’’l’’k’’s’’i’’z’’e’00 ‘5’’1’’2’00 ‘t’’i’</p>
<p>0050: ‘m’’e’’o’’u’’t’00 ‘1’’0’00 ‘t’’s’’i’’z’’e’00 ‘0’</p>
<p>0060: 00以太网首部：源MAC地址是00:05:5d:61:58:a8，目的MAC地址是00:05:5d:67:d0:b1，上层协议类型0x0800表示IP。</p>
<p>IP首部：每一个字节0x45包含4位版本号和4位首部长度，版本号为4，即IPv4，首部长度为5，说明IP首部不带有选项字段。服务类型为0，没有使用服务。16位总长度字段（包括IP首部和IP层payload的长度）为0x0053，即83字节，加上以太网首部14字节可知整个帧长度是97字节。IP报标识是0x9325，标志字段和片偏移字段设置为0x0000，就是DF=0允许分片，MF=0此数据报没有更多分片，没有分片偏移。TTL是0x80，也就是128。上层协议0x11表示UDP协议。IP首部校验和为0x25ec，源主机IP是c0 a8 00 37（192.168.0.55），目的主机IP是c0 a8 00 01（192.168.0.1）。</p>
<p>UDP首部：源端口号0x05d4（1492）是客户端的端口号，目的端口号0x0045（69）是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。</p>
<p>TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是：</p>
<p>c:\qwerq.qwe</p>
<p>netascii</p>
<p>blksize 512</p>
<p>timeout 10</p>
<p>tsize 0</p>
<p>一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口（如上例所示）。在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。/etc/services中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。</p>
<p>很多服务有well-known的端口号，然而客户端程序的端口号却不必是well-known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号，想想这是为什么？</p>
<p>前面提过，UDP协议不面向连接，也不保证传输的可靠性，例如：</p>
<p>发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。</p>
<p>接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。</p>
<p>通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。</p>
<p>因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于    各种文件的传输。TCP协议又是如何用面向连接的服务来代替应用程序解决传输的可靠性问题呢。</p>
<h3 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a><strong>TCP数据报格式</strong></h3><img src="/2019/09/16/Linux网络编程-网络基础/net11.png"> 

<p>TCP数据段</p>
<p>与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小稍后详细解释。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，本节稍后将解释SYN、ACK、FIN、RST四个位，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内。紧急指针和各种选项的解释从略。</p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a><strong>TCP协议</strong></h2><h3 id="TCP通信时序"><a href="#TCP通信时序" class="headerlink" title="TCP通信时序"></a><strong>TCP通信时序</strong></h3><p>下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的<strong>三次握手</strong>和四次握手。</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net12.png"> 

<p>TCP通讯时序</p>
<p>在这个例子中，首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主要信息在箭头上标出，例如段2的箭头上标着SYN, 8000(0), ACK1001, ，表示该段中的SYN位置1，32位序号是8000，该段不携带有效载荷（数据字节数为0），ACK位置1，32位确认序号是1001，带有一个mss（Maximum Segment Size，最大报文长度）选项值为1024。</p>
<p>建立连接（三次握手）的过程：</p>
<ol>
<li>客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。</li>
</ol>
<p>客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。</p>
<ol start="2">
<li>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。</li>
</ol>
<p>服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。</p>
<ol start="3">
<li>客户必须再次回应服务器端一个ACK报文，这是报文段3。</li>
</ol>
<p>客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three-way-handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</p>
<p>在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户端的telnet程序收到RST段后报告错误Connection refused：</p>
<p>$ telnet 192.168.0.200 8080</p>
<p>Trying 192.168.0.200…</p>
<p>telnet: Unable to connect to remote host: Connection refused</p>
<p>数据传输的过程：</p>
<ol>
<li><p>客户端发出段4，包含从序号1001开始的20个字节数据。</p>
</li>
<li><p>服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。</p>
</li>
<li><p>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。</p>
</li>
</ol>
<p>在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</p>
<p>关闭连接（四次握手）的过程：</p>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<ol>
<li><p>客户端发出段7，FIN位表示关闭连接的请求。</p>
</li>
<li><p>服务器发出段8，应答客户端的关闭连接请求。</p>
</li>
<li><p>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</p>
</li>
<li><p>客户端发出段10，应答服务器的关闭连接请求。</p>
</li>
</ol>
<p>建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</p>
<h3 id="滑动窗口-TCP流量控制"><a href="#滑动窗口-TCP流量控制" class="headerlink" title="滑动窗口 (TCP流量控制)"></a><strong>滑动窗口 (TCP流量控制)</strong></h3><p>介绍UDP时我们描述了这样的问题：如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。TCP协议通过“滑动窗口（Sliding Window）”机制解决这一问题。看下图的通讯过程：</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net13.png"> 

<p>滑动窗口</p>
<ol>
<li><p>发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。</p>
</li>
<li><p>发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</p>
</li>
<li><p>接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。</p>
</li>
<li><p>接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</p>
</li>
<li><p>发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。</p>
</li>
<li><p>接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。</p>
</li>
<li><p>接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</p>
</li>
<li><p>接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。</p>
</li>
<li><p>接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。</p>
</li>
</ol>
<p>上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，虚线框表示接收缓冲区，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。</p>
<p>从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。</p>
<h3 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a><strong>TCP状态转换</strong></h3><p>这个图N多人都知道，它排除和定位网络或系统故障时大有帮助，但是怎样牢牢地将这张图刻在脑中呢？那么你就一定要对这张图的每一个状态，及转换的过程有深刻的认识，不能只停留在一知半解之中。下面对这张图的11种状态详细解析一下，以便加强记忆！不过在这之前，先回顾一下TCP建立连接的三次握手过程，以及 关闭连接的四次握手过程。</p>
<img src="/2019/09/16/Linux网络编程-网络基础/net14.png"> 

<p>TCP状态转换图</p>
<p><strong>CLOSED：</strong>表示初始状态。</p>
<p><strong>LISTEN：</strong>该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</p>
<p><strong>SYN_SENT：</strong>这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p>
<p><strong>SYN_RCVD:</strong> 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</p>
<p><strong>ESTABLISHED：</strong>表示连接已经建立。</p>
<p><strong>FIN_WAIT_1:</strong>  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：</p>
<p>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。</p>
<p>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</p>
<p><strong>FIN_WAIT_2：**</strong>主动关闭链接的一方，发出FIN收到ACK以后进入该状态<strong>**。称之为半连接或半关闭状态。</strong>该状态下的socket只能接收数据，不能发。</p>
<p><strong>TIME_WAIT:</strong> 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p>
<p><strong>CLOSING:</strong> 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p>
<p><strong>CLOSE_WAIT:</strong> 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</p>
<p><strong>LAST_ACK:</strong> 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p>
<h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a><strong>半关闭</strong></h3><p>当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。</p>
<p>从程序的角度，可以使用API来控制实现半连接状态。</p>
<p>#include &lt;sys/socket.h&gt;</p>
<p>int shutdown(int sockfd, int how);</p>
<p>sockfd: 需要关闭的socket的描述符</p>
<p>how:    允许为shutdown操作选择以下几种方式:</p>
<p>​    SHUT_RD(0)：    关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</p>
<p>​                    该套接字<strong>不再接受数据</strong>，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</p>
<p>​    SHUT_WR(1):        关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</p>
<p>​    SHUT_RDWR(2):    关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</p>
<p>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。</p>
<p><strong>shutdown不考虑描述符的引用计数，直接关闭描述符</strong>。也可选择中止一个方向的连接，只中止读或只中止写。</p>
<p>注意:</p>
<ol>
<li><p>如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 </p>
</li>
<li><p>在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。</p>
</li>
</ol>
<h3 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a><strong>2MSL</strong></h3><p>2MSL (Maximum Segment Lifetime) TIME_WAIT状态的存在有两个理由：</p>
<p>（1）<strong>让4次握手关闭流程更加可靠</strong>；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。</p>
<p>（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost uplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。</p>
<p>另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost uplicate加上incarnation connection，则会对我们的传输造成致命的错误。</p>
<p>TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq=1000, 来了一个lost duplicate为seq=1000，len=1000, 则TCP认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</p>
<p>该状态为什么设计在<strong>主动关闭这一方</strong>：</p>
<p>（1）发最后ACK的是主动关闭一方。</p>
<p>（2）只要有一方保持TIME_WAIT状态，就能起到避免incarnation connection在2MSL内的重新建立，不需要两方都有。</p>
<p>如何正确对待2MSL TIME_WAIT?</p>
<p>RFC要求socket pair在处于TIME_WAIT时，不能再起一个incarnation connection。但绝大部分TCP实现，强加了更为严格的限制。在2MSL等待期间，socket中使用的本地端口在默认情况下不能再被使用。</p>
<p>若A 10.234.5.5 : 1234和B 10.55.55.60 : 6666建立了连接，A主动关闭，那么在A端只要port为1234，无论对方的port和ip是什么，都不允许再起服务。这甚至比RFC限制更为严格，RFC仅仅是要求socket pair不一致，而实现当中只要这个port处于TIME_WAIT，就不允许起连接。这个限制对主动打开方来说是无所谓的，因为一般用的是临时端口；但对于被动打开方，一般是server，就悲剧了，因为server一般是熟知端口。比如http，一般端口是80，不可能允许这个服务在2MSL内不能起来。</p>
<p>解决方案是给服务器的socket设置SO_REUSEADDR选项，这样的话就算熟知端口处于TIME_WAIT状态，在这个端口上依旧可以将服务启动。当然，虽然有了SO_REUSEADDR选项，但sockt pair这个限制依旧存在。比如上面的例子，A通过SO_REUSEADDR选项依旧在1234端口上起了监听，但这时我们若是从B通过6666端口去连它，TCP协议会告诉我们连接失败，原因为Address already in use.</p>
<p>RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p>
<p>RFC (Request For Comments)，是一系列以编号排定的文件。收集了有关因特网相关资讯，以及UNIX和因特网社群的<a href="http://baike.baidu.com/view/37.htm" target="_blank" rel="noopener">软件</a>文件。</p>
<h4 id="程序设计中的问题"><a href="#程序设计中的问题" class="headerlink" title="程序设计中的问题"></a><strong>程序设计中的问题</strong></h4><p>做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果：</p>
<p>itcast$ ./server</p>
<p>bind error: Address already in use </p>
<p>这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口。我们用netstat命令查看一下：</p>
<p>itcast$ netstat -apn |grep 6666</p>
<p>tcp        1      0 192.168.1.11:38103      192.168.1.11:6666       CLOSE_WAIT  3525/client     </p>
<p>tcp        0      0 192.168.1.11:6666       192.168.1.11:38103      FIN_WAIT2   -           </p>
<p>server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。</p>
<p>现在用Ctrl-C把client也终止掉，再观察现象：</p>
<p>itcast$ netstat -apn |grep 6666</p>
<p>tcp        0      0 192.168.1.11:6666       192.168.1.11:38104      TIME_WAIT   -</p>
<p>itcast$ ./server</p>
<p>bind error: Address already in use</p>
<p>client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。TCP协议规定，<strong>主动关闭连接的一方要处于TIME_WAIT状态</strong>，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为我们先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。</p>
<p>MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。至于为什么要规定TIME_WAIT的时间，可参考UNP 2.7节。</p>
<h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a><strong>端口复用</strong></h4><p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是lis-tenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。</p>
<p>在server代码的socket()和bind()调用之间插入如下代码：</p>
<p>​    int opt = 1;</p>
<p>​    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</p>
<p>有关setsockopt可以设置的其它选项请参考UNP第7章。</p>
<h3 id="TCP异常断开"><a href="#TCP异常断开" class="headerlink" title="TCP异常断开"></a><strong>TCP异常断开</strong></h3><h4 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a><strong>心跳检测机制</strong></h4><p>在TCP网络通信中，经常会出现客户端和服务器之间的非正常断开，需要实时检测查询链接状态。常用的解决方法就是在程序中加入心跳机制。</p>
<p>Heart-Beat线程</p>
<p>这个是最常用的简单方法。在接收和发送数据时个人设计一个守护进程(线程)，定时发送Heart-Beat包，客户端/服务器收到该小包后，立刻返回相应的包即可检测对方是否实时在线。</p>
<p>该方法的好处是通用，但缺点就是会改变现有的通讯协议！大家一般都是使用业务层心跳来处理，主要是灵活可控。</p>
<p>UNIX网络编程不推荐使用SO_KEEPALIVE来做心跳检测，还是在业务层以心跳包做检测比较好，也方便控制。</p>
<h4 id="设置TCP属性"><a href="#设置TCP属性" class="headerlink" title="设置TCP属性"></a><strong>设置TCP属性</strong></h4><p>SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为EHOSTUNREACH。</p>
<p>根据上面的介绍我们可以知道对端以一种非优雅的方式断开连接的时候，我们可以设置SO_KEEPALIVE属性使得我们在2小时以后发现对方的TCP连接是否依然存在。</p>
<p>​    keepAlive = 1;</p>
<p>​    setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;keepAlive, sizeof(keepAlive));</p>
<p>如果我们不能接受如此之长的等待时间，从TCP-Keepalive-HOWTO上可以知道一共有两种方式可以设置，一种是修改内核关于网络方面的 配置参数，另外一种就是SOL_TCP字段的TCP_KEEPIDLE， TCP_KEEPINTVL， TCP_KEEPCNT三个选项。</p>
<ol>
<li>The tcp_keepidle parameter specifies the interval of inactivity that causes TCP to generate a KEEPALIVE transmission for an application that requests them. tcp_keepidle defaults to 14400 (two hours). </li>
</ol>
<p>/*开始首次KeepAlive探测前的TCP空闭时间 */</p>
<ol start="2">
<li>The tcp_keepintvl parameter specifies the interval between the nine retriesthat are attempted if a KEEPALIVE transmission is not acknowledged. tcp_keep ntvldefaults to 150 (75 seconds). </li>
</ol>
<p>/* 两次KeepAlive探测间的时间间隔 */</p>
<ol start="3">
<li>The tcp_keepcnt option specifies the maximum number of keepalive probes tobe sent. The value of TCP_KEEPCNT is an integer value between 1 and n, where n s the value of the systemwide tcp_keepcnt parameter. </li>
</ol>
<p>/* 判定断开前的KeepAlive探测次数*/</p>
<p>int keepIdle = 1000;</p>
<p>int keepInterval = 10;</p>
<p>int keepCount = 10;</p>
<p>Setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;keepIdle, sizeof(keepIdle));</p>
<p>Setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)&amp;keepInterval, sizeof(keepInterval));</p>
<p>Setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)&amp;keepCount, sizeof(keepCount));</p>
<p>SO_KEEPALIVE设置空闲2小时才发送一个“保持存活探测分节”，不能保证实时检测。对于判断网络断开时间太长，对于需要及时响应的程序不太适应。</p>
<p>当然也可以修改时间间隔参数，但是会影响到所有打开此选项的套接口！关联了完成端口的socket可能会忽略掉该套接字选项。</p>
<h2 id="网络名词术语解析"><a href="#网络名词术语解析" class="headerlink" title="网络名词术语解析"></a><strong>网络名词术语解析</strong></h2><h3 id="路由-route"><a href="#路由-route" class="headerlink" title="路由(route)"></a><strong>路由(route)</strong></h3><p>路由（名词）</p>
<p>数据包从源地址到目的地址所经过的路径，由一系列路由节点组成。</p>
<p>路由（动词）</p>
<p>某个路由节点为数据包选择投递方向的选路过程。</p>
<h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a><strong>路由器工作原理</strong></h3><p>路由器（Router）是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号的设备。</p>
<p>传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数， 并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。</p>
<p>路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。</p>
<p>网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用；选择最合理的路由，引导通信也是路由器基本功能；多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。</p>
<p>路由和交换之间的主要区别就是交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p>
<h3 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a><strong>路由表(Routing Table)</strong></h3><p>在计算机网络中，路由表或称路由择域信息库（RIB）是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径。</p>
<h3 id="路由条目"><a href="#路由条目" class="headerlink" title="路由条目"></a><strong>路由条目</strong></h3><p>路由表中的一行，每个条目主要由目的网络地址、子网掩码、下一跳地址、发送接口四部分组成，如果要发送的数据包的目的网络地址匹配路由表中的某一行，就按规定的接口发送到下一跳地址。</p>
<h3 id="缺省路由条目"><a href="#缺省路由条目" class="headerlink" title="缺省路由条目"></a><strong>缺省路由条目</strong></h3><p>路由表中的最后一行，主要由下一跳地址和发送接口两部分组成，当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址。</p>
<h3 id="路由节点"><a href="#路由节点" class="headerlink" title="路由节点"></a><strong>路由节点</strong></h3><p>一个具有路由能力的主机或路由器，它维护一张路由表，通过查询路由表来决定向哪个接口发送数据包。</p>
<h3 id="以太网交换机工作原理"><a href="#以太网交换机工作原理" class="headerlink" title="以太网交换机工作原理"></a><strong>以太网交换机工作原理</strong></h3><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p>
<p>以太网交换机工作于OSI网络参考模型的第二层（即数据链路层），是一种基于MAC（Media Access Control，介质访问控制）地址识别、完成以太网数据帧转发的网络设备。</p>
<h3 id="hub工作原理"><a href="#hub工作原理" class="headerlink" title="hub工作原理"></a><strong>hub工作原理</strong></h3><p>集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。</p>
<p>集线器功能是随机选出某一端口的设备，并让它独占全部带宽，与集线器的上联设备（交换机、路由器或服务器等）进行通信。从Hub的工作方式可以看出，它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力，是—个标准的共享式设备。其次是Hub只与它的上联设备(如上层Hub、交换机或服务器)进行通信，同层的各端口之间不会直接进行通信，而是通过上联设备再将信息广播到所有端口上。 由此可见，即使是在同一Hub的不同两个端口之间进行通信，都必须要经过两步操作：</p>
<p>第一步是将信息上传到上联设备；</p>
<p>第二步是上联设备再将该信息广播到所有端口上。</p>
<h3 id="半双工-全双工"><a href="#半双工-全双工" class="headerlink" title="半双工/全双工"></a><strong>半双工/全双工</strong></h3><p>Full-duplex（全双工）全双工是在通道中同时双向数据传输的能力。</p>
<p>Half-duplex（半双工）在通道中同时只能沿着一个方向传输数据。</p>
<h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a><strong>DNS服务器</strong></h3><p>DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址串。</p>
<p>它是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。</p>
<h3 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网(LAN)"></a><strong>局域网(LAN)</strong></h3><p>local area network，一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网。</p>
<ol>
<li><p>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p>
</li>
<li><p>使用专门铺设的传输介质进行联网，数据传输速率高（10Mb/s～10Gb/s）</p>
</li>
<li><p>通信延迟时间短，可靠性较高</p>
</li>
<li><p>局域网可以支持多种传输介质</p>
</li>
</ol>
<h3 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网(WAN)"></a><strong>广域网(WAN)</strong></h3><p>wide area network，一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。</p>
<p>覆盖的范围比局域网（LAN）和城域网（MAN）都广。广域网的通信子网主要使用分组交换技术。</p>
<p>广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如互联网是世界范围内最大的广域网。</p>
<ol>
<li><p>适应大容量与突发性通信的要求；</p>
</li>
<li><p>适应综合业务服务的要求；</p>
</li>
<li><p>开放的设备接口与规范化的协议；</p>
</li>
<li><p>完善的通信服务与网络管理。</p>
</li>
</ol>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a><strong>端口</strong></h3><p>逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</p>
<p>\1. 端口号小于256的定义为常用端口，服务器一般都是通过常用端口号来识别的。</p>
<p>\2. 客户端只需保证该端口号在本机上是惟一的就可以了。客户端口号因存在时间很短暂又称临时端口号；</p>
<p>\3. 大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口号是为其他服务器预留的。</p>
<p>我们应该在自定义端口时，避免使用well-known的端口。如：80、21等等。</p>
<h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a><strong>MTU</strong></h3><p>MTU:通信术语 最大传输单元（Maximum Transmission Unit，MTU）</p>
<p>是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。</p>
<p>以下是一些协议的MTU：</p>
<p>FDDI协议：4352字节</p>
<p><strong>以太网（Ethernet）协议：1500字节</strong></p>
<p>PPPoE（ADSL）协议：1492字节</p>
<p>X.25协议（Dial Up/Modem）：576字节</p>
<p>Point-to-Point：4470字节</p>
<h2 id="常见网络知识面试题"><a href="#常见网络知识面试题" class="headerlink" title="常见网络知识面试题"></a><strong>常见网络知识面试题</strong></h2><ol>
<li><p>TCP如何建立链接</p>
</li>
<li><p>TCP如何通信</p>
</li>
<li><p>TCP如何关闭链接</p>
</li>
<li><p>什么是滑动窗口</p>
</li>
<li><p>什么是半关闭</p>
</li>
<li><p>局域网内两台机器如何利用TCP/IP通信</p>
</li>
<li><p>internet上两台主机如何进行通信</p>
</li>
<li><p>如何在internet上识别唯一一个进程</p>
</li>
</ol>
<p>答：通过“IP地址+端口号”来区分不同的服务</p>
<ol start="9">
<li><p>为什么说TCP是可靠的链接，UDP不可靠</p>
</li>
<li><p>路由器和交换机的区别</p>
</li>
<li><p>点到点，端到端</p>
</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-线程同步]]></title>
      <url>/2019/09/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h2 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a><strong>同步概念</strong></h2><p>​    所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等</p>
<p>​    而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a><strong>线程同步</strong></h3><p>​    同步即协同步调，按预定的先后次序运行。</p>
<p>​    线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p>
<p>举例1：    银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</p>
<p>举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续    从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</p>
<p>​    产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</p>
<p>​    “同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p>
<p>​    因此，<strong>所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</strong></p>
<h3 id="数据混乱原因："><a href="#数据混乱原因：" class="headerlink" title="数据混乱原因："></a><strong>数据混乱原因：</strong></h3><ol>
<li><p>资源共享（独享资源则不会）    </p>
</li>
<li><p>调度随机（意味着数据访问会出现竞争）    </p>
</li>
<li><p>线程间缺乏必要的同步机制。</p>
</li>
</ol>
<p>​    以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p>
<p>​    所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p>
<h2 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a><strong>互斥量mutex</strong></h2><p>Linux中提供一把互斥锁mutex（也称之为互斥量）。</p>
<p>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p>
<p>​    资源还是共享的，线程间也还是竞争的，                            </p>
<p>​    但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p>
<img src="/2019/09/16/Linux系统编程-线程同步/sync1.png"> 

<p>​    但，应注意：同一时刻，只能有一个线程持有该锁。</p>
<p>​    当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</p>
<p>​    所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。</p>
<p>​    因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</p>
<h3 id="主要应用函数："><a href="#主要应用函数：" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h3><p>​    pthread_mutex_init函数</p>
<p>​    pthread_mutex_destroy函数</p>
<p>​    pthread_mutex_lock函数</p>
<p>​    pthread_mutex_trylock函数</p>
<p>​    pthread_mutex_unlock函数</p>
<p>以上5个函数的返回值都是：成功返回0， 失败返回错误号。    </p>
<p>pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</p>
<p>pthread_mutex_t mutex; 变量mutex只有两种取值1、0。</p>
<h4 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a><strong>pthread_mutex_init函数</strong></h4><p>初始化一个互斥锁(互斥量) —&gt; 初值可看作1</p>
<p>​    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</p>
<p>​    参1：传出参数，调用时应传 &amp;mutex    </p>
<p>​    restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</p>
<p>​    参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</p>
<ol>
<li><p>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</p>
</li>
<li><p>动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</p>
</li>
</ol>
<h4 id="pthread-mutex-destroy函数"><a href="#pthread-mutex-destroy函数" class="headerlink" title="pthread_mutex_destroy函数"></a><strong>pthread_mutex_destroy函数</strong></h4><p>销毁一个互斥锁</p>
<p>​    int pthread_mutex_destroy(pthread_mutex_t *mutex);</p>
<h4 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a><strong>pthread_mutex_lock函数</strong></h4><p>加锁。可理解为将mutex–（或-1）</p>
<p>​    int pthread_mutex_lock(pthread_mutex_t *mutex);</p>
<h4 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a><strong>pthread_mutex_unlock函数</strong></h4><p>解锁。可理解为将mutex ++（或+1）</p>
<p>​    int pthread_mutex_unlock(pthread_mutex_t *mutex);</p>
<h4 id="pthread-mutex-trylock函数"><a href="#pthread-mutex-trylock函数" class="headerlink" title="pthread_mutex_trylock函数"></a><strong>pthread_mutex_trylock函数</strong></h4><p>尝试加锁</p>
<p>​    int pthread_mutex_trylock(pthread_mutex_t *mutex);</p>
<h3 id="加锁与解锁"><a href="#加锁与解锁" class="headerlink" title="加锁与解锁"></a><strong>加锁与解锁</strong></h3><h4 id="lock与unlock："><a href="#lock与unlock：" class="headerlink" title="lock与unlock："></a><strong>lock与unlock：</strong></h4><p>​    lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</p>
<p>​    unlock主动解锁函数，<strong>同时将阻塞在该锁上的所有线程**</strong>全部唤醒**，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</p>
<p>​    例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。</p>
<p>​    可假想mutex锁 init成功初值为1。    lock 功能是将mutex–。    unlock将mutex++</p>
<h4 id="lock与trylock："><a href="#lock与trylock：" class="headerlink" title="lock与trylock："></a><strong>lock与trylock：</strong></h4><p>​    lock加锁失败会阻塞，等待锁释放。</p>
<p>​    trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</p>
<h3 id="加锁步骤测试："><a href="#加锁步骤测试：" class="headerlink" title="加锁步骤测试："></a><strong>加锁步骤测试：</strong></h3><p>​    看如下程序：该程序是非常典型的，由于共享、竞争而没有加任何同步机制，导致产生于时间有关的错误，造成数据混乱：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">3</span>);	<span class="comment">/*模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误*/</span></span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">​    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">​    pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【练习】：修改该程序，使用mutex互斥锁进行同步。                                        </p>
<ol>
<li><p>定义全局互斥量，初始化init(&amp;m, NULL)互斥量，添加对应的destry</p>
</li>
<li><p>两个线程while中，两次printf前后，分别加lock和unlock</p>
</li>
<li><p>将unlock挪至第二个sleep后，发现交替现象很难出现。</p>
</li>
</ol>
<p>线程在操作完共享资源后本应该立即解锁，但修改后，线程抱着锁睡眠。睡醒解锁后又立即加锁，这两个库函数本身不会阻塞。</p>
<p>所以在这两行代码之间失去cpu的概率很小。因此，另外一个线程很难得到加锁的机会。</p>
<ol start="4">
<li><p>main 中加flag = 5 将flg在while中–  这时，主线程输出5次后试图销毁锁，但子线程未将锁释放，无法完成。</p>
</li>
<li><p>main 中加pthread_cancel()将子线程取消。                                        </p>
</li>
</ol>
<p><strong>结论：</strong></p>
<p>​    <strong>在访问共享资源前加锁，访问结束后**</strong>立即解锁<strong>**。锁的“粒度”应越小越好。</strong></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h2><p>​    1. 线程试图对同一个互斥量A加锁两次。</p>
<p>​    2. 线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁                                        </p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h2><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。</p>
<h3 id="读写锁状态："><a href="#读写锁状态：" class="headerlink" title="读写锁状态："></a><strong>读写锁状态：</strong></h3><p>一把读写锁具备三种状态：</p>
<p>​    1. 读模式下加锁状态 (读锁)</p>
<p>​    2. 写模式下加锁状态 (写锁)</p>
<p>​    3. 不加锁状态</p>
<h3 id="读写锁特性："><a href="#读写锁特性：" class="headerlink" title="读写锁特性："></a><strong>读写锁特性：</strong></h3><ol>
<li><p>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</p>
</li>
<li><p>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</p>
</li>
<li><p>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁, 读锁、写锁并行阻塞，<strong>写锁优先级高</strong></p>
</li>
</ol>
<p>​    读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享。</strong></p>
<p>​    读写锁非常适合于对数据结构读的次数远大于写的情况。</p>
<h3 id="主要应用函数：-1"><a href="#主要应用函数：-1" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h3><p>​    pthread_rwlock_init函数</p>
<p>​    pthread_rwlock_destroy函数</p>
<p>​    pthread_rwlock_rdlock函数  </p>
<p>​    pthread_rwlock_wrlock函数</p>
<p>​    pthread_rwlock_tryrdlock函数</p>
<p>​    pthread_rwlock_trywrlock函数</p>
<p>​    pthread_rwlock_unlock函数</p>
<p>以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。    </p>
<p>​    pthread_rwlock_t类型    用于定义一个读写锁变量。</p>
<p>​    pthread_rwlock_t rwlock;</p>
<h4 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a><strong>pthread_rwlock_init函数</strong></h4><p>初始化一把读写锁</p>
<p>​    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</p>
<p>​    参2：attr表读写锁属性，通常使用默认属性，传NULL即可。</p>
<h4 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a><strong>pthread_rwlock_destroy函数</strong></h4><p>销毁一把读写锁</p>
<p>​    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a><strong>pthread_rwlock_rdlock函数</strong></h4><p>以读方式请求读写锁。（常简称为：请求读锁）</p>
<p>​    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a><strong>pthread_rwlock_wrlock函数</strong></h4><p>以写方式请求读写锁。（常简称为：请求写锁）</p>
<p>​    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a><strong>pthread_rwlock_unlock函数</strong></h4><p>解锁</p>
<p>​    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-tryrdlock函数"><a href="#pthread-rwlock-tryrdlock函数" class="headerlink" title="pthread_rwlock_tryrdlock函数"></a><strong>pthread_rwlock_tryrdlock函数</strong></h4><p>非阻塞以读方式请求读写锁（非阻塞请求读锁）</p>
<p>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</p>
<h4 id="pthread-rwlock-trywrlock函数"><a href="#pthread-rwlock-trywrlock函数" class="headerlink" title="pthread_rwlock_trywrlock函数"></a><strong>pthread_rwlock_trywrlock函数</strong></h4><p>非阻塞以写方式请求读写锁（非阻塞请求写锁）</p>
<p>​    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</p>
<h3 id="读写锁示例"><a href="#读写锁示例" class="headerlink" title="读写锁示例"></a><strong>读写锁示例</strong></h3><p>看如下示例，同时有多个线程对同一全局数据读、写操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">th_write</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> t, i = (<span class="keyword">int</span>)arg;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​        t = counter;</span><br><span class="line"></span><br><span class="line">​        usleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"=======write %d: %lu: counter=%d ++counter=%d\n"</span>, i, pthread_self(), t, ++counter);</span><br><span class="line"></span><br><span class="line">​        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​        usleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">th_read</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"----------------------------read %d: %lu: %d\n"</span>, i, pthread_self(), counter);</span><br><span class="line"></span><br><span class="line">​        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​        usleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">​    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"></span><br><span class="line">​        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, th_write, (<span class="keyword">void</span> *)i);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line"></span><br><span class="line">​        pthread_create(&amp;tid[i+<span class="number">3</span>], <span class="literal">NULL</span>, th_read, (<span class="keyword">void</span> *)i);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line"></span><br><span class="line">​        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                </p>
<h2 id="条件变量："><a href="#条件变量：" class="headerlink" title="条件变量："></a><strong>条件变量：</strong></h2><p>​    条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</p>
<h3 id="主要应用函数：-2"><a href="#主要应用函数：-2" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h3><p>​    pthread_cond_init函数</p>
<p>​    pthread_cond_destroy函数</p>
<p>​    pthread_cond_wait函数</p>
<p>​    pthread_cond_timedwait函数</p>
<p>​    pthread_cond_signal函数</p>
<p>​    pthread_cond_broadcast函数</p>
<p>以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。</p>
<p>​    pthread_cond_t类型    用于定义条件变量</p>
<p>​    pthread_cond_t cond;</p>
<h4 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a><strong>pthread_cond_init函数</strong></h4><p>初始化一个条件变量</p>
<p>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);        </p>
<p>参2：attr表条件变量属性，通常为默认值，传NULL即可</p>
<p>也可以使用静态初始化的方法，初始化条件变量：</p>
<p>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p>
<h4 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a><strong>pthread_cond_destroy函数</strong></h4><p>销毁一个条件变量</p>
<p>int pthread_cond_destroy(pthread_cond_t *cond);</p>
<h4 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a><strong>pthread_cond_wait函数</strong></h4><p>阻塞等待一个条件变量</p>
<p>​    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</p>
<p>函数作用：</p>
<ol>
<li><p>阻塞等待条件变量cond（参1）满足    </p>
</li>
<li><p>释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);</p>
<p><strong>1.2.两步为一个原子操作。</strong></p>
</li>
<li><p>当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</p>
</li>
</ol>
<h4 id="pthread-cond-timedwait函数"><a href="#pthread-cond-timedwait函数" class="headerlink" title="pthread_cond_timedwait函数"></a><strong>pthread_cond_timedwait函数</strong></h4><p>限时等待一个条件变量</p>
<p>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</p>
<p>​    参3：    参看man sem_timedwait函数，查看struct timespec结构体。</p>
<p>​        struct timespec {</p>
<p>​            time_t tv_sec;        /* seconds */ 秒</p>
<p>​            long   tv_nsec;    /* nanosecondes*/ 纳秒</p>
<p>​        }                                </p>
<p>形参abstime：绝对时间。                                        </p>
<p>如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。    </p>
<p>​            struct timespec t = {1, 0};</p>
<p>​            pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 1970年1月1日 00:00:01秒(早已经过去) </p>
<p>​        正确用法：</p>
<p>​            time_t cur = time(NULL); 获取当前时间。</p>
<p>struct timespec t;    定义timespec 结构体变量t</p>
<p>​            t.tv_sec = cur+1; 定时1秒</p>
<p>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参                参APUE.11.6线程同步条件变量小节</p>
<p>​        在讲解setitimer函数时我们还提到另外一种时间类型：</p>
<p>​        struct timeval {</p>
<p>​             time_t      tv_sec;  /* seconds */ 秒</p>
<p>​             suseconds_t tv_usec;     /* microseconds */ 微秒</p>
<p>​        };</p>
<h4 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a><strong>pthread_cond_signal函数</strong></h4><p>唤醒至少一个阻塞在条件变量上的线程</p>
<p>int pthread_cond_signal(pthread_cond_t *cond);</p>
<h4 id="pthread-cond-broadcast函数"><a href="#pthread-cond-broadcast函数" class="headerlink" title="pthread_cond_broadcast函数"></a><strong>pthread_cond_broadcast函数</strong></h4><p>唤醒全部阻塞在条件变量上的线程</p>
<p>​    int pthread_cond_broadcast(pthread_cond_t *cond);</p>
<h3 id="生产者消费者条件变量模型"><a href="#生产者消费者条件变量模型" class="headerlink" title="生产者消费者条件变量模型"></a><strong>生产者消费者条件变量模型</strong></h3><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p>
<p>看如下示例，使用条件变量模拟生产者、消费者问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">​        pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">while</span> (head == <span class="literal">NULL</span>) &#123;           <span class="comment">//头指针为空,说明没有节点    可以为if吗</span></span><br><span class="line"></span><br><span class="line">​            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        mp = head;      </span><br><span class="line"></span><br><span class="line">​        head = mp-&gt;next;    			<span class="comment">//模拟消费掉一个产品</span></span><br><span class="line"></span><br><span class="line">​        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"-Consume ---%d\n"</span>, mp-&gt;num);</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">free</span>(mp);</span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        mp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct msg));</span><br><span class="line"></span><br><span class="line">​        mp-&gt;num = rand() % <span class="number">1000</span> + <span class="number">1</span>;        <span class="comment">//模拟生产一个产品</span></span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"-Produce ---%d\n"</span>, mp-&gt;num);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​        pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">​        mp-&gt;next = head;</span><br><span class="line"></span><br><span class="line">​        head = mp;</span><br><span class="line"></span><br><span class="line">​        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​        pthread_cond_signal(&amp;has_product);  <span class="comment">//将等待在该条件变量上的一个线程唤醒</span></span><br><span class="line"></span><br><span class="line">​        sleep(rand() % <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_t</span> pid, cid;</span><br><span class="line"></span><br><span class="line">​    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                        </p>
<h3 id="条件变量的优点："><a href="#条件变量的优点：" class="headerlink" title="条件变量的优点："></a><strong>条件变量的优点：</strong></h3><p>​    相较于mutex而言，条件变量可以减少竞争。</p>
<p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong>信号量</strong></h2><p>进化版的互斥锁（1 –&gt; N）</p>
<p>​    由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</p>
<p>​    信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p>
<h3 id="主要应用函数：-3"><a href="#主要应用函数：-3" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h3><p>​    sem_init函数</p>
<p>​    sem_destroy函数</p>
<p>​    sem_wait函数</p>
<p>​    sem_trywait函数    </p>
<p>​    sem_timedwait函数    </p>
<p>​    sem_post函数</p>
<p>以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)</p>
<p>​    sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。 </p>
<p>sem_t sem; 规定信号量sem不能 &lt; 0。头文件 &lt;semaphore.h&gt;</p>
<h4 id="信号量基本操作："><a href="#信号量基本操作：" class="headerlink" title="信号量基本操作："></a><strong>信号量基本操作：</strong></h4><p>sem_wait:    1. 信号量大于0，则信号量–        （类比pthread_mutex_lock）</p>
<p>​      |            2. 信号量等于0，造成线程阻塞</p>
<p>​    对应</p>
<p>​      |</p>
<p>​    sem_post：    将信号量++，同时唤醒阻塞在信号量上的线程    （类比pthread_mutex_unlock）</p>
<p>但，由于sem_t的实现对用户隐藏，所以所谓的++、–操作只能通过函数来实现，而不能直接++、–符号。</p>
<p><strong>信号量的初值，决定了占用信号量的线程的个数。</strong></p>
<h4 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a><strong>sem_init函数</strong></h4><p>初始化一个信号量</p>
<p>​    int sem_init(sem_t *sem, int pshared, unsigned int value);</p>
<p>​    参1：sem信号量    </p>
<p>参2：pshared取0用于线程间；取非0（一般为1）用于进程间    </p>
<p>参3：value指定信号量初值</p>
<h4 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a><strong>sem_destroy函数</strong></h4><p>销毁一个信号量</p>
<p>​    int sem_destroy(sem_t *sem);</p>
<h4 id="sem-wait函数"><a href="#sem-wait函数" class="headerlink" title="sem_wait函数"></a><strong>sem_wait函数</strong></h4><p>给信号量加锁 – </p>
<p>​    int sem_wait(sem_t *sem);</p>
<h4 id="sem-post函数"><a href="#sem-post函数" class="headerlink" title="sem_post函数"></a><strong>sem_post函数</strong></h4><p>给信号量解锁 ++</p>
<p>​     int sem_post(sem_t *sem);    </p>
<h4 id="sem-trywait函数"><a href="#sem-trywait函数" class="headerlink" title="sem_trywait函数"></a><strong>sem_trywait函数</strong></h4><p>尝试对信号量加锁 –    (与sem_wait的区别类比lock和trylock)</p>
<p>​     int sem_trywait(sem_t *sem);    </p>
<h4 id="sem-timedwait函数"><a href="#sem-timedwait函数" class="headerlink" title="sem_timedwait函数"></a><strong>sem_timedwait函数</strong></h4><p>限时尝试对信号量加锁 –</p>
<p>​    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</p>
<p>​    参2：abs_timeout采用的是绝对时间。            </p>
<p>​    定时1秒：</p>
<p>​        time_t cur = time(NULL); 获取当前时间。</p>
<p>struct timespec t;    定义timespec 结构体变量t</p>
<p>​        t.tv_sec = cur+1; 定时1秒</p>
<p>​        t.tv_nsec = t.tv_sec +100; </p>
<p>sem_timedwait(&amp;sem, &amp;t); 传参</p>
<h3 id="生产者消费者信号量模型"><a href="#生产者消费者信号量模型" class="headerlink" title="生产者消费者信号量模型"></a><strong>生产者消费者信号量模型</strong></h3><p>【练习】：使用信号量完成线程间同步，模拟生产者，消费者问题。            </p>
<p>分析：</p>
<p>​    规定：    如果□中有数据，生产者不能生产，只能阻塞。</p>
<p>​            如果□中没有数据，消费者不能消费，只能等待数据。</p>
<p>​    定义两个信号量：S满 = 0， S空 = 1 （S满代表满格的信号量，S空表示空格的信号量，程序起始，格子一定为空）</p>
<p>​    所以有：    T生产者主函数 {                T消费者主函数 {</p>
<p>​                     sem_wait(S空);                 sem_wait(S满);</p>
<p>​                    生产….                          消费….</p>
<p>​                     sem_post(S满);                 sem_post(S空);</p>
<p>​                }                            }</p>
<p>​    假设：    线程到达的顺序是:T生、T生、T消。</p>
<p>​    那么：    T生1 到达，将S空-1，生产，将S满+1</p>
<p>​            T生2 到达，S空已经为0， 阻塞</p>
<p>​            T消  到达，将S满-1，消费，将S空+1</p>
<p>​    三个线程到达的顺序是：T生1、T生2、T消。而执行的顺序是T生1、T消、T生2</p>
<p>​    这里，S空 表示空格子的总数，代表可占用信号量的线程总数–&gt;1。其实这样的话，信号量就等同于互斥锁。</p>
<p>​    但，如果S空=2、3、4……就不一样了，该信号量同时可以由多个线程占用，不再是互斥的形式。因此我们说信号量是互斥锁的加强版。</p>
<p>【推演练习】：    理解上述模型，推演，如果是两个消费者，一个生产者，是怎么样的情况。        </p>
<p>【作业】：结合生产者消费者信号量模型，揣摩sem_timedwait函数作用。编程实现，一个线程读用户输入， 另一个线程打印“hello world”。如果用户无输入，则每隔5秒向屏幕打印一个“hello world”；如果用户有输入，立刻打印“hello world”到屏幕。                                                                            </p>
<h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a><strong>进程间同步</strong></h2><h3 id="互斥量mutex-1"><a href="#互斥量mutex-1" class="headerlink" title="互斥量mutex"></a><strong>互斥量mutex</strong></h3><p>进程间也可以使用互斥锁，来达到同步的目的。但应在pthread_mutex_init初始化之前，修改其属性为进程间共享。mutex的属性修改函数主要有以下几个。</p>
<h4 id="主要应用函数：-4"><a href="#主要应用函数：-4" class="headerlink" title="主要应用函数："></a><strong>主要应用函数：</strong></h4><p>​    pthread_mutexattr_t mattr 类型：        用于定义mutex锁的【属性】</p>
<p>​    <strong>pthread_mutexattr_init函数</strong>：            初始化一个mutex属性对象</p>
<p>​        int pthread_mutexattr_init(pthread_mutexattr_t *attr);</p>
<p>​    <strong>pthread_mutexattr_destroy函数</strong>：        销毁mutex属性对象 (而非销毁锁)</p>
<p>​        int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</p>
<p>​    <strong>pthread_mutexattr_setpshared函数</strong>：    修改mutex属性。</p>
<p>​        int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</p>
<p>​        参2：pshared取值：</p>
<p>​            线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有)</p>
<p>​            进程锁：PTHREAD_PROCESS_SHARED</p>
<h4 id="进程间mutex示例"><a href="#进程间mutex示例" class="headerlink" title="进程间mutex示例"></a><strong>进程间mutex示例</strong></h4><p>进程间使用mutex来实现同步：</p>
<p>​                    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mt</span> &#123;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> fd, i;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">mt</span> *<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    fd = open(<span class="string">"mt_test"</span>, O_CREAT | O_RDWR, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">​    ftruncate(fd, <span class="keyword">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line">​    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(*mm), PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">​    close(fd);</span><br><span class="line"></span><br><span class="line">​    unlink(<span class="string">"mt_test"</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);</span></span><br><span class="line"></span><br><span class="line">​    <span class="built_in">memset</span>(mm, <span class="number">0</span>, <span class="keyword">sizeof</span>(*mm));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_mutexattr_init(&amp;mm-&gt;mutexattr);                                  <span class="comment">//初始化mutex属性对象</span></span><br><span class="line"></span><br><span class="line">​    pthread_mutexattr_setpshared(&amp;mm-&gt;mutexattr, PTHREAD_PROCESS_SHARED);    <span class="comment">//修改属性为进程间共享</span></span><br><span class="line"></span><br><span class="line">​    pthread_mutex_init(&amp;mm-&gt;mutex, &amp;mm-&gt;mutexattr);                          <span class="comment">//初始化一把mutex琐</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pid = fork();</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">​            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line"></span><br><span class="line">​            (mm-&gt;num)++;</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">printf</span>(<span class="string">"-child----num++   %d\n"</span>, mm-&gt;num);</span><br><span class="line"></span><br><span class="line">​            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line"></span><br><span class="line">​            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">​            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line"></span><br><span class="line">​            mm-&gt;num += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">printf</span>(<span class="string">"-parent---num+=2  %d\n"</span>, mm-&gt;num);</span><br><span class="line"></span><br><span class="line">​            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    pthread_mutexattr_destroy(&amp;mm-&gt;mutexattr);          <span class="comment">//销毁mutex属性对象</span></span><br><span class="line"></span><br><span class="line">​    pthread_mutex_destroy(&amp;mm-&gt;mutex);                <span class="comment">//销毁mutex</span></span><br><span class="line"></span><br><span class="line">​    munmap(mm,<span class="keyword">sizeof</span>(*mm));                          <span class="comment">//释放映射区</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a><strong>文件锁</strong></h3><p>​    借助 fcntl函数来实现锁机制。    操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作。</p>
<p>fcntl函数：    获取、设置文件访问控制属性。</p>
<p>​    int fcntl(int fd, int cmd, … /* arg */ );</p>
<p>​    参2：</p>
<p>​        F_SETLK (struct flock *)    设置文件锁（trylock）</p>
<p>​        F_SETLKW (struct flock *) 设置文件锁（lock）W –&gt; wait</p>
<p>​        F_GETLK (struct flock *)    获取文件锁</p>
<p>​    参3：</p>
<p>​        struct flock {</p>
<p>​              …</p>
<p>​              short l_type;        锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</p>
<p>​              short l_whence;      偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </p>
<p>​              off_t l_start;           起始偏移：1000</p>
<p>​              off_t l_len;             长度：0表示整个文件加锁</p>
<p>​              pid_t l_pid;         持有该锁的进程ID：(F_GETLK only)</p>
<p>​              …</p>
<p>​         };</p>
<h4 id="进程间文件锁示例"><a href="#进程间文件锁示例" class="headerlink" title="进程间文件锁示例"></a><strong>进程间文件锁示例</strong></h4><p>多个进程对加锁文件进行访问： </p>
<p>​    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    perror(str); <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">​    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">f_lock</span>;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">printf</span>(<span class="string">"./a.out filename\n"</span>); <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">​        sys_err(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    <span class="comment">//f_lock.l_type = F_WRLCK;        /*选用写琐*/</span></span><br><span class="line"></span><br><span class="line">​    f_lock.l_type = F_RDLCK;          <span class="comment">/*选用读琐*/</span> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    f_lock.l_whence = SEEK_SET;</span><br><span class="line"></span><br><span class="line">​    f_lock.l_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    f_lock.l_len = <span class="number">0</span>;               <span class="comment">/* 0表示整个文件加锁 */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"get flock\n"</span>);</span><br><span class="line"></span><br><span class="line">​    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    f_lock.l_type = F_UNLCK;</span><br><span class="line"></span><br><span class="line">​    fcntl(fd, F_SETLKW, &amp;f_lock);</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">printf</span>(<span class="string">"un flock\n"</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    close(fd);	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                </p>
<p>依然遵循“读共享、写独占”特性。但！如若进程不加锁直接操作文件，依然可访问成功，但数据势必会出现混乱。</p>
<p>【思考】：多线程中，可以使用文件锁吗？</p>
<p>多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。</p>
<h2 id="哲学家用餐模型分析"><a href="#哲学家用餐模型分析" class="headerlink" title="哲学家用餐模型分析"></a><strong>哲学家用餐模型分析</strong></h2><h3 id="多线程版："><a href="#多线程版：" class="headerlink" title="多线程版："></a><strong>多线程版：</strong></h3><p>​    选用互斥锁mutex，如创建5个， pthread_mutex_t m[5];</p>
<p>​    模型抽象：    </p>
<p>​        5个哲学家 –&gt; 5个线程；    5支筷子 –&gt; 5把互斥锁        int left(左手)， right(右手)</p>
<p>​        5个哲学家使用相同的逻辑，可通用一个线程主函数，void *tfn(void *arg)，使用参数来表示线程编号：int i = (int)arg;</p>
<p>​        哲学家线程根据编号知道自己是第几个哲学家，而后选定锁，锁住，吃饭。否则哲学家thinking。</p>
<p>​                                         A   B   C   D   E</p>
<p>​        5支筷子，在逻辑上形成环： 0   1   2   3   4   分别对应5个哲学家：</p>
<img src="/2019/09/16/Linux系统编程-线程同步/sync2.png"> 

<p>​    所以有：</p>
<p>​        if(i == 4)    </p>
<p>​            left = i, right = 0;</p>
<p>​        else </p>
<p>​            left = i, right = i+1;</p>
<p>​    振荡：如果每个人都攥着自己左手的锁，尝试去拿右手锁，拿不到则将锁释放。过会儿五个人又同时再攥着左手锁尝试拿右手锁，依然拿不到。如此往复形成另外一种极端死锁的现象——振荡。</p>
<p>​    避免振荡现象：只需5个人中，任意一个人，拿锁的方向与其他人相逆即可(如：E，原来：左：4，右：0    现在：左：0， 右：4)。</p>
<p>​    所以以上if else语句应改为：</p>
<p>​        if(i == 4)    </p>
<p>​            left = 0, right = i;</p>
<p>​        else </p>
<p>​            left = i, right = i+1;</p>
<p>​    而后， 首先应让哲学家尝试加左手锁：    </p>
<p>while { </p>
<p>​            pthread_mutex_lock(&amp;m[left]);     如果加锁成功，函数返回再加右手锁，</p>
<p>​                                        如果失败，应立即释放左手锁，等待。</p>
<p>​            若，左右手都加锁成功 –&gt; 吃 –&gt; 吃完 –&gt; 释放锁（应先释放右手、再释放左手，是加锁顺序的逆序）</p>
<p>​        }</p>
<p>​    主线程(main)中，初始化5把锁，销毁5把锁，创建5个线程（并将i传递给线程主函数），回收5个线程。</p>
<p><strong>避免死锁的方法：</strong></p>
<p>​    <strong>1. 当得不到所有所需资源时，放弃已经获得的资源，等待。</strong></p>
<p>​    <strong>2. 保证资源的获取顺序，要求每个线程获取资源的顺序一致。</strong>如：A获取顺序1、2、3；B顺序应也是1、2、3。若B为3、2、1则易出现死锁现象。                                            </p>
<h3 id="多进程版"><a href="#多进程版" class="headerlink" title="多进程版"></a><strong>多进程版</strong></h3><p>相较于多线程需注意问题：</p>
<p>​    需注意如何共享信号量 (注意：坚决不能使用全局变量 sem_t s[5])</p>
<p>实现：</p>
<p>​    main函数中：    </p>
<p>循环 sem_init(&amp;s[i], 0, 1); 将信号量初值设为1，信号量变为互斥锁。</p>
<p>​        循环 sem_destroy(&amp;s[i]);</p>
<p>​        循环 创建 5 个子进程。 if(i &lt; 5) 中完成子进程的代码逻辑。</p>
<p>​        循环 回收 5 个子进程。</p>
<p>​    子进程中：</p>
<p>if(i == 4)  </p>
<p>left = 0, right == 4;</p>
<p>​        else    </p>
<p>left = i, right = i+1;    </p>
<p>​        while (1) {</p>
<p>​            使用 sem_wait(&amp;s[left]) 锁左手，尝试锁右手，若成功 –&gt; 吃； 若不成功 –&gt; 将左手锁释放。</p>
<p>​            吃完后， 先释放右手锁，再释放左手锁。</p>
<p>​        }</p>
<p>【重点注意】：</p>
<p>直接将sem_t s[5]放在全局位置，试图用于子进程间共享是错误的！应将其定义放置与mmap共享映射区中。main中：</p>
<p>sem_t *s = mmap(NULL, sizeof(sem_t) * 5, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON， -1， 0);</p>
<p>​    使用方式：将s当成数组首地址看待，与使用数组s[5]没有差异。</p>
<p>​                                                                            </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-守护进程]]></title>
      <url>/2019/09/15/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="终端："><a href="#终端：" class="headerlink" title="终端："></a><strong>终端：</strong></h2><p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。信号中还讲过，在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl-C表示SIGINT，Ctrl-\表示SIGQUIT。</p>
<p>​    Alt + Ctrl + F1、F2、F3、F4、F5、F6    字符终端   pts (pseudo terminal slave) 指伪终端。</p>
<p>​    Alt + F7        图形终端</p>
<p>​    SSH、Telnet…        网络终端</p>
<h3 id="终端的启动流程："><a href="#终端的启动流程：" class="headerlink" title="终端的启动流程："></a><strong>终端的启动流程：</strong></h3><p>文件与I/O中讲过，每个进程都可以通过一个特殊的设备文件/dev/tty访问它的控制终端。事实上每个终端设备都对应一个不同的设备文件，/dev/tty提供了一个通用的接口，一个进程要访问它的控制终端既可以通过/dev/tty也可以通过该终端设备所对应的设备文件来访问。ttyname函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备而不能是任意文件。</p>
<p>简单来说，一个Linux系统启动，大致经历如下的步骤：</p>
<p>​    init –&gt; fork –&gt; exec –&gt; getty –&gt; 用户输入帐号 –&gt; login –&gt; 输入密码 –&gt; exec –&gt; bash</p>
<p>硬件驱动程序负责读写实际的硬件设备，比如从键盘读入字符和把字符输出到显示器，<strong>线路规程</strong>像一个过滤器，对于某些特殊字符并不是让它直接通过，而是做特殊处理，比如在键盘上按下Ctrl-z，对应的字符并不会被用户程序的read读到，而是被线路规程截获，解释成SIGTSTP信号发给前台进程，通常会使该进程停止。线路规程应该过滤哪些字符和做哪些特殊处理是可以配置的。</p>
<img src="/2019/09/15/Linux系统编程-守护进程/s1.png">

<p>line disciline: 线路规程，用来过滤键盘输入的内容。</p>
<h3 id="ttyname函数"><a href="#ttyname函数" class="headerlink" title="ttyname函数"></a><strong>ttyname函数</strong></h3><p>由文件描述符查出对应的文件名</p>
<p>​    char *ttyname(int fd);    成功：终端名；失败：NULL，设置errno        </p>
<p>下面我们借助ttyname函数，通过实验看一下各种不同的终端所对应的设备文件名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 0: %s\n"</span>, ttyname(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 1: %s\n"</span>, ttyname(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 2: %s\n"</span>, ttyname(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                    </p>
<h3 id="网络终端："><a href="#网络终端：" class="headerlink" title="网络终端："></a><strong>网络终端：</strong></h3><p>虚拟终端或串口终端的数目是有限的，虚拟终端(字符控制终端)一般就是/dev/tty1∼/dev/tty6六个，串口终端的数目也不超过串口的数目。然而网络终端或图形终端窗口的数目却是不受限制的，这是通过伪终端（Pseudo TTY）实现的。一套伪终端由一个<strong>主设备</strong>（PTY Master）和一个<strong>从设备</strong>（PTY Slave）组成。主设备在概念上相当于键盘和显示器，只不过它不是真正的硬件而是一个内核模块，操作它的也不是用户而是另外一个进程。从设备和上面介绍的/dev/tty1这样的终端设备模块类似，只不过它的底层驱动程序不是访问硬件而是访问主设备。网络终端或图形终端窗口的Shell进程以及它启动的其它进程都会认为自己的控制终端是伪终端从设备，例如/dev/pts/0、/dev/pts/1等。下面以telnet为例说明网络登录和使用伪终端的过程。</p>
 <img src="/2019/09/15/Linux系统编程-守护进程/s2.png">

<p>​    TCP/IP协议栈：在数据包上添加报头。</p>
<p>如果telnet客户端和服务器之间的网络延迟较大，我们会观察到按下一个键之后要过几秒钟才能回显到屏幕上。这说明我们每按一个键telnet客户端都会立刻把该字符发送给服务器，然后这个字符经过伪终端主设备和从设备之后被Shell进程读取，同时回显到伪终端从设备，回显的字符再经过伪终端主设备、telnetd服务器和网络发回给telnet客户端，显示给用户看。也许你会觉得吃惊，但真的是这样：每按一个键都要在网络上走个来回！</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a><strong>进程组</strong></h2><h3 id="概念和特性"><a href="#概念和特性" class="headerlink" title="概念和特性"></a><strong>概念和特性</strong></h3><p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</p>
<p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID==第一个进程ID(组长进程)。所以，组长进程标识：其进程组ID==其进程ID </p>
<p>可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。            </p>
<p>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</p>
<p>进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。</p>
<p>一个进程可以为自己或子进程设置进程组ID</p>
<h3 id="进程组操作函数"><a href="#进程组操作函数" class="headerlink" title="进程组操作函数"></a><strong>进程组操作函数</strong></h3><h4 id="getpgrp函数"><a href="#getpgrp函数" class="headerlink" title="getpgrp函数"></a><strong>getpgrp函数</strong></h4><p>获取当前进程的进程组ID</p>
<p>​    pid_t getpgrp(void); 总是返回调用者的进程组ID</p>
<h4 id="getpgid函数"><a href="#getpgid函数" class="headerlink" title="getpgid函数"></a><strong>getpgid函数</strong></h4><p>获取指定进程的进程组ID</p>
<p>​    pid_t getpgid(pid_t pid);     成功：0；失败：-1，设置errno</p>
<p>如果pid = 0，那么该函数作用和getpgrp一样。</p>
<h4 id="setpgid函数"><a href="#setpgid函数" class="headerlink" title="setpgid函数"></a><strong>setpgid函数</strong></h4><p>改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</p>
<p>​    int setpgid(pid_t pid, pid_t pgid);     成功：0；失败：-1，设置errno</p>
<p>将参1对应的进程，加入参2对应的进程组中。</p>
<p>​    注意： </p>
<ol>
<li><p>如改变子进程为新的组，应fork后，exec前。 </p>
</li>
<li><p>权级问题。非root进程只能改变自己创建的子进程，或有权限操作的进程</p>
</li>
</ol>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a><strong>会话</strong></h2><h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a><strong>创建会话</strong></h3><p>创建一个会话需要注意以下6点注意事项：</p>
<ol>
<li><p>调用进程不能是进程组组长，该进程变成新会话首进程(session header)</p>
</li>
<li><p>该进程成为一个新进程组的组长进程。</p>
</li>
<li><p>需有root权限(ubuntu不需要)</p>
</li>
<li><p>新会话丢弃原有的控制终端，该会话没有控制终端</p>
</li>
<li><p>该调用进程是组长进程，则出错返回</p>
</li>
<li><p>建立新会话时，先调用fork, 父进程终止，子进程调用setsid</p>
</li>
</ol>
<h3 id="getsid函数"><a href="#getsid函数" class="headerlink" title="getsid函数"></a><strong>getsid函数</strong></h3><p>获取进程所属的会话ID</p>
<p>pid_t getsid(pid_t pid); 成功：返回调用进程的会话ID；失败：-1，设置errno</p>
<p>pid为0表示察看当前进程session ID</p>
<p>ps ajx命令查看系统中的进程。参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示列出与作业控制相关的信息。</p>
<p>组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</p>
<h3 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a><strong>setsid函数</strong></h3><p>创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。</p>
<p>​    pid_t setsid(void);  成功：返回调用进程的会话ID；失败：-1，设置errno</p>
<p>​    调用了setsid函数的进程，既是新的会长，也是新的组长。                                </p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a><strong>守护进程</strong></h2><p>Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</p>
<p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</p>
<p>​    创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。</p>
<h3 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a><strong>创建守护进程模型</strong></h3><ol>
<li>创建子进程，父进程退出</li>
</ol>
<p>所有工作在子进程中进行形式上脱离了控制终端</p>
<ol start="2">
<li>在子进程中创建新会话</li>
</ol>
<p>　　    setsid()函数</p>
<p>　　    使子进程完全独立出来，脱离控制</p>
<ol start="3">
<li>改变当前目录为根目录</li>
</ol>
<p>　　    chdir()函数</p>
<p>　　    防止占用可卸载的文件系统</p>
<p>　　    也可以换成其它路径</p>
<ol start="4">
<li>重设文件权限掩码</li>
</ol>
<p>　　    umask()函数</p>
<p>　　    防止继承的文件创建屏蔽字拒绝某些权限</p>
<p>　　    增加守护进程灵活性</p>
<ol start="5">
<li>关闭文件描述符</li>
</ol>
<p>　　    继承的打开文件不会用到，浪费系统资源，无法卸载</p>
<ol start="6">
<li><p>开始执行守护进程核心工作</p>
<p>​    守护进程退出处理程序模型                                                                                                                                                                </p>
</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-线程]]></title>
      <url>/2019/09/09/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a><strong>线程概念</strong></h2><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)<br>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。    独居(进程)；合租(线程)。<br>Linux下：    线程：最小的执行单位<br>             进程：最小分配资源单位，可看成是只有一个线程的进程。</p>
<img src="/2019/09/09/Linux系统编程-线程/p1.png" title="This is an example image">

<h2 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a><strong>Linux内核线程实现原理</strong></h2><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p>
<ol>
<li><p>轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</p>
</li>
<li><p>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</p>
</li>
<li><p>进程可以蜕变成线程</p>
</li>
<li><p>线程可看做寄存器和栈的集合</p>
</li>
<li><p>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</p>
</li>
</ol>
<p>察看LWP号：ps –Lf pid 查看指定线程的lwp号。</p>
<img src="/2019/09/09/Linux系统编程-线程/p2.png">

<p>三级映射：进程PCB –&gt; 页目录(可看成数组，首地址位于PCB中) –&gt; 页表 –&gt; 物理页面 –&gt; 内存单元</p>
<p>参考：《Linux内核源代码情景分析》 —-毛德操</p>
<p>对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。</p>
<p>但！线程不同！两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。</p>
<p>​    实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</p>
<p>​    如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。</p>
<p>​    因此：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</p>
<h3 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a><strong>线程共享资源</strong></h3><p>​    1.文件描述符表</p>
<p>​    2.每种信号的处理方式</p>
<p>​    3.当前工作目录</p>
<p>​    4.用户ID和组ID</p>
<p>​    5.内存地址空间 (.text/.data/.bss/heap/共享库)</p>
<h3 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a><strong>线程非共享资源</strong></h3><p>​    1.线程id</p>
<p>​    2.处理器现场和栈指针(内核栈)</p>
<p>​    3.独立的栈空间(用户空间栈)</p>
<p>​    4.errno变量</p>
<p>​    5.信号屏蔽字</p>
<p>​    6.调度优先级</p>
<h3 id="线程优、缺点"><a href="#线程优、缺点" class="headerlink" title="线程优、缺点"></a><strong>线程优、缺点</strong></h3><p>​    优点：    1. 提高程序并发性    2. 开销小    3. 数据通信、共享数据方便</p>
<p>​    缺点：    1. 库函数，不稳定    2. 调试、编写困难、gdb不支持    3. 对信号支持不好</p>
<p>​    优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a><strong>线程控制原语</strong></h2><h3 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a><strong>pthread_self函数</strong></h3><p>获取线程ID。其作用对应进程中 getpid() 函数。</p>
<p>​    pthread_t pthread_self(void);    返回值：成功：0；    失败：无！</p>
<p>​    线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</p>
<p>​    线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)</p>
<p>​    注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</p>
<h3 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a><strong>pthread_create函数</strong></h3><p>创建一个新线程。        其作用，对应进程中fork() 函数。</p>
<p>​    int pthread_create(pthread_t <em>thread, const pthread_attr_t *attr, void *(</em>start_routine) (void *), void *arg);</p>
<p>​    返回值：成功：0；    失败：错误号    —–Linux环境下，所有线程特点，失败均直接返回错误号。</p>
<p>​    参数：    </p>
<p>​    pthread_t：当前Linux中可理解为：typedef  unsigned long int  pthread_t;</p>
<p>​    参数1：传出参数，保存系统为我们分配好的线程ID</p>
<p>​    参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。</p>
<p>​    参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</p>
<p>​    参数4：线程主函数执行期间所使用的参数。</p>
<p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。</p>
<p>pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。</p>
<p>attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。</p>
<p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。                                                                                               </p>
<p>拓展思考：将pthread_create函数参4修改为(void <em>)&amp;i, 将线程主函数内改为 i=</em>((int *)arg) 是否可以？        </p>
<h4 id="线程与共享"><a href="#线程与共享" class="headerlink" title="线程与共享"></a><strong>线程与共享</strong></h4><p><strong>线程间共享全局变量**</strong>！**</p>
<p>【<strong>牢记</strong>】：线程默认共享数据段、代码段等地址空间，常用的是全局变量。而进程不共享全局变量，只能借助mmap。</p>
<h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a><strong>pthread_exit函数</strong></h3><p>将单个线程退出</p>
<p>​    void pthread_exit(void *retval);    参数：retval表示线程退出状态，通常传NULL</p>
<p>思考：使用exit将指定线程退出，可以吗？                                            </p>
<p>​    结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p>
<p>​    在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。</p>
<p>​    所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</p>
<p>另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p>
<p>【练习】：编写多线程程序，总结exit、return、pthread_exit各自退出效果。</p>
<p>​    return：返回到调用者那里去。</p>
<p>​    pthread_exit()：将调用该函数的线程            </p>
<p>​    exit: 将进程退出。</p>
<h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a><strong>pthread_join函数</strong></h3><p>阻塞等待线程退出，获取线程退出状态        其作用，对应进程中 waitpid() 函数。</p>
<p>​    int pthread_join(pthread_t thread, void **retval); 成功：0；失败：错误号</p>
<p>​    参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。</p>
<p>​    对比记忆：</p>
<p>​        进程中：main返回值、exit参数–&gt;int；等待子进程结束 wait 函数参数–&gt;int *</p>
<p>​        线程中：线程主函数返回值、pthread_exit–&gt;void <em>；等待线程结束 pthread_join 函数参数–&gt;void *</em></p>
<p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<ol>
<li><p>如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</p>
</li>
<li><p>如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</p>
</li>
<li><p>如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</p>
</li>
<li><p>如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</p>
</li>
</ol>
<h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a><strong>pthread_detach函数</strong></h3><p>实现线程分离</p>
<p>​    int pthread_detach(pthread_t thread);    成功：0；失败：错误号</p>
<p>​    线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p>
<p>​    进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p>
<p>​    也可使用 pthread_create函数参2(线程属性)来设置线程分离。</p>
<p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，<strong>这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</strong>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
<h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a><strong>pthread_cancel函数</strong></h3><p>杀死(取消)线程            其作用，对应进程中 kill() 函数。</p>
<p>​    int pthread_cancel(pthread_t thread);    成功：0；失败：错误号</p>
<p>​    【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</p>
<p>​    类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p>
<p>​    取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</p>
<p>可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</p>
<p>被取消的线程，    退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：<strong>#define PTHREAD_CANCELED ((void *) -1)**</strong>。**因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</p>
<h4 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a><strong>终止线程方式</strong></h4><p>总结：终止某个线程而不终止整个进程，有三种方法：</p>
<ol>
<li><p>从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。</p>
</li>
<li><p>一个线程可以调用pthread_cancel终止同一进程中的另一个线程。</p>
</li>
<li><p>线程可以调用pthread_exit终止自己。</p>
</li>
</ol>
<h3 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a><strong>pthread_equal函数</strong></h3><p>比较两个线程ID是否相等。</p>
<p>​    int pthread_equal(pthread_t t1, pthread_t t2);</p>
<p>​    有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</p>
<h3 id="控制原语对比"><a href="#控制原语对比" class="headerlink" title="控制原语对比"></a><strong>控制原语对比</strong></h3><p>​    进程            线程</p>
<p>​    fork            pthread_create</p>
<p>​    exit            pthread_exit</p>
<p>​    wait            pthread_join</p>
<p>​    kill            pthread_cancel</p>
<p>​    getpid        pthread_self        命名空间</p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a><strong>线程属性</strong></h2><p>本节作为指引性介绍，linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p>
<p>typedef struct</p>
<p>{</p>
<p>int                     etachstate;     //线程的分离状态</p>
<p>int                     schedpolicy;     //线程调度策略</p>
<p>struct sched_param    schedparam;     //线程的调度参数</p>
<p>int                     inheritsched;     //线程的继承性</p>
<p>int                     scope;         //线程的作用域</p>
<p>size_t                 guardsize;     //线程栈末尾的警戒缓冲区大小</p>
<p>int                    stackaddr_set; //线程的栈设置</p>
<p>void*                 stackaddr;     //线程栈的位置</p>
<p>size_t                 stacksize;     //线程栈的大小</p>
<p>} pthread_attr_t; </p>
<p>主要结构体成员：</p>
<p>​    1. 线程分离状态</p>
<p>​    2. 线程栈大小（默认平均分配）</p>
<p>​    3. 线程栈警戒缓冲区大小（位于栈末尾）                                    参 APUE.12.3 线程属性</p>
<p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。</p>
<p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p>
<h3 id="线程属性初始化"><a href="#线程属性初始化" class="headerlink" title="线程属性初始化"></a><strong>线程属性初始化</strong></h3><p>注意：应先初始化线程属性，再pthread_create创建线程</p>
<p>初始化线程属性</p>
<p>int pthread_attr_init(pthread_attr_t *attr); 成功：0；失败：错误号</p>
<p>销毁线程属性所占用的资源</p>
<p>int pthread_attr_destroy(pthread_attr_t *attr); 成功：0；失败：错误号</p>
<h3 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a><strong>线程的分离状态</strong></h3><p>线程的分离状态决定一个线程以什么样的方式来终止自己。</p>
<p>非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p>
<p>分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</p>
<p>线程分离状态的函数：</p>
<p>设置线程属性，分离or非分离</p>
<p>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); </p>
<p>获取程属性，分离or非分离</p>
<pre><code>int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate); </code></pre><p>​    参数：    attr：已初始化的线程属性</p>
<p>detachstate：    PTHREAD_CREATE_DETACHED（分离线程）</p>
<p>PTHREAD _CREATE_JOINABLE（非分离线程）</p>
<p>这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<h3 id="线程的栈地址"><a href="#线程的栈地址" class="headerlink" title="线程的栈地址"></a><strong>线程的栈地址</strong></h3><p>POSIX.1定义了两个常量_POSIX_THREAD_ATTR_STACKADDR 和_POSIX_THREAD_ATTR_STACKSIZE检测系统是否支持栈属性。也可以给sysconf函数传递_SC_THREAD_ATTR_STACKADDR或 _SC_THREAD_ATTR_STACKSIZE来进行检测。</p>
<p>当进程栈地址空间不够用时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分别设置和获取线程的栈地址。</p>
<p>int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize); 成功：0；失败：错误号</p>
<p>int pthread_attr_getstack(pthread_attr_t <em>attr, void *</em>stackaddr, size_t *stacksize); 成功：0；失败：错误号</p>
<p>参数：    attr：指向一个线程属性的指针</p>
<p>stackaddr：返回获取的栈地址</p>
<p>stacksize：返回获取的栈大小</p>
<h3 id="线程的栈大小"><a href="#线程的栈大小" class="headerlink" title="线程的栈大小"></a><strong>线程的栈大小</strong></h3><p>当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</p>
<p>函数pthread_attr_getstacksize和 pthread_attr_setstacksize提供设置。</p>
<p>int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); 成功：0；失败：错误号</p>
<p>int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize); 成功：0；失败：错误号</p>
<p>参数：    attr：指向一个线程属性的指针</p>
<p>stacksize：返回线程的堆栈大小</p>
<h3 id="线程属性控制示例"><a href="#线程属性控制示例" class="headerlink" title="线程属性控制示例"></a><strong>线程属性控制示例</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">#define SIZE 0x100000</span><br><span class="line"></span><br><span class="line">void *th_fun(void *arg)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	while (1) </span><br><span class="line"></span><br><span class="line">​		sleep(1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	pthread_t tid;</span><br><span class="line"></span><br><span class="line">​	int err, detachstate, i = 1;</span><br><span class="line"></span><br><span class="line">​	pthread_attr_t attr;</span><br><span class="line"></span><br><span class="line">​	size_t stacksize;</span><br><span class="line"></span><br><span class="line">​	void *stackaddr;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​	pthread_attr_init(&amp;attr);		</span><br><span class="line"></span><br><span class="line">​	pthread_attr_getstack(&amp;attr, &amp;stackaddr, &amp;stacksize);</span><br><span class="line"></span><br><span class="line">​	pthread_attr_getdetachstate(&amp;attr, &amp;detachstate);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​	if (detachstate == PTHREAD_CREATE_DETACHED)</span><br><span class="line"></span><br><span class="line">​		printf(&quot;thread detached\n&quot;);</span><br><span class="line"></span><br><span class="line">​	else if (detachstate == PTHREAD_CREATE_JOINABLE)</span><br><span class="line"></span><br><span class="line">​		printf(&quot;thread join\n&quot;);</span><br><span class="line"></span><br><span class="line">​	else</span><br><span class="line"></span><br><span class="line">​		printf(&quot;thread unknown\n&quot;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​	pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​	while (1) &#123;</span><br><span class="line"></span><br><span class="line">​		stackaddr = malloc(SIZE);</span><br><span class="line"></span><br><span class="line">​		if (stackaddr == NULL) &#123;</span><br><span class="line"></span><br><span class="line">​			perror(&quot;malloc&quot;);</span><br><span class="line"></span><br><span class="line">​			exit(1);</span><br><span class="line"></span><br><span class="line">​		&#125;</span><br><span class="line"></span><br><span class="line">​		stacksize = SIZE;</span><br><span class="line"></span><br><span class="line">​		pthread_attr_setstack(&amp;attr, stackaddr, stacksize);</span><br><span class="line"></span><br><span class="line">​		err = pthread_create(&amp;tid, &amp;attr, th_fun, NULL);</span><br><span class="line"></span><br><span class="line">​		if (err != 0) &#123;</span><br><span class="line"></span><br><span class="line">​			printf(&quot;%s\n&quot;, strerror(err));</span><br><span class="line"></span><br><span class="line">​			exit(1);</span><br><span class="line"></span><br><span class="line">​		&#125;</span><br><span class="line"></span><br><span class="line">​		printf(&quot;%d\n&quot;, i++);</span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">​	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a><strong>NPTL</strong></h2><p>1.察看当前pthread库版本getconf GNU_LIBPTHREAD_VERSION</p>
<p>2.NPTL实现机制(POSIX)，Native POSIX Thread Library</p>
<p>3.使用线程库时gcc指定 –lpthread</p>
<h2 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a><strong>线程使用注意事项</strong></h2><ol>
<li><p>主线程退出其他线程不退出，主线程应调用pthread_exit</p>
</li>
<li><p>避免僵尸线程</p>
</li>
</ol>
<p>pthread_join</p>
<p>pthread_detach</p>
<p>pthread_create指定分离属性</p>
<p>被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</p>
<ol start="3">
<li><p>malloc和mmap申请的内存可以被其他线程释放 </p>
</li>
<li><p>应避免在多线程模型中调用fork除非，马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</p>
</li>
<li><p>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</p>
</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-信号]]></title>
      <url>/2019/09/08/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a><strong>信号的概念</strong></h2><p>信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪……他们都有共性：1. 简单 2. 不能携带大量信息 3. 满足某个特设条件才发送。</p>
<p>​    信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p>
<p>​    Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p>
<h3 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a><strong>信号的机制</strong></h3><p>​    A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</p>
<p><strong>信号的特质</strong>：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p>​    <strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p>
<h3 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a><strong>与信号相关的事件和状态</strong></h3><p>​    <strong>产生信号</strong>: </p>
<ol>
<li><p>按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</p>
</li>
<li><p>系统调用产生，如：kill、raise、abort</p>
</li>
<li><p>软件条件产生，如：定时器alarm</p>
</li>
<li><p>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</p>
</li>
<li><p>命令产生，如：kill命令</p>
</li>
</ol>
<p>​    <strong>递达</strong>：递送并且到达进程。</p>
<p>​    <strong>未决</strong>：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 </p>
<p>​    <strong>信号的处理方式:</strong> </p>
<ol>
<li><p>执行默认动作 </p>
</li>
<li><p>忽略(丢弃) </p>
</li>
<li><p>捕捉(调用户处理函数)</p>
</li>
</ol>
<p>​    Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</p>
<p>​    <strong>阻塞信号集(信号屏蔽字)</strong>： 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)</p>
<p><strong>未决信号集</strong>: </p>
<ol>
<li><p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 </p>
</li>
<li><p>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。    </p>
</li>
</ol>
<h3 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a><strong>信号的编号</strong></h3><p>可以使用kill –l命令查看当前系统可使用的信号有哪些。</p>
<p>1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL         5) SIGTRAP</p>
<p> 6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1</p>
<p>11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM</p>
<p>16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP</p>
<p>21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ</p>
<p>26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR</p>
<p>31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3</p>
<p>38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8</p>
<p>43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13</p>
<p>48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12</p>
<p>53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7</p>
<p>58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2</p>
<p>63) SIGRTMAX-1    64) SIGRTMAX</p>
<p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</p>
<h3 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h3><p>与变量三要素类似的，每个信号也有其必备4要素，分别是：</p>
<ol>
<li>编号 2. 名称 3. 事件 4. 默认处理动作 </li>
</ol>
<p>可通过man 7 signal查看帮助文档获取。也可查看/usr/src/linux-headers-3.16.0-30/arch/s390/include/uapi/asm/signal.h</p>
<p>Signal         Value     Action   Comment</p>
<p>────────────────────────────────────────────</p>
<p>SIGHUP          1       Term    Hangup detected on controlling terminal or death of controlling process</p>
<p>SIGINT           2       Term    Interrupt from keyboard</p>
<p>SIGQUIT          3       Core    Quit from keyboard</p>
<p>SIGILL            4       Core    Illegal Instruction</p>
<p>SIGFPE           8       Core    Floating point exception</p>
<p>SIGKILL           9       Term    Kill signal</p>
<p>SIGSEGV         11      Core    Invalid memory reference</p>
<p>SIGPIPE       13      Term    Broken pipe: write to pipe with no readers</p>
<p>SIGALRM        14      Term    Timer signal from alarm(2)</p>
<p>SIGTERM         15      Term    Termination signal</p>
<p>SIGUSR1   30,10,16    Term    User-defined signal 1</p>
<p>SIGUSR2   31,12,17    Term    User-defined signal 2</p>
<p>SIGCHLD   20,17,18    Ign     Child stopped or terminated</p>
<p>SIGCONT   19,18,25    Cont    Continue if stopped</p>
<p>SIGSTOP   17,19,23    Stop    Stop process</p>
<p>SIGTSTP   18,20,24    Stop    Stop typed at terminal</p>
<p>SIGTTIN   21,21,26    Stop    Terminal input for background process</p>
<p>SIGTTOU   22,22,27   Stop    Terminal output for background process</p>
<p>The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.       </p>
<p>在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。</p>
<p>不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。</p>
<p>​    默认动作：</p>
<p>​        Term：终止进程</p>
<p>​        Ign： 忽略信号 (默认即时对该种信号忽略操作)</p>
<p>​        Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)</p>
<p>​        Stop：停止（暂停）进程</p>
<p>​        Cont：继续运行进程</p>
<p>   注意从man 7 signal帮助文档中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</p>
<p>   这里特别强调了<strong>9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<p>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！</p>
<h3 id="Linux常规信号一览表"><a href="#Linux常规信号一览表" class="headerlink" title="Linux常规信号一览表"></a><strong>Linux常规信号一览表</strong></h3><p>1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程</p>
<p>2) SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</p>
<p>3) SIGQUIT：当用户按下&lt;ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</p>
<p>4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件</p>
<p>5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。</p>
<p>6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。</p>
<p>7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</p>
<p>8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。</p>
<p>9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</p>
<p>10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p>
<p>11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。</p>
<p>12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p>
<p>13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。</p>
<p>14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。</p>
<p>15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。</p>
<p>16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</p>
<p>17) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。</p>
<p>18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。</p>
<p>19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</p>
<p>20) SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</p>
<p>21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</p>
<p>22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</p>
<p>23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</p>
<p>24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。</p>
<p>25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</p>
<p>26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。</p>
<p>27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。</p>
<p>28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</p>
<p>29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。</p>
<p>30) SIGPWR：关机。默认动作为终止进程。</p>
<p>31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。</p>
<p>34) SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。</p>
<h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a><strong>信号的产生</strong></h2><h3 id="终端按键产生信号"><a href="#终端按键产生信号" class="headerlink" title="终端按键产生信号"></a><strong>终端按键产生信号</strong></h3><p>​    Ctrl + c  → 2) SIGINT（终止/中断）     “INT” —-Interrupt</p>
<p>​    Ctrl + z  → 20) SIGTSTP（暂停/停止）  “T” —-Terminal 终端。</p>
<p>​    Ctrl + \  → 3) SIGQUIT（退出）    </p>
<h3 id="硬件异常产生信号"><a href="#硬件异常产生信号" class="headerlink" title="硬件异常产生信号"></a><strong>硬件异常产生信号</strong></h3><p>​    除0操作   → 8) SIGFPE (浮点数例外)    “F” —–float 浮点数。</p>
<p>​    非法访问内存  → 11) SIGSEGV (段错误)</p>
<p>​    总线错误  → 7) SIGBUS    </p>
<h3 id="kill函数-命令产生信号"><a href="#kill函数-命令产生信号" class="headerlink" title="kill函数/命令产生信号"></a><strong>kill函数/命令产生信号</strong></h3><p>kill命令产生信号：kill -SIGKILL pid</p>
<p>kill函数：给指定进程发送指定信号(不一定杀死)</p>
<p>​    int kill(pid_t pid, int sig);     成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno</p>
<p>​    sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</p>
<p>​    pid &gt; 0:  发送信号给指定的进程。</p>
<p>​    pid = 0:  发送信号给 与调用kill函数进程属于同一进程组的所有进程。</p>
<p>​    pid &lt; 0:  取|pid|发给对应进程组。</p>
<p>​    pid = -1：发送给进程有权限发送的系统中所有进程。</p>
<p>​    进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 kill -9 (root用户的pid)  是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID == 接收者实际或有效用户ID</p>
<h3 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a><strong>raise和abort函数</strong></h3><p>​    raise 函数：给当前进程发送指定信号(自己给自己发)    raise(signo) == kill(getpid(), signo);</p>
<p>​        int raise(int sig); 成功：0，失败非0值</p>
<p>​    abort 函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件</p>
<p>​        void abort(void); 该函数无返回</p>
<h3 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a><strong>软件条件产生信号</strong></h3><h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a><strong>alarm函数</strong></h4><p>设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。</p>
<p><strong>每个进程都有且只有唯一个定时器。</strong></p>
<p>unsigned int alarm(unsigned int seconds); 返回0或剩余的秒数，无失败。</p>
<p>​    常用：取消定时器alarm(0)，返回旧闹钟余下秒数。</p>
<p>​    例：alarm(5) → 3sec → alarm(4) → 5sec → alarm(5) → alarm(0)</p>
<p>​    定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。</p>
<h4 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a><strong>setitimer函数</strong></h4><p>​    设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。</p>
<p>​    int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);    成功：0；失败：-1，设置errno</p>
<p>​    参数：which：指定定时方式</p>
<p>​        ① 自然定时：ITIMER_REAL → 14）SIGLARM                         计算自然时间</p>
<p>​        ② 虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM       只计算进程占用cpu的时间</p>
<p>​        ③ 运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF         计算占用cpu及执行系统调用的时间</p>
<h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a><strong>信号集操作函数</strong></h2><p>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。</p>
<h3 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a><strong>信号集设定</strong></h3><p>​    sigset_t  set;        // typedef unsigned long sigset_t; </p>
<p>​    int sigemptyset(sigset_t *set);            将某个信号集清0                 成功：0；失败：-1</p>
<p>​    int sigfillset(sigset_t *set);                将某个信号集置1                  成功：0；失败：-1</p>
<p>​    int sigaddset(sigset_t *set, int signum);        将某个信号加入信号集          成功：0；失败：-1</p>
<p>​    int sigdelset(sigset_t *set, int signum);        将某个信号清出信号集           成功：0；失败：-1</p>
<p>​    int sigismember(const sigset_t *set, int signum);判断某个信号是否在信号集中    返回值：在集合：1；不在：0；出错：-1  </p>
<p>​    sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p>
<p>​    对比认知select 函数。</p>
<h3 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a><strong>sigprocmask函数</strong></h3><p>用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)</p>
<p>​    <strong>严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</strong></p>
<p>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);    成功：0；失败：-1，设置errno</p>
<p>参数：</p>
<p>​        set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。</p>
<p>​        oldset：传出参数，保存旧的信号屏蔽集。</p>
<p>​        how参数取值：    假设当前的信号屏蔽字为mask</p>
<ol>
<li><p>SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask|set</p>
</li>
<li><p>SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set</p>
</li>
<li><p>SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p>
</li>
</ol>
<h3 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a><strong>sigpending函数</strong></h3><p>读取当前进程的<strong>未决</strong>信号集</p>
<p>int sigpending(sigset_t *set);    set传出参数。   返回值：成功：0；失败：-1，设置errno</p>
<h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a><strong>信号捕捉</strong></h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a><strong>signal函数</strong></h3><p>注册一个信号捕捉函数：</p>
<p>typedef void (*sighandler_t)(int);</p>
<p>sighandler_t signal(int signum, sighandler_t handler);</p>
<p>​    该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</p>
<p>​    void (<em>signal(int signum, void (</em>sighandler_t)(int))) (int);</p>
<p>​    能看出这个函数代表什么意思吗？  注意多在复杂结构中使用typedef。</p>
<h3 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a><strong>sigaction函数</strong></h3><p>修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数）</p>
<p>​    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);  成功：0；失败：-1，设置errno</p>
<p>参数：</p>
<p>act：传入参数，新的处理方式。</p>
<p>​        oldact：传出参数，旧的处理方式。                                                </p>
<h4 id="struct-sigaction结构体"><a href="#struct-sigaction结构体" class="headerlink" title="struct sigaction结构体"></a><strong>struct sigaction结构体</strong></h4><p>​    struct sigaction {</p>
<p>​        void     (*sa_handler)(int);</p>
<p>​        void     (*sa_sigaction)(int, siginfo_t *, void *);</p>
<p>​        sigset_t   sa_mask; </p>
<p>​        int       sa_flags; </p>
<p>​        void     (*sa_restorer)(void);</p>
<p>​    };</p>
<p>​    sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)</p>
<p>​    sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用)  </p>
<p>重点掌握：</p>
<p>​    ① sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</p>
<p>​    ② sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</p>
<p>​    ③ sa_flags：通常设置为0，表使用默认属性。    </p>
<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a><strong>信号捕捉特性</strong></h4><ol>
<li><p>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。</p>
</li>
<li><p>XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。</p>
</li>
<li><p>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</p>
</li>
</ol>
<h3 id="内核实现信号捕捉过程："><a href="#内核实现信号捕捉过程：" class="headerlink" title="内核实现信号捕捉过程："></a><strong>内核实现信号捕捉过程：</strong></h3> <img src="/2019/09/08/Linux系统编程-信号/sig1.png">

<h2 id="竞态条件-时序竞态-："><a href="#竞态条件-时序竞态-：" class="headerlink" title="竞态条件(时序竞态)："></a><strong>竞态条件(时序竞态)：</strong></h2><h3 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a><strong>pause函数</strong></h3><p>​    调用该函数可以造成进程主动挂起，等待信号唤醒。调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。</p>
<p>​    int pause(void);    返回值：-1 并设置errno为EINTR</p>
<p>​    返回值：</p>
<p>​        ① 如果信号的默认处理动作是终止进程，则进程终止，pause函数么有机会返回。</p>
<p>​        ② 如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。</p>
<p>​        ③ 如果信号的处理动作是捕捉，则【调用完信号处理函数之后，pause返回-1】</p>
<p>errno设置为EINTR，表示“被信号中断”。想想我们还有哪个函数只有出错返回值。</p>
<p>​        ④ pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。</p>
<h3 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a><strong>时序竞态</strong></h3><h4 id="前导例"><a href="#前导例" class="headerlink" title="前导例"></a><strong>前导例</strong></h4><p>设想如下场景：</p>
<p>​    欲睡觉，定闹钟10分钟，希望10分钟后闹铃将自己唤醒。</p>
<p>​    正常：定时，睡觉，10分钟后被闹钟唤醒。</p>
<p>​    异常：闹钟定好后，被唤走，外出劳动，20分钟后劳动结束。回来继续睡觉计划，但劳动期间闹钟已经响过，不会再将我唤醒。</p>
<h4 id="时序问题分析"><a href="#时序问题分析" class="headerlink" title="时序问题分析"></a><strong>时序问题分析</strong></h4><p>回顾，借助pause和alarm实现的mysleep函数。设想如下时序：</p>
<p>​    1. 注册SIGALRM信号处理函数     （sigaction…)</p>
<p>​    2. 调用alarm(1) 函数设定闹钟1秒。</p>
<p>​    3. 函数调用刚结束，开始倒计时1秒。当前进程失去cpu，内核调度优先级高的进程(有多个)取代当前进程。当前进程无法获得cpu，进入就绪态等待cpu。</p>
<p>​    4. 1秒后，闹钟超时，内核向当前进程发送SIGALRM信号(自然定时法，与进程状态无关)，高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决)</p>
<p>​    5. 优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。SIGALRM信号递达，信号设置捕捉，执行处理函数sig_alarm。</p>
<p>​    6. 信号处理函数执行结束，返回当前进程主控流程，pause()被调用挂起等待。（欲等待alarm函数发送的SIGALRM信号将自己唤醒）</p>
<p>​    7. SIGALRM信号已经处理完毕，pause不会等到。</p>
<h4 id="解决时序问题"><a href="#解决时序问题" class="headerlink" title="解决时序问题"></a><strong>解决时序问题</strong></h4><p>可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这个两个操作间隙失去cpu资源。除非将这两步骤合并成一个“原子操作”。sigsuspend函数具备这个功能。在对时序要求严格的场合下都应该使用sigsuspend替换pause。     </p>
<p>​    int sigsuspend(const sigset_t *mask);    挂起等待信号。</p>
<p>sigsuspend函数调用期间，进程信号屏蔽字由其<strong>参数mask</strong>指定。</p>
<p>​    可将某个信号（如SIGALRM）从临时信号屏蔽字mask中删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，sigsuspend函数返回后仍然屏蔽该信号。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</p>
<p>不可靠由其实现原理所致。信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</p>
<p>这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
<h3 id="全局变量异步I-O"><a href="#全局变量异步I-O" class="headerlink" title="全局变量异步I/O"></a><strong>全局变量异步I/O</strong></h3><p>   分析如下父子进程交替数数程序。当捕捉函数里面的sleep取消，程序即会出现问题。请分析原因</p>
<p>​    示例中，通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。</p>
<p>​    问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。</p>
<p>如何解决该问题呢？可以使用后续课程讲到的“锁”机制。当操作全局变量的时候，通过加锁、解锁来解决该问题。</p>
<p>现阶段，我们在编程期间如若使用全局变量，应在主观上注意<strong>全局变量的异步IO</strong>可能造成的问题。</p>
<h3 id="可-不可重入函数"><a href="#可-不可重入函数" class="headerlink" title="可/不可重入函数"></a><strong>可/不可重入函数</strong></h3><p>​    一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称之为“重入”。根据函数实现的方法可分为“可重入函数”和“不可重入函数”两种。看如下时序。</p>
 <img src="/2019/09/08/Linux系统编程-信号/sig2.png">

<p>​    显然，insert函数是不可重入函数，重入调用，会导致意外结果呈现。究其原因，是该函数内部实现使用了全局变量。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ol>
<li><p>定义可重入函数，函数内不能含有全局变量及static变量，不能使用malloc、free</p>
</li>
<li><p>信号捕捉函数应设计为可重入函数</p>
</li>
<li><p>信号处理程序可以调用的可重入函数可参阅man 7 signal </p>
</li>
<li><p>没有包含在上述列表中的函数大多是不可重入的，其原因为：</p>
<p>a) 使用静态数据结构</p>
<p>b) 调用了malloc或free</p>
<p>c) 是标准I/O函数</p>
</li>
</ol>
<h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a><strong>SIGCHLD信号</strong></h2><h3 id="SIGCHLD的产生条件"><a href="#SIGCHLD的产生条件" class="headerlink" title="SIGCHLD的产生条件"></a><strong>SIGCHLD的产生条件</strong></h3><p>子进程终止时</p>
<p>子进程接收到SIGSTOP信号停止时</p>
<p>子进程处在停止态，接受到SIGCONT后唤醒时</p>
<h3 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a><strong>借助SIGCHLD信号回收子进程</strong></h3><p>子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</p>
<h3 id="子进程结束status处理方式"><a href="#子进程结束status处理方式" class="headerlink" title="子进程结束status处理方式"></a><strong>子进程结束status处理方式</strong></h3><p>pid_t waitpid(pid_t pid, int *status, int options)</p>
<p>options</p>
<p>WNOHANG</p>
<p>没有子进程结束，立即返回</p>
<p>WUNTRACED</p>
<p>如果子进程由于被停止产生的SIGCHLD，waitpid则立即返回</p>
<p>WCONTINUED</p>
<p>如果子进程由于被SIGCONT唤醒而产生的SIGCHLD，waitpid则立即返回</p>
<p>获取status</p>
<p>WIFEXITED(status)</p>
<p>子进程正常exit终止，返回真</p>
<p>WEXITSTATUS(status)返回子进程正常退出值</p>
<p>WIFSIGNALED(status)</p>
<p>子进程被信号终止，返回真</p>
<p>WTERMSIG(status)返回终止子进程的信号值</p>
<p>WIFSTOPPED(status)</p>
<p>子进程被停止，返回真</p>
<p>WSTOPSIG(status)返回停止子进程的信号值</p>
<p>WIFCONTINUED(status)</p>
<h3 id="SIGCHLD信号注意问题"><a href="#SIGCHLD信号注意问题" class="headerlink" title="SIGCHLD信号注意问题"></a><strong>SIGCHLD信号注意问题</strong></h3><ol>
<li><p>子进程继承了父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集spending。</p>
</li>
<li><p>注意注册信号捕捉函数的位置。</p>
</li>
<li><p>应该在fork之前，阻塞SIGCHLD信号。注册完捕捉函数后解除阻塞。</p>
</li>
</ol>
<h2 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a><strong>信号传参</strong></h2><h3 id="发送信号传参"><a href="#发送信号传参" class="headerlink" title="发送信号传参"></a><strong>发送信号传参</strong></h3><p>sigqueue函数对应kill函数，但可在向指定进程发送信号的同时携带参数</p>
<p>int sigqueue(pid_t pid, int sig, const union sigval value);成功：0；失败：-1，设置errno</p>
<p>​           union sigval {</p>
<p>​               int   sival_int;</p>
<p>​               void *sival_ptr;</p>
<p>​           };</p>
<p>​    向指定进程发送指定信号的同时，携带数据。但，如传地址，需注意，不同进程之间虚拟地址空间各自独立，将当前进程地址传递给另一进程没有实际意义。</p>
<h3 id="捕捉函数传参"><a href="#捕捉函数传参" class="headerlink" title="捕捉函数传参"></a><strong>捕捉函数传参</strong></h3><p>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</p>
<p>​           struct sigaction {</p>
<p>​               void     (*sa_handler)(int);</p>
<p>​               void     (*sa_sigaction)(int, siginfo_t *, void *);</p>
<p>​               sigset_t   sa_mask;</p>
<p>​               int       sa_flags;</p>
<p>​               void     (*sa_restorer)(void);</p>
<p>​           };</p>
<p>​    当注册信号捕捉函数，希望获取更多信号相关信息，不应使用sa_handler而应该使用sa_sigaction。但此时的<strong>sa**</strong>_flags必须指定为SA_SIGINFO**。siginfo_t是一个成员十分丰富的结构体类型，可以携带各种与信号相关的数据。</p>
<h2 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a><strong>中断系统调用</strong></h2><p>系统调用可分为两类：慢速系统调用和其他系统调用。</p>
<ol>
<li><p>慢速系统调用：可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，read、write、pause、wait…</p>
</li>
<li><p>其他系统调用：getpid、getppid、fork…</p>
</li>
</ol>
<p>结合pause，回顾慢速系统调用：</p>
<p>​    慢速系统调用被中断的相关行为，实际上就是pause的行为： 如，read</p>
<p>​        ① 想中断pause，信号不能被屏蔽。</p>
<p>​        ② 信号的处理方式必须是捕捉 (默认、忽略都不可以)</p>
<p>​        ③ 中断后返回-1， 设置errno为EINTR(表“被信号中断”)</p>
<p>可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRURT不重启。 SA_RESTART重启。</p>
<p>扩展了解：</p>
<p>​    sa_flags还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-进程间通信]]></title>
      <url>/2019/09/06/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<h2 id="IPC方法"><a href="#IPC方法" class="headerlink" title="IPC方法"></a><strong>IPC方法</strong></h2><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。</p>
<img src="/2019/09/06/Linux系统编程-进程间通信/ipc1.png"> 

<p>​    在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p>
<p>​    ① 管道 (使用最简单)</p>
<p>​    ② 信号 (开销最小)</p>
<p>​    ③ 共享映射区 (无血缘关系)</p>
<p>​    ④ 本地套接字 (最稳定)</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h2><h3 id="管道的概念："><a href="#管道的概念：" class="headerlink" title="管道的概念："></a><strong>管道的概念：</strong></h3><p>​    管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<ol>
<li><p>其本质是一个伪文件(实为内核缓冲区) </p>
</li>
<li><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p>
</li>
<li><p>规定数据从管道的写端流入管道，从读端流出。</p>
</li>
</ol>
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>管道的局限性：</p>
<p>① 数据自己读不能自己写。</p>
<p>​        ② 数据一旦被读走，便不在管道中存在，不可反复读取。</p>
<p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p>
<p>④ 只能在有公共祖先的进程间使用管道。</p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a><strong>pipe函数</strong></h3><p>创建管道</p>
<p>​    int pipe(int pipefd[2]);        成功：0；失败：-1，设置errno</p>
<p>函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</p>
<p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：</p>
<img src="/2019/09/06/Linux系统编程-进程间通信/ipc2.png">  

<ol>
<li><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</p>
</li>
<li><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</p>
</li>
<li><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p>
</li>
</ol>
<h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a><strong>管道的读写行为</strong></h3><p>​    使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：</p>
<ol>
<li><p>如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</p>
</li>
<li><p>如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</p>
</li>
<li><p>如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</p>
</li>
<li><p>如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>
</li>
</ol>
<p>总结：</p>
<p>① 读管道：    1. 管道中有数据，read返回实际读到的字节数。</p>
<p>​                        2. 管道中无数据：</p>
<p>​                             (1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)</p>
<p>​                             (2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</p>
<p>② 写管道：    1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</p>
<p>​                        2. 管道读端没有全部关闭： </p>
<p>​                            (1) 管道已满，write阻塞。</p>
<p>​                            (2) 管道未满，write将数据写入，并返回实际写入的字节数。</p>
<p>​    程序执行，发现程序执行结束，shell还在阻塞等待用户输入。这是因为，shell → fork → ./pipe1， 程序pipe1的子进程将stdin重定向给管道，父进程执行的ls会将结果集通过管道写给子进程。若父进程在子进程打印wc的结果到屏幕之前被shell调用wait回收，shell就会先输出$提示符。</p>
<h3 id="管道缓冲区大小"><a href="#管道缓冲区大小" class="headerlink" title="管道缓冲区大小"></a><strong>管道缓冲区大小</strong></h3><p>​    可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p>
<p>​        pipe size            (512 bytes, -p) 8</p>
<p>​    也可以使用fpathconf函数，借助参数    选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p>
<p>​        long fpathconf(int fd, int name);    成功：返回管道的大小    失败：-1，设置errno</p>
<h3 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a><strong>管道的优劣</strong></h3><p>​    优点：简单，相比信号，套接字实现进程间通信，简单很多。</p>
<p>​    缺点：1. 只能单向通信，双向通信需建立两个管道。</p>
<p>​          2. 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a><strong>FIFO</strong></h3><p>FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。</p>
<p>​    FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。</p>
<p>创建方式：</p>
<ol>
<li><p>命令：mkfifo 管道名</p>
</li>
<li><p>库函数：int mkfifo(const char *pathname,  mode_t mode);  成功：0； 失败：-1</p>
</li>
</ol>
<p>​    一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。</p>
<p>​                                                                                    </p>
<h2 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a><strong>共享存储映射</strong></h2><h3 id="文件进程间通信"><a href="#文件进程间通信" class="headerlink" title="文件进程间通信"></a><strong>文件进程间通信</strong></h3><p>使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。</p>
<h3 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a><strong>存储映射I/O</strong></h3><p>​    存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。</p>
<p>​    使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</p>
<img src="/2019/09/06/Linux系统编程-进程间通信/ipc3.png">  

<h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a><strong>mmap函数</strong></h4><p>void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); </p>
<p>返回：成功：返回创建的映射区首地址；<strong>失败：MAP_FAILED宏</strong></p>
<p>参数：    </p>
<p>​    addr:     建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</p>
<p>​    length： 欲创建映射区的大小</p>
<p>​    prot：    映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</p>
<p>​    flags：    标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)</p>
<p>​              MAP_SHARED:  会将映射区所做的操作反映到物理设备（磁盘）上。</p>
<p>​              MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。</p>
<p>​    fd：     用来建立映射区的文件描述符</p>
<p>​    offset：     映射文件的偏移(4k的整数倍)</p>
<h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a><strong>munmap函数</strong></h4><p>​    同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。</p>
<p>int munmap(void *addr, size_t length);    成功：0； 失败：-1</p>
<p>​    借鉴malloc和free函数原型，尝试装自定义函数smalloc，sfree来完成映射区的建立和释放。思考函数接口该如何设计？</p>
<p>​                                                                                        </p>
<h4 id="mmap注意事项"><a href="#mmap注意事项" class="headerlink" title="mmap注意事项"></a><strong>mmap注意事项</strong></h4><p>思考：</p>
<ol>
<li><p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p>
</li>
<li><p>如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？</p>
</li>
<li><p>文件描述符先关闭，对mmap映射有没有影响？</p>
</li>
<li><p>如果文件偏移量为1000会怎样？</p>
</li>
<li><p>对mem越界操作会怎样？</p>
</li>
<li><p>如果mem++，munmap可否成功？</p>
</li>
<li><p>mmap什么情况下会调用失败？</p>
</li>
<li><p>如果不检测mmap的返回值，会怎样？</p>
</li>
</ol>
<p><strong>总结</strong>：使用mmap时务必注意以下事项:</p>
<ol>
<li><p>创建映射区的过程中，隐含着一次对映射文件的读操作。</p>
</li>
<li><p>当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</p>
</li>
<li><p>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</p>
</li>
<li><p>特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！    mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</p>
</li>
<li><p>munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</p>
</li>
<li><p>如果文件偏移量必须为4K的整数倍</p>
</li>
<li><p>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</p>
</li>
</ol>
<h3 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a><strong>mmap父子进程通信</strong></h3><p>​    父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：</p>
<p>​    MAP_PRIVATE:  (私有映射)  父子进程各自独占映射区；</p>
<p>​    MAP_SHARED:  (共享映射)  父子进程共享映射区；</p>
<p>   父进程创建映射区，然后fork子进程，子进程修改映射区内容，而后，父进程读取映射区内容，查验是否共享?                                                                                 </p>
<p>结论：父子进程共享：1. 打开的文件  2. mmap建立的映射区(但必须要使用MAP_SHARED)</p>
<h3 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a><strong>匿名映射</strong></h3><p>​    通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。</p>
<p>使用MAP_ANONYMOUS (或MAP_ANON)， 如: </p>
<p>​    int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0); </p>
<p>​    “4”随意举例，该位置表大小，可依实际需要填写。</p>
<p>需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。</p>
<p>​    ① fd = open(“/dev/zero”, O_RDWR);</p>
<p>​    ② p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</p>
<h3 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a><strong>mmap无血缘关系进程间通信</strong></h3><p>实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用MAP_SHARED了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-进程]]></title>
      <url>/2019/09/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a><strong>程序和进程</strong></h2><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p>
<p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p>
<p>程序 → 剧本(纸)        进程 → 戏(舞台、演员、灯光、道具…)</p>
<p>同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)</p>
<p>如：同时开两个终端。各自都有一个bash但彼此ID不同。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p>
<p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p>
<img src="/2019/09/05/Linux系统编程-进程/fork1.png" title="This is an example image">

<h3 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a><strong>单道程序设计</strong></h3><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><strong>多道程序设计</strong></h3><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p>
<p><strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p>
<h2 id="CPU和MMU"><a href="#CPU和MMU" class="headerlink" title="CPU和MMU"></a><strong>CPU和MMU</strong></h2><img src="/2019/09/05/Linux系统编程-进程/fork2.png" title="This is an example image">

<img src="/2019/09/05/Linux系统编程-进程/fork3.png" title="This is an example image">

<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a><strong>进程控制块PCB</strong></h2><p>我们知道，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h文件中可以查看struct task_struct 结构体定义。其内部成员有很多，我们重点掌握以下部分即可：</p>
<p>* 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</p>
<p>* 进程的状态，有就绪、运行、挂起、停止等状态。</p>
<p>* 进程切换时需要保存和恢复的一些CPU寄存器。</p>
<p>* 描述虚拟地址空间的信息。</p>
<p>* 描述控制终端的信息。</p>
<p>* 当前工作目录（Current Working Directory）。</p>
<p>* umask掩码。</p>
<p>* 文件描述符表，包含很多指向file结构体的指针。</p>
<p>* 和信号相关的信息。</p>
<p>* 用户id和组id。</p>
<p>* 会话（Session）和进程组。</p>
<p>* 进程可以使用的资源上限（Resource Limit）。</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h2><p>进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。</p>
<img src="/2019/09/05/Linux系统编程-进程/fork4.png">

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a><strong>环境变量</strong></h2><p>按照惯例，环境变量字符串都是name=value这样的形式，大多数name由大写字母加下划线组成，一般把name的部分叫做环境变量，value的部分则是环境变量的值。环境变量定义了进程的运行环境，一些比较重要的环境变量的含义如下：</p>
<h4 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a><strong>PATH</strong></h4><p>可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值：</p>
<p>$ echo $PATH</p>
<h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a><strong>SHELL</strong></h4><p>当前Shell，它的值通常是/bin/bash。</p>
<h4 id="TERM"><a href="#TERM" class="headerlink" title="TERM"></a><strong>TERM</strong></h4><p>当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。</p>
<h4 id="LANG"><a href="#LANG" class="headerlink" title="LANG"></a><strong>LANG</strong></h4><p>语言和locale，决定了字符编码以及时间、货币等信息的显示格式。</p>
<h4 id="HOME"><a href="#HOME" class="headerlink" title="HOME"></a><strong>HOME</strong></h4><p>当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。</p>
<h4 id="getenv函数"><a href="#getenv函数" class="headerlink" title="getenv函数"></a><strong>getenv函数</strong></h4><p>获取环境变量值</p>
<p>​    char *getenv(const char *name);     成功：返回环境变量的值；失败：NULL (name不存在)</p>
<h4 id="setenv函数"><a href="#setenv函数" class="headerlink" title="setenv函数"></a><strong>setenv函数</strong></h4><p>设置环境变量的值    </p>
<p>​    int setenv(const char *name, const char *value, int overwrite);      成功：0；失败：-1</p>
<p>​    参数overwrite取值：    1：覆盖原环境变量 </p>
<p>0：不覆盖。(该参数常用于设置新环境变量，如：ABC = haha-day-night)</p>
<h4 id="unsetenv函数"><a href="#unsetenv函数" class="headerlink" title="unsetenv函数"></a><strong>unsetenv函数</strong></h4><p>删除环境变量name的定义</p>
<p>​    int unsetenv(const char *name);     成功：0；失败：-1 </p>
<p>​    注意事项：name不存在仍返回0(成功)，当name命名为”ABC=”时则会出错。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><strong>进程控制</strong></h2><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><strong>fork函数</strong></h4><p>创建一个子进程。</p>
<p>pid_t fork(void);    失败返回-1；成功返回：① 父进程返回子进程的ID(非负)    ②子进程返回 0 </p>
<p>pid_t类型表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1)</p>
<p>​    注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。</p>
<img src="/2019/09/05/Linux系统编程-进程/fork6.png">

<p>从上图我们可以很清晰的看到，当n为3时候，循环创建了(2^n)-1个子进程，而不是N的子进程。需要在循环的过程，保证子进程不再执行fork ，因此当(fork() == 0)时，子进程应该立即break;才正确。</p>
<h4 id="循环创建n个子进程"><a href="#循环创建n个子进程" class="headerlink" title="循环创建n个子进程"></a><strong>循环创建n个子进程</strong></h4><p>一次fork函数调用可以创建一个子进程。那么创建N个子进程应该怎样实现呢？</p>
<p>简单想，for(i = 0; i &lt; n; i++) { fork() } 即可。但这样创建的是N个子进程吗？</p>
<h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a><strong>getpid函数</strong></h4><p>获取当前进程ID</p>
<p>​    pid_t getpid(void);        </p>
<h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a><strong>getppid函数</strong></h4><p>​    获取当前进程的父进程ID</p>
<p>​        pid_t getppid(void);</p>
<p>区分一个函数是“系统函数”还是“库函数”依据：</p>
<p>​    ① 是否访问内核数据结构</p>
<p>​    ② 是否访问外部硬件资源        二者有任一 → 系统函数；二者均无 → 库函数</p>
<h4 id="getuid函数"><a href="#getuid函数" class="headerlink" title="getuid函数"></a><strong>getuid函数</strong></h4><p>获取当前进程实际用户ID</p>
<p>uid_t getuid(void);</p>
<p>​    获取当前进程有效用户ID</p>
<p>uid_t geteuid(void);</p>
<h4 id="getgid函数"><a href="#getgid函数" class="headerlink" title="getgid函数"></a><strong>getgid函数</strong></h4><p>​    获取当前进程使用用户组ID</p>
<p>gid_t getgid(void);</p>
<p>​    获取当前进程有效用户组ID</p>
<p>gid_t getegid(void);</p>
<h2 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a><strong>进程共享</strong></h2><p>父子进程之间在fork后。有哪些相同，那些相异之处呢？</p>
<p>刚fork之后：</p>
<p>父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…</p>
<p>父子不同处: 1.进程ID   2.fork返回值   3.父进程ID    4.进程运行时间    5.闹钟(定时器)   6.未决信号集</p>
<p>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</p>
<p>当然不是!父子进程间遵循<strong>读时共享写时复制</strong>的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。   </p>
<p>重点注意！躲避父子进程共享全局变量的知识误区！</p>
<p>【重点】：父子进程共享：1. 文件描述符(打开文件的结构体)  2. mmap建立的映射区 (进程间通信详解)</p>
<p>特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。</p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><strong>gdb调试</strong></h3><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p>
<p>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</p>
<p>set follow-fork-mode parent 设置跟踪父进程。</p>
<p>注意，一定要在fork函数调用之前设置才有效。</p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a><strong>exec函数族</strong></h2><p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</p>
<p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</p>
<p>其实有六种以exec开头的函数，统称exec函数：</p>
<p>int execl(const char *path, const char *arg, …);</p>
<p>int execlp(const char *file, const char *arg, …);</p>
<p>int execle(const char *path, const char *arg, …, char *const envp[]);</p>
<p>int execv(const char *path, char *const argv[]);</p>
<p>int execvp(const char *file, char *const argv[]);</p>
<p>int execve(const char *path, char *const argv[], char *const envp[]);</p>
<h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h4><p>加载一个进程，借助PATH环境变量         </p>
<p>int execlp(const char *file, const char *arg, …);        成功：无返回；失败：-1</p>
<p>​    参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</p>
<p>​    该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。</p>
<h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h4><p>加载一个进程， 通过 路径+程序名 来加载。 </p>
<p>​    int execl(const char *path, const char *arg, …);        成功：无返回；失败：-1</p>
<p>对比execlp，如加载”ls”命令带有-l，-F参数</p>
<p>execlp(“ls”, “ls”, “-l”, “-F”, NULL);         使用程序名在PATH中搜索。</p>
<p>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL);    使用参数1给出的绝对路径搜索。</p>
<h4 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h4><p>加载一个进程，使用自定义环境变量env</p>
<p>int execvp(const char *file, const char *argv[]);</p>
<p>变参形式： ①… ② argv[]  (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …)) </p>
<p>变参终止条件：① NULL结尾 ② 固参指定</p>
<p>execvp与execlp参数形式不同，原理一致。</p>
<h4 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a><strong>exec函数族一般规律</strong></h4><p>exec函数一旦调用成功即执行新的程序，不返回。<strong>只有失败才返回，错误值-1</strong>。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</p>
<p>l (list)            命令行参数列表</p>
<p>p (path)            搜素file时使用path变量</p>
<p>v (vector)            使用命令行参数数组</p>
<p>e (environment)    使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p>
<p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示。</p>
<img src="/2019/09/05/Linux系统编程-进程/fork5.png">

<h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a><strong>回收子进程</strong></h2><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a><strong>孤儿进程</strong></h4><p>​    孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a><strong>僵尸进程</strong></h4><p>僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。  </p>
<p>特别注意，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。思考！用什么办法可清除掉僵尸进程呢？</p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a><strong>wait函数</strong></h4><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p>
<p>① 阻塞等待子进程退出 </p>
<p>② 回收子进程残留资源 </p>
<p>③ 获取子进程结束状态(退出原因)。</p>
<p>​    <strong>pid_t wait(int *status);</strong>     成功：清理掉的子进程ID；失败：-1 (没有子进程)</p>
<p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p>
<p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</p>
<p> \1.  WIFEXITED(status) 为非0    → 进程正常结束</p>
<p>​    WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</p>
<p> \2.     WIFSIGNALED(status) 为非0 → 进程异常终止</p>
<p>​    WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p>
<p>*3.     WIFSTOPPED(status) 为非0 → 进程处于暂停状态</p>
<p>​    WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。</p>
<p>​    WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行</p>
<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h4><p>作用同wait，但可指定pid进程清理，可以不阻塞。</p>
<p>​    <strong>pid_t waitpid(pid_t pid, int *status, in options);</strong>    成功：返回清理掉的子进程ID；失败：-1(无子进程)</p>
<p>特殊参数和返回情况：</p>
<p>参数pid： </p>
<p><strong>&gt; 0 回收指定ID的子进程</strong>    </p>
<p><strong>-1 回收任意子进程（相当于wait）</strong></p>
<p>0 回收和当前调用waitpid一个组的所有子进程</p>
<p>​        &lt; -1 回收指定进程组内的任意子进程</p>
<p>返回0：参3为WNOHANG，且子进程正在运行。</p>
<p>注意：<strong>一次wait或waitpid调用只能清理一个子进程</strong>，清理多个子进程应使用循环。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
