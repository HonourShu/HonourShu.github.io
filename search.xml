<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Linux系统编程-守护进程]]></title>
      <url>/2019/09/15/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="终端："><a href="#终端：" class="headerlink" title="终端："></a><strong>终端：</strong></h2><p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。信号中还讲过，在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl-C表示SIGINT，Ctrl-\表示SIGQUIT。</p>
<p>​    Alt + Ctrl + F1、F2、F3、F4、F5、F6    字符终端   pts (pseudo terminal slave) 指伪终端。</p>
<p>​    Alt + F7        图形终端</p>
<p>​    SSH、Telnet…        网络终端</p>
<h3 id="终端的启动流程："><a href="#终端的启动流程：" class="headerlink" title="终端的启动流程："></a><strong>终端的启动流程：</strong></h3><p>文件与I/O中讲过，每个进程都可以通过一个特殊的设备文件/dev/tty访问它的控制终端。事实上每个终端设备都对应一个不同的设备文件，/dev/tty提供了一个通用的接口，一个进程要访问它的控制终端既可以通过/dev/tty也可以通过该终端设备所对应的设备文件来访问。ttyname函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备而不能是任意文件。</p>
<p>简单来说，一个Linux系统启动，大致经历如下的步骤：</p>
<p>​    init –&gt; fork –&gt; exec –&gt; getty –&gt; 用户输入帐号 –&gt; login –&gt; 输入密码 –&gt; exec –&gt; bash</p>
<p>硬件驱动程序负责读写实际的硬件设备，比如从键盘读入字符和把字符输出到显示器，<strong>线路规程</strong>像一个过滤器，对于某些特殊字符并不是让它直接通过，而是做特殊处理，比如在键盘上按下Ctrl-z，对应的字符并不会被用户程序的read读到，而是被线路规程截获，解释成SIGTSTP信号发给前台进程，通常会使该进程停止。线路规程应该过滤哪些字符和做哪些特殊处理是可以配置的。</p>
<img src="/2019/09/15/Linux系统编程-守护进程/s1.png">

<p>line disciline: 线路规程，用来过滤键盘输入的内容。</p>
<h3 id="ttyname函数"><a href="#ttyname函数" class="headerlink" title="ttyname函数"></a><strong>ttyname函数</strong></h3><p>由文件描述符查出对应的文件名</p>
<p>​    char *ttyname(int fd);    成功：终端名；失败：NULL，设置errno        </p>
<p>下面我们借助ttyname函数，通过实验看一下各种不同的终端所对应的设备文件名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 0: %s\n"</span>, ttyname(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 1: %s\n"</span>, ttyname(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 2: %s\n"</span>, ttyname(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                    </p>
<h3 id="网络终端："><a href="#网络终端：" class="headerlink" title="网络终端："></a><strong>网络终端：</strong></h3><p>虚拟终端或串口终端的数目是有限的，虚拟终端(字符控制终端)一般就是/dev/tty1∼/dev/tty6六个，串口终端的数目也不超过串口的数目。然而网络终端或图形终端窗口的数目却是不受限制的，这是通过伪终端（Pseudo TTY）实现的。一套伪终端由一个<strong>主设备</strong>（PTY Master）和一个<strong>从设备</strong>（PTY Slave）组成。主设备在概念上相当于键盘和显示器，只不过它不是真正的硬件而是一个内核模块，操作它的也不是用户而是另外一个进程。从设备和上面介绍的/dev/tty1这样的终端设备模块类似，只不过它的底层驱动程序不是访问硬件而是访问主设备。网络终端或图形终端窗口的Shell进程以及它启动的其它进程都会认为自己的控制终端是伪终端从设备，例如/dev/pts/0、/dev/pts/1等。下面以telnet为例说明网络登录和使用伪终端的过程。</p>
 <img src="/2019/09/15/Linux系统编程-守护进程/s2.png">

<p>​    TCP/IP协议栈：在数据包上添加报头。</p>
<p>如果telnet客户端和服务器之间的网络延迟较大，我们会观察到按下一个键之后要过几秒钟才能回显到屏幕上。这说明我们每按一个键telnet客户端都会立刻把该字符发送给服务器，然后这个字符经过伪终端主设备和从设备之后被Shell进程读取，同时回显到伪终端从设备，回显的字符再经过伪终端主设备、telnetd服务器和网络发回给telnet客户端，显示给用户看。也许你会觉得吃惊，但真的是这样：每按一个键都要在网络上走个来回！</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a><strong>进程组</strong></h2><h3 id="概念和特性"><a href="#概念和特性" class="headerlink" title="概念和特性"></a><strong>概念和特性</strong></h3><p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</p>
<p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID==第一个进程ID(组长进程)。所以，组长进程标识：其进程组ID==其进程ID </p>
<p>可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。            </p>
<p>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</p>
<p>进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。</p>
<p>一个进程可以为自己或子进程设置进程组ID</p>
<h3 id="进程组操作函数"><a href="#进程组操作函数" class="headerlink" title="进程组操作函数"></a><strong>进程组操作函数</strong></h3><h4 id="getpgrp函数"><a href="#getpgrp函数" class="headerlink" title="getpgrp函数"></a><strong>getpgrp函数</strong></h4><p>获取当前进程的进程组ID</p>
<p>​    pid_t getpgrp(void); 总是返回调用者的进程组ID</p>
<h4 id="getpgid函数"><a href="#getpgid函数" class="headerlink" title="getpgid函数"></a><strong>getpgid函数</strong></h4><p>获取指定进程的进程组ID</p>
<p>​    pid_t getpgid(pid_t pid);     成功：0；失败：-1，设置errno</p>
<p>如果pid = 0，那么该函数作用和getpgrp一样。</p>
<h4 id="setpgid函数"><a href="#setpgid函数" class="headerlink" title="setpgid函数"></a><strong>setpgid函数</strong></h4><p>改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</p>
<p>​    int setpgid(pid_t pid, pid_t pgid);     成功：0；失败：-1，设置errno</p>
<p>将参1对应的进程，加入参2对应的进程组中。</p>
<p>​    注意： </p>
<ol>
<li><p>如改变子进程为新的组，应fork后，exec前。 </p>
</li>
<li><p>权级问题。非root进程只能改变自己创建的子进程，或有权限操作的进程</p>
</li>
</ol>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a><strong>会话</strong></h2><h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a><strong>创建会话</strong></h3><p>创建一个会话需要注意以下6点注意事项：</p>
<ol>
<li><p>调用进程不能是进程组组长，该进程变成新会话首进程(session header)</p>
</li>
<li><p>该进程成为一个新进程组的组长进程。</p>
</li>
<li><p>需有root权限(ubuntu不需要)</p>
</li>
<li><p>新会话丢弃原有的控制终端，该会话没有控制终端</p>
</li>
<li><p>该调用进程是组长进程，则出错返回</p>
</li>
<li><p>建立新会话时，先调用fork, 父进程终止，子进程调用setsid</p>
</li>
</ol>
<h3 id="getsid函数"><a href="#getsid函数" class="headerlink" title="getsid函数"></a><strong>getsid函数</strong></h3><p>获取进程所属的会话ID</p>
<p>pid_t getsid(pid_t pid); 成功：返回调用进程的会话ID；失败：-1，设置errno</p>
<p>pid为0表示察看当前进程session ID</p>
<p>ps ajx命令查看系统中的进程。参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示列出与作业控制相关的信息。</p>
<p>组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</p>
<h3 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a><strong>setsid函数</strong></h3><p>创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。</p>
<p>​    pid_t setsid(void);  成功：返回调用进程的会话ID；失败：-1，设置errno</p>
<p>​    调用了setsid函数的进程，既是新的会长，也是新的组长。                                </p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a><strong>守护进程</strong></h2><p>Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</p>
<p>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</p>
<p>​    创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。</p>
<h3 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a><strong>创建守护进程模型</strong></h3><ol>
<li>创建子进程，父进程退出</li>
</ol>
<p>所有工作在子进程中进行形式上脱离了控制终端</p>
<ol start="2">
<li>在子进程中创建新会话</li>
</ol>
<p>　　    setsid()函数</p>
<p>　　    使子进程完全独立出来，脱离控制</p>
<ol start="3">
<li>改变当前目录为根目录</li>
</ol>
<p>　　    chdir()函数</p>
<p>　　    防止占用可卸载的文件系统</p>
<p>　　    也可以换成其它路径</p>
<ol start="4">
<li>重设文件权限掩码</li>
</ol>
<p>　　    umask()函数</p>
<p>　　    防止继承的文件创建屏蔽字拒绝某些权限</p>
<p>　　    增加守护进程灵活性</p>
<ol start="5">
<li>关闭文件描述符</li>
</ol>
<p>　　    继承的打开文件不会用到，浪费系统资源，无法卸载</p>
<ol start="6">
<li><p>开始执行守护进程核心工作</p>
<p>​    守护进程退出处理程序模型                                                                                                                                                                </p>
</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-线程]]></title>
      <url>/2019/09/09/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a><strong>线程概念</strong></h2><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)<br>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。    独居(进程)；合租(线程)。<br>Linux下：    线程：最小的执行单位<br>             进程：最小分配资源单位，可看成是只有一个线程的进程。</p>
<img src="/2019/09/09/Linux系统编程-线程/p1.png" title="This is an example image">

<h2 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a><strong>Linux内核线程实现原理</strong></h2><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p>
<ol>
<li><p>轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</p>
</li>
<li><p>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</p>
</li>
<li><p>进程可以蜕变成线程</p>
</li>
<li><p>线程可看做寄存器和栈的集合</p>
</li>
<li><p>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</p>
</li>
</ol>
<p>察看LWP号：ps –Lf pid 查看指定线程的lwp号。</p>
<img src="/2019/09/09/Linux系统编程-线程/p2.png">]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-信号]]></title>
      <url>/2019/09/08/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a><strong>信号的概念</strong></h2><p>信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪……他们都有共性：1. 简单 2. 不能携带大量信息 3. 满足某个特设条件才发送。</p>
<p>​    信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</p>
<p>​    Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p>
<h3 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a><strong>信号的机制</strong></h3><p>​    A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</p>
<p><strong>信号的特质</strong>：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</p>
<p>​    <strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p>
<h3 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a><strong>与信号相关的事件和状态</strong></h3><p>​    <strong>产生信号</strong>: </p>
<ol>
<li><p>按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</p>
</li>
<li><p>系统调用产生，如：kill、raise、abort</p>
</li>
<li><p>软件条件产生，如：定时器alarm</p>
</li>
<li><p>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</p>
</li>
<li><p>命令产生，如：kill命令</p>
</li>
</ol>
<p>​    <strong>递达</strong>：递送并且到达进程。</p>
<p>​    <strong>未决</strong>：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 </p>
<p>​    <strong>信号的处理方式:</strong> </p>
<ol>
<li><p>执行默认动作 </p>
</li>
<li><p>忽略(丢弃) </p>
</li>
<li><p>捕捉(调用户处理函数)</p>
</li>
</ol>
<p>​    Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</p>
<p>​    <strong>阻塞信号集(信号屏蔽字)</strong>： 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)</p>
<p><strong>未决信号集</strong>: </p>
<ol>
<li><p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 </p>
</li>
<li><p>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。    </p>
</li>
</ol>
<h3 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a><strong>信号的编号</strong></h3><p>可以使用kill –l命令查看当前系统可使用的信号有哪些。</p>
<p>1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL         5) SIGTRAP</p>
<p> 6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1</p>
<p>11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM</p>
<p>16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP</p>
<p>21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ</p>
<p>26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR</p>
<p>31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3</p>
<p>38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8</p>
<p>43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13</p>
<p>48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12</p>
<p>53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7</p>
<p>58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2</p>
<p>63) SIGRTMAX-1    64) SIGRTMAX</p>
<p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</p>
<h3 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h3><p>与变量三要素类似的，每个信号也有其必备4要素，分别是：</p>
<ol>
<li>编号 2. 名称 3. 事件 4. 默认处理动作 </li>
</ol>
<p>可通过man 7 signal查看帮助文档获取。也可查看/usr/src/linux-headers-3.16.0-30/arch/s390/include/uapi/asm/signal.h</p>
<p>Signal         Value     Action   Comment</p>
<p>────────────────────────────────────────────</p>
<p>SIGHUP          1       Term    Hangup detected on controlling terminal or death of controlling process</p>
<p>SIGINT           2       Term    Interrupt from keyboard</p>
<p>SIGQUIT          3       Core    Quit from keyboard</p>
<p>SIGILL            4       Core    Illegal Instruction</p>
<p>SIGFPE           8       Core    Floating point exception</p>
<p>SIGKILL           9       Term    Kill signal</p>
<p>SIGSEGV         11      Core    Invalid memory reference</p>
<p>SIGPIPE       13      Term    Broken pipe: write to pipe with no readers</p>
<p>SIGALRM        14      Term    Timer signal from alarm(2)</p>
<p>SIGTERM         15      Term    Termination signal</p>
<p>SIGUSR1   30,10,16    Term    User-defined signal 1</p>
<p>SIGUSR2   31,12,17    Term    User-defined signal 2</p>
<p>SIGCHLD   20,17,18    Ign     Child stopped or terminated</p>
<p>SIGCONT   19,18,25    Cont    Continue if stopped</p>
<p>SIGSTOP   17,19,23    Stop    Stop process</p>
<p>SIGTSTP   18,20,24    Stop    Stop typed at terminal</p>
<p>SIGTTIN   21,21,26    Stop    Terminal input for background process</p>
<p>SIGTTOU   22,22,27   Stop    Terminal output for background process</p>
<p>The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.       </p>
<p>在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。</p>
<p>不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。</p>
<p>​    默认动作：</p>
<p>​        Term：终止进程</p>
<p>​        Ign： 忽略信号 (默认即时对该种信号忽略操作)</p>
<p>​        Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试)</p>
<p>​        Stop：停止（暂停）进程</p>
<p>​        Cont：继续运行进程</p>
<p>   注意从man 7 signal帮助文档中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</p>
<p>   这里特别强调了<strong>9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</strong></p>
<p>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！</p>
<h3 id="Linux常规信号一览表"><a href="#Linux常规信号一览表" class="headerlink" title="Linux常规信号一览表"></a><strong>Linux常规信号一览表</strong></h3><p>1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程</p>
<p>2) SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</p>
<p>3) SIGQUIT：当用户按下&lt;ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</p>
<p>4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件</p>
<p>5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。</p>
<p>6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。</p>
<p>7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</p>
<p>8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。</p>
<p>9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</p>
<p>10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p>
<p>11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。</p>
<p>12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</p>
<p>13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。</p>
<p>14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。</p>
<p>15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。</p>
<p>16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</p>
<p>17) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。</p>
<p>18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。</p>
<p>19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</p>
<p>20) SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</p>
<p>21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</p>
<p>22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</p>
<p>23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</p>
<p>24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。</p>
<p>25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</p>
<p>26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。</p>
<p>27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。</p>
<p>28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</p>
<p>29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。</p>
<p>30) SIGPWR：关机。默认动作为终止进程。</p>
<p>31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。</p>
<p>34) SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。</p>
<h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a><strong>信号的产生</strong></h2><h3 id="终端按键产生信号"><a href="#终端按键产生信号" class="headerlink" title="终端按键产生信号"></a><strong>终端按键产生信号</strong></h3><p>​    Ctrl + c  → 2) SIGINT（终止/中断）     “INT” —-Interrupt</p>
<p>​    Ctrl + z  → 20) SIGTSTP（暂停/停止）  “T” —-Terminal 终端。</p>
<p>​    Ctrl + \  → 3) SIGQUIT（退出）    </p>
<h3 id="硬件异常产生信号"><a href="#硬件异常产生信号" class="headerlink" title="硬件异常产生信号"></a><strong>硬件异常产生信号</strong></h3><p>​    除0操作   → 8) SIGFPE (浮点数例外)    “F” —–float 浮点数。</p>
<p>​    非法访问内存  → 11) SIGSEGV (段错误)</p>
<p>​    总线错误  → 7) SIGBUS    </p>
<h3 id="kill函数-命令产生信号"><a href="#kill函数-命令产生信号" class="headerlink" title="kill函数/命令产生信号"></a><strong>kill函数/命令产生信号</strong></h3><p>kill命令产生信号：kill -SIGKILL pid</p>
<p>kill函数：给指定进程发送指定信号(不一定杀死)</p>
<p>​    int kill(pid_t pid, int sig);     成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno</p>
<p>​    sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</p>
<p>​    pid &gt; 0:  发送信号给指定的进程。</p>
<p>​    pid = 0:  发送信号给 与调用kill函数进程属于同一进程组的所有进程。</p>
<p>​    pid &lt; 0:  取|pid|发给对应进程组。</p>
<p>​    pid = -1：发送给进程有权限发送的系统中所有进程。</p>
<p>​    进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</p>
<p>权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 kill -9 (root用户的pid)  是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID == 接收者实际或有效用户ID</p>
<h3 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a><strong>raise和abort函数</strong></h3><p>​    raise 函数：给当前进程发送指定信号(自己给自己发)    raise(signo) == kill(getpid(), signo);</p>
<p>​        int raise(int sig); 成功：0，失败非0值</p>
<p>​    abort 函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件</p>
<p>​        void abort(void); 该函数无返回</p>
<h3 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a><strong>软件条件产生信号</strong></h3><h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a><strong>alarm函数</strong></h4><p>设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。</p>
<p><strong>每个进程都有且只有唯一个定时器。</strong></p>
<p>unsigned int alarm(unsigned int seconds); 返回0或剩余的秒数，无失败。</p>
<p>​    常用：取消定时器alarm(0)，返回旧闹钟余下秒数。</p>
<p>​    例：alarm(5) → 3sec → alarm(4) → 5sec → alarm(5) → alarm(0)</p>
<p>​    定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸…无论进程处于何种状态，alarm都计时。</p>
<h4 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a><strong>setitimer函数</strong></h4><p>​    设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。</p>
<p>​    int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);    成功：0；失败：-1，设置errno</p>
<p>​    参数：which：指定定时方式</p>
<p>​        ① 自然定时：ITIMER_REAL → 14）SIGLARM                         计算自然时间</p>
<p>​        ② 虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM       只计算进程占用cpu的时间</p>
<p>​        ③ 运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF         计算占用cpu及执行系统调用的时间</p>
<h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a><strong>信号集操作函数</strong></h2><p>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。</p>
<h3 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a><strong>信号集设定</strong></h3><p>​    sigset_t  set;        // typedef unsigned long sigset_t; </p>
<p>​    int sigemptyset(sigset_t *set);            将某个信号集清0                 成功：0；失败：-1</p>
<p>​    int sigfillset(sigset_t *set);                将某个信号集置1                  成功：0；失败：-1</p>
<p>​    int sigaddset(sigset_t *set, int signum);        将某个信号加入信号集          成功：0；失败：-1</p>
<p>​    int sigdelset(sigset_t *set, int signum);        将某个信号清出信号集           成功：0；失败：-1</p>
<p>​    int sigismember(const sigset_t *set, int signum);判断某个信号是否在信号集中    返回值：在集合：1；不在：0；出错：-1  </p>
<p>​    sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</p>
<p>​    对比认知select 函数。</p>
<h3 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a><strong>sigprocmask函数</strong></h3><p>用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)</p>
<p>​    <strong>严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</strong></p>
<p>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);    成功：0；失败：-1，设置errno</p>
<p>参数：</p>
<p>​        set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。</p>
<p>​        oldset：传出参数，保存旧的信号屏蔽集。</p>
<p>​        how参数取值：    假设当前的信号屏蔽字为mask</p>
<ol>
<li><p>SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask = mask|set</p>
</li>
<li><p>SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set</p>
</li>
<li><p>SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask = set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p>
</li>
</ol>
<h3 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a><strong>sigpending函数</strong></h3><p>读取当前进程的<strong>未决</strong>信号集</p>
<p>int sigpending(sigset_t *set);    set传出参数。   返回值：成功：0；失败：-1，设置errno</p>
<h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a><strong>信号捕捉</strong></h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a><strong>signal函数</strong></h3><p>注册一个信号捕捉函数：</p>
<p>typedef void (*sighandler_t)(int);</p>
<p>sighandler_t signal(int signum, sighandler_t handler);</p>
<p>​    该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</p>
<p>​    void (<em>signal(int signum, void (</em>sighandler_t)(int))) (int);</p>
<p>​    能看出这个函数代表什么意思吗？  注意多在复杂结构中使用typedef。</p>
<h3 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a><strong>sigaction函数</strong></h3><p>修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数）</p>
<p>​    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);  成功：0；失败：-1，设置errno</p>
<p>参数：</p>
<p>act：传入参数，新的处理方式。</p>
<p>​        oldact：传出参数，旧的处理方式。                                                </p>
<h4 id="struct-sigaction结构体"><a href="#struct-sigaction结构体" class="headerlink" title="struct sigaction结构体"></a><strong>struct sigaction结构体</strong></h4><p>​    struct sigaction {</p>
<p>​        void     (*sa_handler)(int);</p>
<p>​        void     (*sa_sigaction)(int, siginfo_t *, void *);</p>
<p>​        sigset_t   sa_mask; </p>
<p>​        int       sa_flags; </p>
<p>​        void     (*sa_restorer)(void);</p>
<p>​    };</p>
<p>​    sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)</p>
<p>​    sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用)  </p>
<p>重点掌握：</p>
<p>​    ① sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</p>
<p>​    ② sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</p>
<p>​    ③ sa_flags：通常设置为0，表使用默认属性。    </p>
<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a><strong>信号捕捉特性</strong></h4><ol>
<li><p>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。</p>
</li>
<li><p>XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。</p>
</li>
<li><p>阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</p>
</li>
</ol>
<h3 id="内核实现信号捕捉过程："><a href="#内核实现信号捕捉过程：" class="headerlink" title="内核实现信号捕捉过程："></a><strong>内核实现信号捕捉过程：</strong></h3> <img src="/2019/09/08/Linux系统编程-信号/sig1.png">

<h2 id="竞态条件-时序竞态-："><a href="#竞态条件-时序竞态-：" class="headerlink" title="竞态条件(时序竞态)："></a><strong>竞态条件(时序竞态)：</strong></h2><h3 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a><strong>pause函数</strong></h3><p>​    调用该函数可以造成进程主动挂起，等待信号唤醒。调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。</p>
<p>​    int pause(void);    返回值：-1 并设置errno为EINTR</p>
<p>​    返回值：</p>
<p>​        ① 如果信号的默认处理动作是终止进程，则进程终止，pause函数么有机会返回。</p>
<p>​        ② 如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。</p>
<p>​        ③ 如果信号的处理动作是捕捉，则【调用完信号处理函数之后，pause返回-1】</p>
<p>errno设置为EINTR，表示“被信号中断”。想想我们还有哪个函数只有出错返回值。</p>
<p>​        ④ pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。</p>
<h3 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a><strong>时序竞态</strong></h3><h4 id="前导例"><a href="#前导例" class="headerlink" title="前导例"></a><strong>前导例</strong></h4><p>设想如下场景：</p>
<p>​    欲睡觉，定闹钟10分钟，希望10分钟后闹铃将自己唤醒。</p>
<p>​    正常：定时，睡觉，10分钟后被闹钟唤醒。</p>
<p>​    异常：闹钟定好后，被唤走，外出劳动，20分钟后劳动结束。回来继续睡觉计划，但劳动期间闹钟已经响过，不会再将我唤醒。</p>
<h4 id="时序问题分析"><a href="#时序问题分析" class="headerlink" title="时序问题分析"></a><strong>时序问题分析</strong></h4><p>回顾，借助pause和alarm实现的mysleep函数。设想如下时序：</p>
<p>​    1. 注册SIGALRM信号处理函数     （sigaction…)</p>
<p>​    2. 调用alarm(1) 函数设定闹钟1秒。</p>
<p>​    3. 函数调用刚结束，开始倒计时1秒。当前进程失去cpu，内核调度优先级高的进程(有多个)取代当前进程。当前进程无法获得cpu，进入就绪态等待cpu。</p>
<p>​    4. 1秒后，闹钟超时，内核向当前进程发送SIGALRM信号(自然定时法，与进程状态无关)，高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决)</p>
<p>​    5. 优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。SIGALRM信号递达，信号设置捕捉，执行处理函数sig_alarm。</p>
<p>​    6. 信号处理函数执行结束，返回当前进程主控流程，pause()被调用挂起等待。（欲等待alarm函数发送的SIGALRM信号将自己唤醒）</p>
<p>​    7. SIGALRM信号已经处理完毕，pause不会等到。</p>
<h4 id="解决时序问题"><a href="#解决时序问题" class="headerlink" title="解决时序问题"></a><strong>解决时序问题</strong></h4><p>可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这个两个操作间隙失去cpu资源。除非将这两步骤合并成一个“原子操作”。sigsuspend函数具备这个功能。在对时序要求严格的场合下都应该使用sigsuspend替换pause。     </p>
<p>​    int sigsuspend(const sigset_t *mask);    挂起等待信号。</p>
<p>sigsuspend函数调用期间，进程信号屏蔽字由其<strong>参数mask</strong>指定。</p>
<p>​    可将某个信号（如SIGALRM）从临时信号屏蔽字mask中删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，sigsuspend函数返回后仍然屏蔽该信号。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</p>
<p>不可靠由其实现原理所致。信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</p>
<p>这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</p>
<h3 id="全局变量异步I-O"><a href="#全局变量异步I-O" class="headerlink" title="全局变量异步I/O"></a><strong>全局变量异步I/O</strong></h3><p>   分析如下父子进程交替数数程序。当捕捉函数里面的sleep取消，程序即会出现问题。请分析原因</p>
<p>​    示例中，通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。</p>
<p>​    问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。</p>
<p>如何解决该问题呢？可以使用后续课程讲到的“锁”机制。当操作全局变量的时候，通过加锁、解锁来解决该问题。</p>
<p>现阶段，我们在编程期间如若使用全局变量，应在主观上注意<strong>全局变量的异步IO</strong>可能造成的问题。</p>
<h3 id="可-不可重入函数"><a href="#可-不可重入函数" class="headerlink" title="可/不可重入函数"></a><strong>可/不可重入函数</strong></h3><p>​    一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称之为“重入”。根据函数实现的方法可分为“可重入函数”和“不可重入函数”两种。看如下时序。</p>
 <img src="/2019/09/08/Linux系统编程-信号/sig2.png">

<p>​    显然，insert函数是不可重入函数，重入调用，会导致意外结果呈现。究其原因，是该函数内部实现使用了全局变量。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ol>
<li><p>定义可重入函数，函数内不能含有全局变量及static变量，不能使用malloc、free</p>
</li>
<li><p>信号捕捉函数应设计为可重入函数</p>
</li>
<li><p>信号处理程序可以调用的可重入函数可参阅man 7 signal </p>
</li>
<li><p>没有包含在上述列表中的函数大多是不可重入的，其原因为：</p>
<p>a) 使用静态数据结构</p>
<p>b) 调用了malloc或free</p>
<p>c) 是标准I/O函数</p>
</li>
</ol>
<h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a><strong>SIGCHLD信号</strong></h2><h3 id="SIGCHLD的产生条件"><a href="#SIGCHLD的产生条件" class="headerlink" title="SIGCHLD的产生条件"></a><strong>SIGCHLD的产生条件</strong></h3><p>子进程终止时</p>
<p>子进程接收到SIGSTOP信号停止时</p>
<p>子进程处在停止态，接受到SIGCONT后唤醒时</p>
<h3 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a><strong>借助SIGCHLD信号回收子进程</strong></h3><p>子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</p>
<h3 id="子进程结束status处理方式"><a href="#子进程结束status处理方式" class="headerlink" title="子进程结束status处理方式"></a><strong>子进程结束status处理方式</strong></h3><p>pid_t waitpid(pid_t pid, int *status, int options)</p>
<p>options</p>
<p>WNOHANG</p>
<p>没有子进程结束，立即返回</p>
<p>WUNTRACED</p>
<p>如果子进程由于被停止产生的SIGCHLD，waitpid则立即返回</p>
<p>WCONTINUED</p>
<p>如果子进程由于被SIGCONT唤醒而产生的SIGCHLD，waitpid则立即返回</p>
<p>获取status</p>
<p>WIFEXITED(status)</p>
<p>子进程正常exit终止，返回真</p>
<p>WEXITSTATUS(status)返回子进程正常退出值</p>
<p>WIFSIGNALED(status)</p>
<p>子进程被信号终止，返回真</p>
<p>WTERMSIG(status)返回终止子进程的信号值</p>
<p>WIFSTOPPED(status)</p>
<p>子进程被停止，返回真</p>
<p>WSTOPSIG(status)返回停止子进程的信号值</p>
<p>WIFCONTINUED(status)</p>
<h3 id="SIGCHLD信号注意问题"><a href="#SIGCHLD信号注意问题" class="headerlink" title="SIGCHLD信号注意问题"></a><strong>SIGCHLD信号注意问题</strong></h3><ol>
<li><p>子进程继承了父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集spending。</p>
</li>
<li><p>注意注册信号捕捉函数的位置。</p>
</li>
<li><p>应该在fork之前，阻塞SIGCHLD信号。注册完捕捉函数后解除阻塞。</p>
</li>
</ol>
<h2 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a><strong>信号传参</strong></h2><h3 id="发送信号传参"><a href="#发送信号传参" class="headerlink" title="发送信号传参"></a><strong>发送信号传参</strong></h3><p>sigqueue函数对应kill函数，但可在向指定进程发送信号的同时携带参数</p>
<p>int sigqueue(pid_t pid, int sig, const union sigval value);成功：0；失败：-1，设置errno</p>
<p>​           union sigval {</p>
<p>​               int   sival_int;</p>
<p>​               void *sival_ptr;</p>
<p>​           };</p>
<p>​    向指定进程发送指定信号的同时，携带数据。但，如传地址，需注意，不同进程之间虚拟地址空间各自独立，将当前进程地址传递给另一进程没有实际意义。</p>
<h3 id="捕捉函数传参"><a href="#捕捉函数传参" class="headerlink" title="捕捉函数传参"></a><strong>捕捉函数传参</strong></h3><p>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</p>
<p>​           struct sigaction {</p>
<p>​               void     (*sa_handler)(int);</p>
<p>​               void     (*sa_sigaction)(int, siginfo_t *, void *);</p>
<p>​               sigset_t   sa_mask;</p>
<p>​               int       sa_flags;</p>
<p>​               void     (*sa_restorer)(void);</p>
<p>​           };</p>
<p>​    当注册信号捕捉函数，希望获取更多信号相关信息，不应使用sa_handler而应该使用sa_sigaction。但此时的<strong>sa**</strong>_flags必须指定为SA_SIGINFO**。siginfo_t是一个成员十分丰富的结构体类型，可以携带各种与信号相关的数据。</p>
<h2 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a><strong>中断系统调用</strong></h2><p>系统调用可分为两类：慢速系统调用和其他系统调用。</p>
<ol>
<li><p>慢速系统调用：可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，read、write、pause、wait…</p>
</li>
<li><p>其他系统调用：getpid、getppid、fork…</p>
</li>
</ol>
<p>结合pause，回顾慢速系统调用：</p>
<p>​    慢速系统调用被中断的相关行为，实际上就是pause的行为： 如，read</p>
<p>​        ① 想中断pause，信号不能被屏蔽。</p>
<p>​        ② 信号的处理方式必须是捕捉 (默认、忽略都不可以)</p>
<p>​        ③ 中断后返回-1， 设置errno为EINTR(表“被信号中断”)</p>
<p>可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRURT不重启。 SA_RESTART重启。</p>
<p>扩展了解：</p>
<p>​    sa_flags还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-进程间通信]]></title>
      <url>/2019/09/06/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<h2 id="IPC方法"><a href="#IPC方法" class="headerlink" title="IPC方法"></a><strong>IPC方法</strong></h2><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。</p>
<img src="/2019/09/06/Linux系统编程-进程间通信/ipc1.png"> 

<p>​    在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p>
<p>​    ① 管道 (使用最简单)</p>
<p>​    ② 信号 (开销最小)</p>
<p>​    ③ 共享映射区 (无血缘关系)</p>
<p>​    ④ 本地套接字 (最稳定)</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h2><h3 id="管道的概念："><a href="#管道的概念：" class="headerlink" title="管道的概念："></a><strong>管道的概念：</strong></h3><p>​    管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<ol>
<li><p>其本质是一个伪文件(实为内核缓冲区) </p>
</li>
<li><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p>
</li>
<li><p>规定数据从管道的写端流入管道，从读端流出。</p>
</li>
</ol>
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>管道的局限性：</p>
<p>① 数据自己读不能自己写。</p>
<p>​        ② 数据一旦被读走，便不在管道中存在，不可反复读取。</p>
<p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p>
<p>④ 只能在有公共祖先的进程间使用管道。</p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a><strong>pipe函数</strong></h3><p>创建管道</p>
<p>​    int pipe(int pipefd[2]);        成功：0；失败：-1，设置errno</p>
<p>函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</p>
<p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：</p>
<img src="/2019/09/06/Linux系统编程-进程间通信/ipc2.png">  

<ol>
<li><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</p>
</li>
<li><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</p>
</li>
<li><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p>
</li>
</ol>
<h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a><strong>管道的读写行为</strong></h3><p>​    使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：</p>
<ol>
<li><p>如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</p>
</li>
<li><p>如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</p>
</li>
<li><p>如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</p>
</li>
<li><p>如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>
</li>
</ol>
<p>总结：</p>
<p>① 读管道：    1. 管道中有数据，read返回实际读到的字节数。</p>
<p>​                        2. 管道中无数据：</p>
<p>​                             (1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)</p>
<p>​                             (2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</p>
<p>② 写管道：    1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</p>
<p>​                        2. 管道读端没有全部关闭： </p>
<p>​                            (1) 管道已满，write阻塞。</p>
<p>​                            (2) 管道未满，write将数据写入，并返回实际写入的字节数。</p>
<p>​    程序执行，发现程序执行结束，shell还在阻塞等待用户输入。这是因为，shell → fork → ./pipe1， 程序pipe1的子进程将stdin重定向给管道，父进程执行的ls会将结果集通过管道写给子进程。若父进程在子进程打印wc的结果到屏幕之前被shell调用wait回收，shell就会先输出$提示符。</p>
<h3 id="管道缓冲区大小"><a href="#管道缓冲区大小" class="headerlink" title="管道缓冲区大小"></a><strong>管道缓冲区大小</strong></h3><p>​    可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p>
<p>​        pipe size            (512 bytes, -p) 8</p>
<p>​    也可以使用fpathconf函数，借助参数    选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p>
<p>​        long fpathconf(int fd, int name);    成功：返回管道的大小    失败：-1，设置errno</p>
<h3 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a><strong>管道的优劣</strong></h3><p>​    优点：简单，相比信号，套接字实现进程间通信，简单很多。</p>
<p>​    缺点：1. 只能单向通信，双向通信需建立两个管道。</p>
<p>​          2. 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a><strong>FIFO</strong></h3><p>FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。</p>
<p>​    FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。</p>
<p>创建方式：</p>
<ol>
<li><p>命令：mkfifo 管道名</p>
</li>
<li><p>库函数：int mkfifo(const char *pathname,  mode_t mode);  成功：0； 失败：-1</p>
</li>
</ol>
<p>​    一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。</p>
<p>​                                                                                    </p>
<h2 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a><strong>共享存储映射</strong></h2><h3 id="文件进程间通信"><a href="#文件进程间通信" class="headerlink" title="文件进程间通信"></a><strong>文件进程间通信</strong></h3><p>使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。</p>
<h3 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a><strong>存储映射I/O</strong></h3><p>​    存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。</p>
<p>​    使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</p>
<img src="/2019/09/06/Linux系统编程-进程间通信/ipc3.png">  

<h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a><strong>mmap函数</strong></h4><p>void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); </p>
<p>返回：成功：返回创建的映射区首地址；<strong>失败：MAP_FAILED宏</strong></p>
<p>参数：    </p>
<p>​    addr:     建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</p>
<p>​    length： 欲创建映射区的大小</p>
<p>​    prot：    映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</p>
<p>​    flags：    标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)</p>
<p>​              MAP_SHARED:  会将映射区所做的操作反映到物理设备（磁盘）上。</p>
<p>​              MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。</p>
<p>​    fd：     用来建立映射区的文件描述符</p>
<p>​    offset：     映射文件的偏移(4k的整数倍)</p>
<h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a><strong>munmap函数</strong></h4><p>​    同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。</p>
<p>int munmap(void *addr, size_t length);    成功：0； 失败：-1</p>
<p>​    借鉴malloc和free函数原型，尝试装自定义函数smalloc，sfree来完成映射区的建立和释放。思考函数接口该如何设计？</p>
<p>​                                                                                        </p>
<h4 id="mmap注意事项"><a href="#mmap注意事项" class="headerlink" title="mmap注意事项"></a><strong>mmap注意事项</strong></h4><p>思考：</p>
<ol>
<li><p>可以open的时候O_CREAT一个新文件来创建映射区吗?</p>
</li>
<li><p>如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？</p>
</li>
<li><p>文件描述符先关闭，对mmap映射有没有影响？</p>
</li>
<li><p>如果文件偏移量为1000会怎样？</p>
</li>
<li><p>对mem越界操作会怎样？</p>
</li>
<li><p>如果mem++，munmap可否成功？</p>
</li>
<li><p>mmap什么情况下会调用失败？</p>
</li>
<li><p>如果不检测mmap的返回值，会怎样？</p>
</li>
</ol>
<p><strong>总结</strong>：使用mmap时务必注意以下事项:</p>
<ol>
<li><p>创建映射区的过程中，隐含着一次对映射文件的读操作。</p>
</li>
<li><p>当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</p>
</li>
<li><p>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</p>
</li>
<li><p>特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！    mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</p>
</li>
<li><p>munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</p>
</li>
<li><p>如果文件偏移量必须为4K的整数倍</p>
</li>
<li><p>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</p>
</li>
</ol>
<h3 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a><strong>mmap父子进程通信</strong></h3><p>​    父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：</p>
<p>​    MAP_PRIVATE:  (私有映射)  父子进程各自独占映射区；</p>
<p>​    MAP_SHARED:  (共享映射)  父子进程共享映射区；</p>
<p>   父进程创建映射区，然后fork子进程，子进程修改映射区内容，而后，父进程读取映射区内容，查验是否共享?                                                                                 </p>
<p>结论：父子进程共享：1. 打开的文件  2. mmap建立的映射区(但必须要使用MAP_SHARED)</p>
<h3 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a><strong>匿名映射</strong></h3><p>​    通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。</p>
<p>使用MAP_ANONYMOUS (或MAP_ANON)， 如: </p>
<p>​    int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0); </p>
<p>​    “4”随意举例，该位置表大小，可依实际需要填写。</p>
<p>需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。</p>
<p>​    ① fd = open(“/dev/zero”, O_RDWR);</p>
<p>​    ② p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</p>
<h3 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a><strong>mmap无血缘关系进程间通信</strong></h3><p>实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用MAP_SHARED了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux系统编程-进程]]></title>
      <url>/2019/09/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a><strong>程序和进程</strong></h2><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p>
<p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p>
<p>程序 → 剧本(纸)        进程 → 戏(舞台、演员、灯光、道具…)</p>
<p>同一个剧本可以在多个舞台同时上演。同样，同一个程序也可以加载为不同的进程(彼此之间互不影响)</p>
<p>如：同时开两个终端。各自都有一个bash但彼此ID不同。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p>
<p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p>
<img src="/2019/09/05/Linux系统编程-进程/fork1.png" title="This is an example image">

<h3 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a><strong>单道程序设计</strong></h3><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><strong>多道程序设计</strong></h3><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p>
<p><strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p>
<h2 id="CPU和MMU"><a href="#CPU和MMU" class="headerlink" title="CPU和MMU"></a><strong>CPU和MMU</strong></h2><img src="/2019/09/05/Linux系统编程-进程/fork2.png" title="This is an example image">

<img src="/2019/09/05/Linux系统编程-进程/fork3.png" title="This is an example image">

<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a><strong>进程控制块PCB</strong></h2><p>我们知道，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h文件中可以查看struct task_struct 结构体定义。其内部成员有很多，我们重点掌握以下部分即可：</p>
<p>* 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</p>
<p>* 进程的状态，有就绪、运行、挂起、停止等状态。</p>
<p>* 进程切换时需要保存和恢复的一些CPU寄存器。</p>
<p>* 描述虚拟地址空间的信息。</p>
<p>* 描述控制终端的信息。</p>
<p>* 当前工作目录（Current Working Directory）。</p>
<p>* umask掩码。</p>
<p>* 文件描述符表，包含很多指向file结构体的指针。</p>
<p>* 和信号相关的信息。</p>
<p>* 用户id和组id。</p>
<p>* 会话（Session）和进程组。</p>
<p>* 进程可以使用的资源上限（Resource Limit）。</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h2><p>进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。</p>
<img src="/2019/09/05/Linux系统编程-进程/fork4.png">

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a><strong>环境变量</strong></h2><p>按照惯例，环境变量字符串都是name=value这样的形式，大多数name由大写字母加下划线组成，一般把name的部分叫做环境变量，value的部分则是环境变量的值。环境变量定义了进程的运行环境，一些比较重要的环境变量的含义如下：</p>
<h4 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a><strong>PATH</strong></h4><p>可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值：</p>
<p>$ echo $PATH</p>
<h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a><strong>SHELL</strong></h4><p>当前Shell，它的值通常是/bin/bash。</p>
<h4 id="TERM"><a href="#TERM" class="headerlink" title="TERM"></a><strong>TERM</strong></h4><p>当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。</p>
<h4 id="LANG"><a href="#LANG" class="headerlink" title="LANG"></a><strong>LANG</strong></h4><p>语言和locale，决定了字符编码以及时间、货币等信息的显示格式。</p>
<h4 id="HOME"><a href="#HOME" class="headerlink" title="HOME"></a><strong>HOME</strong></h4><p>当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。</p>
<h4 id="getenv函数"><a href="#getenv函数" class="headerlink" title="getenv函数"></a><strong>getenv函数</strong></h4><p>获取环境变量值</p>
<p>​    char *getenv(const char *name);     成功：返回环境变量的值；失败：NULL (name不存在)</p>
<h4 id="setenv函数"><a href="#setenv函数" class="headerlink" title="setenv函数"></a><strong>setenv函数</strong></h4><p>设置环境变量的值    </p>
<p>​    int setenv(const char *name, const char *value, int overwrite);      成功：0；失败：-1</p>
<p>​    参数overwrite取值：    1：覆盖原环境变量 </p>
<p>0：不覆盖。(该参数常用于设置新环境变量，如：ABC = haha-day-night)</p>
<h4 id="unsetenv函数"><a href="#unsetenv函数" class="headerlink" title="unsetenv函数"></a><strong>unsetenv函数</strong></h4><p>删除环境变量name的定义</p>
<p>​    int unsetenv(const char *name);     成功：0；失败：-1 </p>
<p>​    注意事项：name不存在仍返回0(成功)，当name命名为”ABC=”时则会出错。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><strong>进程控制</strong></h2><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><strong>fork函数</strong></h4><p>创建一个子进程。</p>
<p>pid_t fork(void);    失败返回-1；成功返回：① 父进程返回子进程的ID(非负)    ②子进程返回 0 </p>
<p>pid_t类型表示进程ID，但为了表示-1，它是有符号整型。(0不是有效进程ID，init最小，为1)</p>
<p>​    注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。</p>
<img src="/2019/09/05/Linux系统编程-进程/fork6.png">

<p>从上图我们可以很清晰的看到，当n为3时候，循环创建了(2^n)-1个子进程，而不是N的子进程。需要在循环的过程，保证子进程不再执行fork ，因此当(fork() == 0)时，子进程应该立即break;才正确。</p>
<h4 id="循环创建n个子进程"><a href="#循环创建n个子进程" class="headerlink" title="循环创建n个子进程"></a><strong>循环创建n个子进程</strong></h4><p>一次fork函数调用可以创建一个子进程。那么创建N个子进程应该怎样实现呢？</p>
<p>简单想，for(i = 0; i &lt; n; i++) { fork() } 即可。但这样创建的是N个子进程吗？</p>
<h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a><strong>getpid函数</strong></h4><p>获取当前进程ID</p>
<p>​    pid_t getpid(void);        </p>
<h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a><strong>getppid函数</strong></h4><p>​    获取当前进程的父进程ID</p>
<p>​        pid_t getppid(void);</p>
<p>区分一个函数是“系统函数”还是“库函数”依据：</p>
<p>​    ① 是否访问内核数据结构</p>
<p>​    ② 是否访问外部硬件资源        二者有任一 → 系统函数；二者均无 → 库函数</p>
<h4 id="getuid函数"><a href="#getuid函数" class="headerlink" title="getuid函数"></a><strong>getuid函数</strong></h4><p>获取当前进程实际用户ID</p>
<p>uid_t getuid(void);</p>
<p>​    获取当前进程有效用户ID</p>
<p>uid_t geteuid(void);</p>
<h4 id="getgid函数"><a href="#getgid函数" class="headerlink" title="getgid函数"></a><strong>getgid函数</strong></h4><p>​    获取当前进程使用用户组ID</p>
<p>gid_t getgid(void);</p>
<p>​    获取当前进程有效用户组ID</p>
<p>gid_t getegid(void);</p>
<h2 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a><strong>进程共享</strong></h2><p>父子进程之间在fork后。有哪些相同，那些相异之处呢？</p>
<p>刚fork之后：</p>
<p>父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…</p>
<p>父子不同处: 1.进程ID   2.fork返回值   3.父进程ID    4.进程运行时间    5.闹钟(定时器)   6.未决信号集</p>
<p>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</p>
<p>当然不是!父子进程间遵循<strong>读时共享写时复制</strong>的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。   </p>
<p>重点注意！躲避父子进程共享全局变量的知识误区！</p>
<p>【重点】：父子进程共享：1. 文件描述符(打开文件的结构体)  2. mmap建立的映射区 (进程间通信详解)</p>
<p>特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。</p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><strong>gdb调试</strong></h3><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p>
<p>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</p>
<p>set follow-fork-mode parent 设置跟踪父进程。</p>
<p>注意，一定要在fork函数调用之前设置才有效。</p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a><strong>exec函数族</strong></h2><p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</p>
<p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</p>
<p>其实有六种以exec开头的函数，统称exec函数：</p>
<p>int execl(const char *path, const char *arg, …);</p>
<p>int execlp(const char *file, const char *arg, …);</p>
<p>int execle(const char *path, const char *arg, …, char *const envp[]);</p>
<p>int execv(const char *path, char *const argv[]);</p>
<p>int execvp(const char *file, char *const argv[]);</p>
<p>int execve(const char *path, char *const argv[], char *const envp[]);</p>
<h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h4><p>加载一个进程，借助PATH环境变量         </p>
<p>int execlp(const char *file, const char *arg, …);        成功：无返回；失败：-1</p>
<p>​    参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</p>
<p>​    该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。</p>
<h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h4><p>加载一个进程， 通过 路径+程序名 来加载。 </p>
<p>​    int execl(const char *path, const char *arg, …);        成功：无返回；失败：-1</p>
<p>对比execlp，如加载”ls”命令带有-l，-F参数</p>
<p>execlp(“ls”, “ls”, “-l”, “-F”, NULL);         使用程序名在PATH中搜索。</p>
<p>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL);    使用参数1给出的绝对路径搜索。</p>
<h4 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h4><p>加载一个进程，使用自定义环境变量env</p>
<p>int execvp(const char *file, const char *argv[]);</p>
<p>变参形式： ①… ② argv[]  (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …)) </p>
<p>变参终止条件：① NULL结尾 ② 固参指定</p>
<p>execvp与execlp参数形式不同，原理一致。</p>
<h4 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a><strong>exec函数族一般规律</strong></h4><p>exec函数一旦调用成功即执行新的程序，不返回。<strong>只有失败才返回，错误值-1</strong>。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</p>
<p>l (list)            命令行参数列表</p>
<p>p (path)            搜素file时使用path变量</p>
<p>v (vector)            使用命令行参数数组</p>
<p>e (environment)    使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p>
<p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示。</p>
<img src="/2019/09/05/Linux系统编程-进程/fork5.png">

<h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a><strong>回收子进程</strong></h2><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a><strong>孤儿进程</strong></h4><p>​    孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a><strong>僵尸进程</strong></h4><p>僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。  </p>
<p>特别注意，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。思考！用什么办法可清除掉僵尸进程呢？</p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a><strong>wait函数</strong></h4><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p>
<p>① 阻塞等待子进程退出 </p>
<p>② 回收子进程残留资源 </p>
<p>③ 获取子进程结束状态(退出原因)。</p>
<p>​    <strong>pid_t wait(int *status);</strong>     成功：清理掉的子进程ID；失败：-1 (没有子进程)</p>
<p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p>
<p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</p>
<p> \1.  WIFEXITED(status) 为非0    → 进程正常结束</p>
<p>​    WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</p>
<p> \2.     WIFSIGNALED(status) 为非0 → 进程异常终止</p>
<p>​    WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p>
<p>*3.     WIFSTOPPED(status) 为非0 → 进程处于暂停状态</p>
<p>​    WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。</p>
<p>​    WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行</p>
<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h4><p>作用同wait，但可指定pid进程清理，可以不阻塞。</p>
<p>​    <strong>pid_t waitpid(pid_t pid, int *status, in options);</strong>    成功：返回清理掉的子进程ID；失败：-1(无子进程)</p>
<p>特殊参数和返回情况：</p>
<p>参数pid： </p>
<p><strong>&gt; 0 回收指定ID的子进程</strong>    </p>
<p><strong>-1 回收任意子进程（相当于wait）</strong></p>
<p>0 回收和当前调用waitpid一个组的所有子进程</p>
<p>​        &lt; -1 回收指定进程组内的任意子进程</p>
<p>返回0：参3为WNOHANG，且子进程正在运行。</p>
<p>注意：<strong>一次wait或waitpid调用只能清理一个子进程</strong>，清理多个子进程应使用循环。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
